---
layout:     post
title:      "Linux"
date:       2019-3-27
author:     Tong
catalog: true
tags:
    - Algorithm
---

### 真题

1. 下面关于系统调用的描述中,错误的是()
<ol type="A">
  <li>系统调用把应用程序的请求传输给系统内核执行</li>
  <li>系统调用中被调用的过程运行在"用户态"中</li>
  <li>利用系统调用能够得到操作系统提供的多种服务</li>
  <li>是操作系统提供给编程人员的接口</li>
  <li>系统调用给用户屏蔽了设备访问的细节</li>
  <li>系统调用保护了一些只能在内核模式执行的操作指令</li>
</ol>

> Solution: B. <br>
> 系统调用通过中断完成，这一过程中系统由用户态变为内核态。 在内核态下，系统可以无限制的访问内核资源. <br>
>  用户空间与系统空间所在的内存区间不一样，同样，对于这两种区间，CPU的运行状态也不一样。 在用户空间中，CPU处于"用户态"；在系统空间中，CPU处于"系统态"。


2. 关于linux的I/O复用接口select和epoll,下列说法错误的是()
<ol type="A">
  <li>select调用时会进行线性遍历,epoll采用回调函数机制,不需要线性遍历</li>
  <li>select的最大连接数为FD_SETSIZE</li>
  <li>select较适合于有大量并发连接,且活跃链接较多的场景</li>
  <li>epoll较适用于有大量并发连接，但活跃连接不多的场景</li>
  <li>epoll的效率不随FD数目增加而线性下降</li>
  <li>epoll通过共享存储实现内核和用户的数据交互</li>
</ol>

> Solution: C. <br>
> select 和 epoll效率差异的原因：select采用轮询方式处理连接，epoll是触发式处理连接。<br>
Select:
1.Socket数量限制：该限制可操作的Socket数由FD_SETSIZE决定，内核默认32*32=1024.
2.操作限制：通过遍历FD_SETSIZE(1024)个Socket来完成调度，不管哪个Socket是活跃的，都遍历一遍。<br>
Epoll: <br>
1.Socket数量无限制：该模式下的Socket对应的fd列表由一个数组来保存，大小不限制（默认4k）。
2.操作无限制：基于内核提供的反射模式，有活跃Socket时，内核访问该Socket的callback，不需要遍历轮询。
但当所有的Socket都活跃的时候，所有的callback都被唤醒，会导致资源的竞争。既然都是要处理所有的Socket，
那么遍历是最简单最有效的实现方式。
