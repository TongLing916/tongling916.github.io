---
layout:     post
title:      "Python 3"
date:       2019-8-24
author:     Tong
catalog: true
tags:
    - Python
---

### Basics

#### 标识符

1. 第一个字符必须是字母表中字母或下划线 _ 。
2. 标识符的其他的部分由字母、数字和下划线组成。
3. 标识符对大小写敏感。
4. 不可以是python中的关键字，如False、True、None、class等。

#### 赋值

```python
x = y = z = 1           # 多重赋值，True
x, y, z = 1, 3, 'hello' # 多元赋值，True
x += 1                  # 增量赋值，True
y = (x = x + 1)         # False, 等号右边不能时赋值语句
```

#### __name__

```python
class Person:
    def __init__(self):
        pass
    def getAge(self):
        print(__name__) # __main__

p = Person()
p.getAge()
print(p.getAge.__name__) # getAge
```


### 数值及其运算

#### 复数

```python
a = 1 + 2j
b = 1 + 2J

print(a)            # (1+2j)
print(b)            # (1+2j)
print(a == b)       # True
print(a.imag)       # 2.0
print(a.real)       # 1.0
print(type(a.imag)) # <class 'float'>
print(a > b)        # TypeError: '>' not supported between instances of 'complex' and 'complex'
```

#### Bool为False的值

```python
a = None
b = 0
c = 0.0
d = 0.0 + 0.0j
e = ""
f = [] # empty list is False
g = () # empty tuple is False
h = {} # empty dict

if a or b or c or d or e or f or g:
    print("True")
else:
    print("False")  # False will be our output
```


#### 逻辑运算符

```python
a = []
b = 'Wang'
c = 'Ling'
d = {}

# a and b
# if a is False, return a
# else return b
print(a and b) # []
print(b and c) # Ling
print(b and d) # {}

# a or b
# if a is True, return a
# else return b
print(a or b)  # Wang
print(b or c)  # Wang
print(a or d)  # {}


print(not a) # True
print(not b) # False
```


#### 比较大小

```bash
1. 复数不支持比较大小

2. 类似元组、字符串、列表这类格式，在进行两者之间的比较时，先从第一个元素开始比较 ASCII 码值大小，如果相等，则依次向后比较，如果全部相等，则比较数量大小。

3. ASCII 码值大小:
   3.1 数字:
       0-9: 48-57

   3.2 字母
       A-Z: 65-90
       a-z: 97-122

4. Python2 支持数字与字符串之间的比较，而 Python3 则不支持。

5. 连续比较：`'a' < 'b' < 'c'`表示 `'a' < 'b' and 'b' < 'c'`
```

### String

#### 结尾

Python中的字符串并 **不是** 像C/C++一样以'\0'结尾，而是一个固定长度的字符数组。


#### startswith / endswith

```bash
string.startswith(str, beg, end)
string.endswith(str, beg, end)

string： 被检测的字符串
str：    指定的字符或者子字符串（可以使用元组，会逐一匹配）
beg：    设置字符串检测的起始位置（可选，从左数起）
end：    设置字符串检测的结束位置（可选，从左数起）
```

```python
s = 'Wang Yi Hui'
print(s.startswith('Wang'))     # True (beg，end为可选输入)
print(s.startswith('Yi', 5))    # True
print(s.startswith('Yi', 5, 6)) # False (搜索位置不包含end)
print(s.startswith('Yi', 5, 7)) # True
print(s.startswith('Yi', 6))    # False

print(s.endswith('Hui', 8))     # True
print(s.endswith('Hui', 9))     # False
print(s.endswith('Hui', 1))     # True, beg只要在'Hui'出现及出现之前即可
print(s.endswith('Hui'))        # True
print(s.endswith('Hui', 8, 10)) # False
print(s.endswith('Hui', 8, 11)) # True

```

#### encode / decode (To-Do)

1. Python 2.7 Unicode编码的书写方式
   * a = u'中文'
   * a = unicode("我不是乱码", "utf-8")


### re (正则表达式)

#### 基本规则

1. `\d`可以匹配一个数字

2. `\w`可以匹配一个字母或数字

3. `\s`可以匹配一个空格（或者Tab等空白符）

4. `.`可以匹配任意字符

5. `*`表示匹配任意个字符

6. `+`表示至少一个字符

7. `?`表示0或1个字符

8. `{n}`表示n个字符

9. `{n, m}`表示n-m个字符

10. 对于特殊字符，要用`\`转义，例如要想匹配`-`，我们得写成`\-`

11. `[]`可以用来表示范围
    * `[0-9a-zA-Z\_]`可以匹配一个数字，字母或者下划线
    * `[0-9a-zA-Z\_]+`可以匹配 **至少** 一个数字，字母或者下划线组成的字符串，例如`a100`
    * `[0-9a-zA-Z\_]*`可以匹配由 **任意个** 数字，字母或者下划线组成的字符串
    * `[0-9a-zA-Z\_]{0, 19}`可以匹配长度为0到19的由数字，字母或者下划线组成的字符串。

12. `A|B`表示匹配A或者B，所以`(P|p)ython`可以匹配`Python`或者`python`

13. `^`表示行的开头，`^\d`表示必须以数字开头

14. `$`表示行的结束，`\d$`表示必须以数字结束

15. `^py$`表示整行匹配，所以我们只能匹配`py`

16. 可以使用`r`前缀，就不用考虑转义问题了

```python
s1 = 'ABC\\-001'
s2 = r'ABC\-001'
print(s1 == s2) # True
```

#### match()

`match()`成功匹配的话，返回一个`Match`对象，否则返回`None`。

```python
import re

# re.Match object; span=(0, 9), match='010-12345'>
print(re.match('\d{3}\-\d{3,8}$', '010-12345'))

# None
print(re.match('\d{3}\-\d{3,8}$', '010 12345'))
```

#### split()

```python
import re

print('a b  c'.split(' '))                   # ['a', 'b', '', 'c']
print(re.split(r'[\s]+', 'a b  c'))          # ['a', 'b', 'c']
print(re.split(r'[\s\,]+', 'a,,b,  c'))      # ['a', 'b', 'c']
print(re.split(r'[\s\,\;]+', 'a,, b;;;  c')) # ['a', 'b', 'c']
```

#### group()

`()`表示要提取的分组。比如：`^(\d{3})-(\d{3,8})$`表示两个分组，可以直接从匹配的字符串提取出区号和本地号码。

```python
import re

m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
print(m.group(0)) # 010-12345
print(m.group(1)) # 010
print(m.group(2)) # 12345
```

#### 贪婪匹配

正则匹配默认时贪婪匹配。加个`?`就可以采用非贪婪匹配。

```python
import re

print(re.match(r'^(\d+)(0*)$', '102300').groups())  # ('102300', '')
print(re.match(r'^(\d+?)(0*)$', '102300').groups()) # ('1023', '00')

```

#### 可选标志

1. `re.I`表示对大小写不敏感

2. `re.L`表示做本地化识别 (local-aware) 匹配

3. `re.M`表示多行匹配，影响`^`和`$`

4. `re.S`表示使`.`匹配包括换行在内的所有字符

5. `re.U`根据Unicode字符集解析字符。这个标志影响 `\w`, `\W`, `\b`, `\B`.

6. `re.X`该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。

```python
import re

str1 = "Python's features"
str2 = re.match( r'(.*)on(.*?) .*', str1, re.M|re.I)
print(str2.group(1)) # Pyth
```

### List

#### Delete

```python
bicycles = ['trek', 'canodale', 'redline', 'specialized']

del bicycles[0]
print(bicycles)           # ['canodale', 'redline', 'specialized']

print(bicycles.pop())     # specialized

print(bicycles.pop(0))    # canodale

bicycles.remove('redline')
print(bicycles)           # []
```


#### Sort

`nums.sort()` 改变原数组的排列顺序，`sorted(nums)`不改变。

```python
nums = [2, 1, 4, 3]

print(sorted(nums)) # [1, 2, 3, 4]

print(nums)         # [2, 1, 4, 3]


nums.sort()
print(nums)        # [1, 2, 3, 4]

```

#### Copy


```python
nums = [1]
nums_1 = nums[:] # 创建了一个新的数组nums_1
nums_2 = nums    # nums_2就是原数组nums的另一个名称，地址相同
print(nums_1)    # [1]
print(nums_2)    # [1]


nums.append(100)
print(nums_1)    # [1]
print(nums_2)    # [1, 100]
```

##### Shallow Copy vs. Deep Copy

```python
import copy

# 对于简单的object, 例如数字, list,
# 浅拷贝和深拷贝没区别
# 注意：此时，对原元素的修改不会引起拷贝后元素的改变
a = 1000
b = copy.copy(a)
c = copy.deepcopy(a)
print(a is b)         # True
print(b is c)         # True

a = 1
print(b)              # 1000
print(c) # 1000

d = [1, 2, 3]
e = copy.copy(d)
f = copy.deepcopy(d)
print(d is e)         # False
print(e is f)         # False

d.append(4)
print(e)              # [1, 2, 3]
print(f)              # [1, 2, 3]


g = {1 : 1, 2 : 2}
h = copy.copy(g)
i = copy.deepcopy(g)
print(e is f)         # False

g[1] = 5
print(h)              # {1: 1, 2: 2}
print(i)              # {1: 1, 2: 2}

```

```python
import copy

# 对于复杂的object, 例如list套list
# 浅拷贝和深拷贝有区别
# 浅拷贝只会复制list里的第一层，我们仍然能通过改变浅拷贝后的元素来修改原数组
# 深拷贝会完全复制每一层，这个深拷贝后的数组和原来的没有任何关系
a = [1, 2, [3, 4]]
b = copy.copy(a)
c = copy.deepcopy(a)
print(a is b) # False
print(b is c) # False

# 对第一层的元素进行修改，毫无影响
a[0] = 1000
print(b) # [1, 2, [3, 4]]
print(c) # [1, 2, [3, 4]]


# 对第二层的元素进行修改，浅拷贝的元素会受到影响, 即使index可能发生改变
a[2].append(100)
print(b) # [1, 2, [3, 4, 100]]
print(c) # [1, 2, [3, 4]]


del a[1]
print(a)        # [1000, [3, 4, 100]]
a[1].append(200)
print(a)        # [1000, [3, 4, 100, 200]]
print(b)        # [1, 2, [3, 4, 100, 200]]
print(c)        # [1, 2, [3, 4]]
```


#### append() vs. extend()

```python
numbers = [1, 2, 3, 4]

numbers.append([5,6,7,8])
print(numbers)                  # [1, 2, 3, 4, [5, 6, 7, 8]]
print(len(numbers))             # 5

numbers.extend([9, 10, 11, 12])
print(numbers)                  # [1, 2, 3, 4, [5, 6, 7, 8], 9, 10, 11, 12]
print(len(numbers))             # 9

```


### 元组 (tuple, 可以用index访问)

里面元素不可变，它本身可以变化。

#### Init

```python
dimensions = (200, 50)
print(dimensions[0])
dimensions = (400, 100) # correct

a = (1)   # 这只是个int，不是tuple
b = (1, ) # 单个元素的时候，我们要加上个逗号，这样才能表示tuple
```


### 字典 (dict, 无序)

#### Init

```python
alien_0 = {'color': 'green', 'points': '5'}
print(alien_0['color'])


# key必须是不可变的
dict1 = {}                 # True
dict2 = { 3 : 5 }          # True
dict3 = {[1,2,3]: "uestc"} # ERROR: unhashable type: 'list'
dict4 = {(1,2,3): "uestc"} # True
```

#### Delete

```python
alien_0 = {'color': 'green', 'points': '5'}
print(alien_0)              # {'color': 'green', 'points': '5'}

del alien_0['points']
print(alien_0)              # {'color': 'green'}

print(alien_0.pop('color')) # green
print(alien_0)              # {}

```

#### Traverse

```python
user_0 = {'username': 'Tong', 'first': 'April', 'last': 'Wang'}
print(user_0) # {'username': 'Tong', 'last': 'Wang', 'first': 'April'}

for key, value in user_0.items():
    print("\nKey: " + key)
    print("Value: " + value)

# 顺序可能会发生改变
#    Key: username
#    Value: Tong

#    Key: last
#    Value: Wang

#    Key: first
#    Value: April

# for key in user_0.keys(): 等价于 for key in user_0:
# user_0.keys() 返回一个列表
for key in user_0.keys():
    print("\nKey: " + key)
```


### OrderedDict (记录键-值对的加入顺序)

```python
from collections import OrderedDict

favorite_languages = OrderedDict()

favorite_languages['april'] = 'python'
favorite_languages['tong'] = 'c++'
favorite_languages['edison'] = 'ruby'

#April's favorite language is Python.
#Tong's favorite language is C++.
#Edison's favorite language is Ruby.
for name, language in favorite_languages.items():
    print(name.title() + "'s favorite language is " + language.title() + ".")

```

### 集合（set, 不重复的元素，无序，不能用index）

#### Init

```python
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket) # {'apple', 'pear', 'banana', 'orange'}

a = set('abracadabra')
print(a) # {'c', 'a', 'd', 'r', 'b'}

nums = [1, 2, 3, 3, 4]
print(set(nums)) # {1, 2, 3, 4}

```



### 函数

#### 返回值

1. `return`没有返回值时，函数自动返回`None`，Python没有`NULL`

2. `return`可以返回多个值

3. 执行到`return`时，程序将停止函数内`return`后面的语句

4. 函数中`return`不是必须的

#### 实参和形参

如果要想给形参指定 **默认值**，那么在形参列表中必须先列出没有默认值的形参，再列出有默认值的形参。

```python
def describe_pet(pet_name, animal_type='dog'):
    print("\nI have a " + animal_type + ".")
    print("My " + animal_type + "'s name is " + pet_name.title() + ".")

#I have a dog.
#My dog's name is Willie.
describe_pet(pet_name='willie')

#I have a dog.
#My dog's name is Willie.
describe_pet('willie')

#I have a hamseter.
#My hamseter's name is Willie.
describe_pet('willie', 'hamseter')

```

#### 禁止函数修改列表

```python
# 传递副本而非列表本身
function_name(list_name[:])

```


#### 传递任意数量的实参

用带一个星号的形参，是指用一个元组来存储传递过来的实参。

```python
def make_pizza(*toppings):
    print(toppings)

make_pizza('pepperoni') # ('pepperoni',)

make_pizza('mushrooms', 'green peppers', 'extra cheese') # ('mushrooms', 'green peppers', 'extra cheese')

```

用带两个星号的实参，是指来接受任意数量的关键子实参（键-值对）。

```python
def build_profile(first, last, **user_info):
    profile = {}
    profile['first_name'] = first
    profile['last_name'] = last
    for key, value in user_info.items():
        profile[key] = value
    return profile

user_profile = build_profile('albert', 'einstein', location='princeton', field='physics')

# {'last_name': 'einstein', 'first_name': 'albert', 'location': 'princeton', 'field': 'physics'}
print(user_profile)
```

#### 作为元素添加到集合

```python
def foo():
    print('from foo')
dic={'func':foo}

foo()              # 'from foo'
print(dic['func']) # <function foo at 0x000001905BD5C1E0>
dic['func']()      # 'from foo'
```

#### 作为参数值传递给其它函数

```python
def foo():
    print('from foo')

def bar(func):
    print(func)
    func()

bar(foo)

# <function foo at 0x000001D9556EC1E0>
# from foo
```

#### 函数嵌套

```python
def bar(multiple):
    def foo(n):
        return multiple ** n
    return foo  # 我们可以把foo想象成一个一个元素，其中multiple为输入的multiple

print(bar(2)(3)) # 2**3 = 8

```

#### 闭包 (closure) To-Do


#### print()

```python
print('\n')  # new line
print('\\n') # \n
print(r'\n') # \n
             # 'r'代表原始字符串标识符，该字符串中的特殊符号不会被转义
```


#### xrange() (只存在Python2里面，Python3里面没了)

1. `xrange()` 函数用法与 `range()` 完全相同。只是`xrange()`生成的时生成器而不是数组。

2. 要生成很大的数字序列的时候，用`xrange`会比`range`性能优很多，因为不需要一上来就开辟一块很大的内存空间。

#### map()

```python
# map(function_to_apply, list_of_inputs)
# lambda argument: manipulate(argument)

a = map(lambda x : x**3, [1, 2, 3]) # map object
print(list(a))                      # [1, 8, 27]

```

#### 装饰器 (decorator)

```python
def a_new_decorator(a_func):
    def wrapTheFunction():
        print("I am doing some boring work before a_func()")
        a_func()
        print("I am doing some boring work after a_func()")
    return wrapTheFunction

def a_function_requiring_decoration():
    print("I am the function which needs decoration")

a_function_requiring_decoration()
# I am the function which needs decoration

a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)

a_function_requiring_decoration()
# I am doing some boring work before a_func()
# I am the function which needs decoration
# I am doing some boring work after a_func()
```

上面的代码等价于下面

```python
def a_new_decorator(a_func):
    def wrapTheFunction():
        print("I am doing some boring work before a_func()")
        a_func()
        print("I am doing some boring work after a_func()")
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    print("I am the function which needs decoration")

a_function_requiring_decoration()
# I am doing some boring work before a_func()
# I am the function which needs decoration
# I am doing some boring work after a_func()

print(a_function_requiring_decoration.__name__) # wrapTheFunction
```

为了保持函数名称不变，我们可以使用`@wraps()`

```python
from functools import wraps

def a_new_decorator(a_func):
    @wraps(a_func)
    def wrapTheFunction():
        print("I am doing some boring work before a_func()")
        a_func()
        print("I am doing some boring work after a_func()")
    return wrapTheFunction

@a_new_decorator
def a_function_requiring_decoration():
    print("I am the function which needs decoration")

print(a_function_requiring_decoration.__name__) # a_function_requiring_decoration

```

例子
```python
def dec(f):
    n = 3
    def wrapper(*args,**kw):
        return f(*args,**kw) * n
    return wrapper

@dec
def foo(n):
    return n * 2

print(foo(2)) # 12 = (2 * 2) * 3
print(foo(3)) # 18 = (3 * 2) * 3
```



### Class

#### Init

```python
class Dog():

    # 创建新实例时，自动运行
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def sit(self):
        print(self.name.title() + " is now sitting.")

    def roll_over(self):
        print(self.name.title() + " rolled over!")

my_dog = Dog('willie', 6)
print(my_dog.age)
```


#### 继承

```python
class Car():
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = str(self.year) + ' ' + self.make + ' ' + self.model
        return long_name.title()

class Battery():
    def __init__(self, battery_size=70):
        self.battery_size = battery_size()

class ElectricCar(Car):
    def __init__(self, make, model, year):
        # super()让ElectricCar实例包含父类的所有属性
        super().__init__(make, model, year)
        self.battery = Battery()
```

#### `__new__` vs. `__init__`

1. `__init__`方法为初始化方法（什么都不返回）, `__new__`方法才是真正的构造函数。

2. `__new__`方法默认返回实例对象供`__init__`方法、实例方法使用。

3. `__init__`方法为初始化方法，为类的实例提供一些属性或完成一些动作 （只有在`__new__`返回一个cls的实例时，后面的`__init__`才能被调用）。

4. `__new__`方法创建实例对象供`__init__`方法使用，`__init__`方法定制实例对象。

5. `__new__`是一个静态方法，而`__init__`是一个实例方法。

6. 当创建一个新实例时调用`__new__`，初始化一个实例时用`__init__`。


#### 成员命名方式

1. `object`: 公用方法

2. `_object`: 半保护, 被看作是`protected`(但python中其实只分`public`和`private`)，意思是只有类对象和子类对象自己能访问到这些变量，在模块或类外不可以使用，不能用`from module import *`导入。

3. `_ _object`: 全私有，全保护。私有成员`private`，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据，不能用`from module import *`导入。`_ _object` 会导致Python解释器重写属性名称， 对于该标识符描述的方法，父类的方法不能轻易地被子类的方法覆盖，他们的名字实际上是`_classname__methodname`。

4. `_ _object_ _`: 内建方法，用户不要这样定义。


### Exception

#### ZeroDivisionError

```python
first_number = input("First number\n")
second_number = input("\nSecond number\n")
try:
    answer = int(first_number) / int(second_number)
except ZeroDivisionError:
    print("You can't divide by 0!")
else:
    print(answer)
```

#### FileNotFoundError

```python
filename = "alice.txt"

try:
    with open(filename) as f_obj:
        contents = f_obj.read()
except FileNotFoundError:
    msg = "Sorry, the file " + filename + " does not exist."
    print(msg)
```

#### 运行过程

* 程序异常执行except
* 程序正常执行try和else
* 无论程序正常执行还是出现异常都执行final


### Test

#### Unit test
```python
def get_formatted_name(first, last):
    full_name = first + ' ' + last
    return full_name.title()

import unittest

class NamesTestCase(unittest.TestCase):
    def setUp(self):
        # 创建一些对象用在各个test_里面
        # 这个方法在test_各种方法之前运行

    # all fucntions beginning with "test_" will be tested
    def test_first_last_name(self):
        formatted_name = get_formatted_name('janis', 'joplin')
        self.assertEqual(formatted_name, 'Janis Joplin')

unittest.main()
```


### 协程 (coroutine) To-Do

1. 一个线程可以运行多个协程

2. 协程的调度由所在程序自身控制

3. Linux中线程的调度由操作系统控制

```python
def grep(pattern):
    print("Searching for", pattern)
    while True:
        line = (yield)
        if pattern in line:
            print(line)

search = grep('coroutine')
next(search)                                # Output: Searching for coroutine

search.send("I love you")
search.send("Don't you love me?")
search.send("I love coroutines instead!")   # Output: I love coroutines instead!

search.close()
```


### Socket

1. `connect()`: 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。

2. `getsockname()`: 返回套接字自己的地址。通常是一个元组(ipaddr,port)

3. `listen()`: 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。

4. `recvfrom()`: 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。
