---
layout:     post
title:      "Arrays"
date:       2019-5-9
author:     Tong
catalog: true
tags:
    - Arrays
---

### Summary

1.


### [53. Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)

#### Question

Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

__Example 1:__
```
Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
```

#### Train of Thought

The aim is to find the maximum subarray. Therefore, it is necessary to create a variable named `maxValue`, which should be compared with different subarrays.

The difficulty is how to traverse all the subarrays. A naive thought is brute force. However, is it possible to traverse in `O(n)` time? Every time when we access an element e.g. `nums[i]`, we just need compare the `maxValue` with the biggest subarray which ends at `nums[i]`. Then, after we have scanned the whole vector, we have already done with the finding process.

To get the biggest subarray which ends at `nums[i]`, we just need to compare `nums[i]` with (`nums[i]` + the biggest subarray ending at `nums[i-1]`).

#### Solution
```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

class Solution {
public:
	int maxSubArray(vector<int>& nums) {
		int n = nums.size();
		if (n == 0)
			return 0;
		int maxValue = nums[0];
		int cur = nums[0];

		for (int i = 1; i < n; ++i)
		{
			cur = max(nums[i], cur + nums[i]);
			maxValue = max(maxValue, cur);
		}
		return maxValue;
	}
};
int main()
{
	Solution solution;
	vector<int> nums{ -2,1,-3,4,-1,2,1,-5,4 };

	cout << solution.maxSubArray(nums) << endl;
}
```
