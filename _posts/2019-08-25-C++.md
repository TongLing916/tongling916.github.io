---
layout:     post
title:      "C++"
date:       2019-8-25
author:     Tong
catalog: true
tags:
    - Language
---

### Basics

#### 面向对象

面向对象的三大特性：封装、继承、多态

#### OOP: 面向对象程序设计

数据抽象，继承和动态绑定。


#### 左值，右值

* 左值是变量的地址，右值是变量存储的内容。变量本质即存储空间的名称，编译后变为对应地址。

* 左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用，而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。
* 左值引用

```c++
int a = 3;
int & ref_a = a; //指针是一种数据类型，而引用不是。当其用作函数传参时，传递的就是变量的左值即地址。
```

* 右值引用
    * 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
    * 能够更简洁明确地定义泛型函数；
    * 右值引用形式：类型 && a= 被引用的对象。与左值的区别在于：右值是临时变量，如函数返回值，且不变。
    * 右值引用可以理解为右值的引用，右值初始化后临时变量消失。

#### sizeof()

* Padding

* Pragma


#### STL - Standard Template Library

* 容器（Container），是一种数据结构，如list，vector，和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；

* 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；

* 算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；

* 仿函数（Function object）

* 迭代适配器（Adaptor）

* 空间配制器（allocator）




### 基本数据类型

#### float vs. double

* A float is a single precision, 32-bit floating-point data type that accommodates seven digits. Its range is approximately 1.5 × 10^−45 to 3.4 × 10^38.

* A double is a double-precision, 64-bit floating-point data type. It accommodates 15 to 16 digits, with a range of approximately 5.0 × 10^−345 to 1.7 × 10^308.



### vector

#### 初始化

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// initialization
	vector<int> v1{ 1, 2, 3 };  // [1, 2, 3]
	cout << "v1" << endl << v1 << endl << endl;
	vector<int> v2(5, 0);		// [0, 0, 0, 0, 0]
	cout << "v2" << endl << v2 << endl << endl;
	vector<int> v3(v2.begin(), v2.end());
	cout << "v3" << endl << v3 << endl << endl;
	int arr4[] = { 10, 20, 30 };
	vector<int> v4(arr4, arr4 + sizeof(arr4) / sizeof(arr4[0]));
	cout << "v4" << endl << v4 << endl << endl;
	vector<int> v5;
	v5.push_back(1);
	v5.push_back(2);
	cout << "v5" << endl << v5 << endl << endl;
	vector<vector<int>> v6(3, vector<int>(4, -1));  // 3 x 4
}
```




#### 添加元素

 * `push_back()`

 ```c++
void push_back (const value_type& val);
void push_back (value_type&& val);
```

在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。
引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。




 * `emplace_back()`

```c++
template <class... Args>
  void emplace_back (Args&&... args);
```

在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。

```c++
// https://blog.csdn.net/xiaolewennofollow/article/details/52559364

#include <vector>  
#include <string>  
#include <iostream>  

struct President
{
	std::string name;
	std::string country;
	int year;

	President(std::string p_name, std::string p_country, int p_year)
		: name(std::move(p_name)), country(std::move(p_country)), year(p_year)
	{
		std::cout << "I am being constructed.\n";
	}
	President(const President& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being copy constructed.\n";
	}
	President(President&& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being moved.\n";
	}
	President& operator=(const President& other);
};

int main()
{
	std::vector<President> elections;
	std::cout << "emplace_back:\n";
	elections.emplace_back("Nelson Mandela", "South Africa", 1994); //没有类的创建  

	std::vector<President> reElections;
	std::cout << "\npush_back:\n";
	reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));

	std::cout << "\nContents:\n";
	for (President const& president : elections) {
		std::cout << president.name << " was elected president of "
			<< president.country << " in " << president.year << ".\n";
	}
	for (President const& president : reElections) {
		std::cout << president.name << " was re-elected president of "
			<< president.country << " in " << president.year << ".\n";
	}

}
```


```bash
emplace_back:
I am being constructed.

push_back:
I am being constructed.
I am being moved.

Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.
```


#### 动态扩展

由下面例子可以看到，`vector`在添加元素时，会多次重新分配内存。但是，当vector在删除元素的时候，容量并不会随着减小。vector的增容方式为： 0  1  2  3  4  6 ... 从第三项开始基本遵循`capacity = capacity + capacity / 2`这个规律。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	cout << "orignal capacity: " << v.capacity() << endl;
	auto capacity = v.capacity();
	for (int i = 0; i < 1000; ++i)
	{
		v.push_back(i);
		if (v.capacity() != capacity)
		{
			cout << "new capacity: " << v.capacity() << endl;
			capacity = v.capacity();
		}
	}
}
```

```bash
orignal capacity: 0
new capacity: 1
new capacity: 2
new capacity: 3
new capacity: 4
new capacity: 6
new capacity: 9
new capacity: 13
new capacity: 19
new capacity: 28
new capacity: 42
new capacity: 63
new capacity: 94
new capacity: 141
new capacity: 211
new capacity: 316
new capacity: 474
new capacity: 711
new capacity: 1066
```

* `reserve()`

```c++
void reserve (size_type n);
```

`reserve()`使用空间置配器 ( allocator ) 来分配内存，也就是，没有存储元素的那部分内存是原生 ( raw ) 内存。要是`n`小于或等于`v.capacity()`，那么，`v`将忽略这个操作。
要是`n`大于`v.capacity()`，那么，v将会重新分配内存，并保证新的容量至少为n。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.reserve(500);
	cout << v.size() << endl;		// 0
	cout << v.capacity() << endl;   // 500
}
```

* `resize()`

```c++
void resize (size_type n);
void resize (size_type n, const value_type& val);
```

`resize()`的行为将取决于参数n，
    * 当`n`小于元素的个数，那么，容器的前`n`个元素将得到保留，其它的元素将被移除并销毁。
    * 当`n`大于元素的个数，那么，新的元素将被默认初始化，并添加到容器末尾。要是指定了`val`，那么，将使用`val`来初始化新的元素。
    * 要是`n`大于容器的容量，那么，在添加新元素之前，容器的内存将进行重新分配。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.resize(500);
	cout << v.size() << endl;		// 500
	cout << v.capacity() << endl;   // 500
}
```



#### 删除元素

* `pop_back()`: 删除尾部元素，内存没有被真正释放

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	// pop_back()
	vector<int> v{ 1, 2, 3 };
	cout << v.size() << endl;		// 3
	cout << v.capacity() << endl;   // 3
	v.pop_back();
	cout << v.size() << endl;		// 2
	cout << v.capacity() << endl;   // 3
}
```


* `erase()`: 从指定容器删除指定位置的元素或某段范围内的元素。返回值是一个迭代器，指向删除元素下一个元素；如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素。内存没有被真正释放。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const nt num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// iterator erase(const_iterator position);
	// iterator erase(const_iterator first, const_iterator last);
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	auto it = v.erase(v.begin() + 1);
	cout << * it << endl;				// 3
	cout << v << endl;					// 1 3 4 5 6 7 8
	cout << v.size() << endl;			// 7
	cout << v.capacity() << endl;       // 8

	it = v.erase(v.begin(), v.begin() + 3);
	cout << * it << endl;				// 5
	cout << v << endl;					// 5 6 7 8
	cout << v.size() << endl;			// 4
	cout << v.capacity() << endl;       // 8
}
```



* `clear()`: `size()`一定会变为0，但是`capacity()`不保证会变成0.

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
}
```

* `swap()`: `vector<T>().swap(x);   // clear x reallocating`. 这才是释放vector内存的方法。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	vector<int>().swap(v);
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```

* `shrink_to_fit()`: Requests the container to reduce its `capacity` to fit its `size`. 所以我们可以通过先调用`clear()`再调用`shrink_to_fit()`的方式来释放内存。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
	v.shrink_to_fit();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```



#### iterator失效情形

* `erase(it)`后并没由对`it`进行赋值。如下例：明显可以看到使用`erase`删除某一个结点之后，`vector`迭代器虽然还是指向当前位置，而且也引起了元素前挪，但是由于删除结点的迭代器就已经失效，指向删除点后面的元素的迭代器也全部失效，所以不能对当前迭代器进行任何操作；需要对迭代器重新赋值或者接收`erase`它的返回。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2)
			v.erase(it);
		cout << * it << " ";
	}
}
```

* `erase(it)`后`it`移动了多次，导致越界。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		cout << * it << " ";
	}
}
```

解决办法：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end();)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		else
			++it;
	}
}
```

* `push_back()`导致`capacity`变化，而`it`并未更新。当插入(push_back)一个元素后，`capacity`的返回值与没有插入元素之前相比有改变，进行了深拷贝，而迭代器所指向的位置已经被析构函数释放所以导致迭代器失效。而当你在不增容的情况下尾插数据并不会导致迭代器失效。`insert`使迭代器失效的与`push_back`类似。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

如果我们预留了足够的`capacity`，那么问题就能解决。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

* `end()`迭代器并未更新

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	vector<int>::iterator end = v.end();
	for (auto it = v.begin(); it != end; ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1); // push_back()导致v.end()发生了改变
		cout << *it << endl;
	}
}
```



* `push_back()`导致无限循环

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(0); // 0会导致一直添加0
		cout << * it << endl;
	}
}
```

#### 比较大小

类似Python，逐位比较。

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v1{ 1, 2 };
	vector<int> v2{ 1, 3 };
	vector<int> v3{ 1, 2, 3 };
	vector<int> v4{ 4, 1 };
	cout << (v1 < v2) << endl; // 1
	cout << (v1 < v3) << endl; // 1
	cout << (v2 < v3) << endl; // 0
	cout << (v2 < v4) << endl; // 1
}
```


#### vector vs. array

* creation:
    * vector: sequential container to store elements
    * array: original data structure, based on index concept
* Memory
    * vector: occupy more memory than array
    * array: memory-efficient
* Length
    * vector: length vary
    * array: fixed size length
* Usage
    * vector: frequent insertion and deletion
    * array: frequent element acces
* Resize
    * vector: resize vector is dynamic in nature
    * array: resizing arrays is expensiv
* Structure
    * vector: template class, c++ only construct.
    * array: contiguous memory location
* Indexing
    * vector: non-indexed based stuctrue
    * array: index based with the lowest address as first, and highest address as last
* Access
    * vector: access element is time-consuming although based on a position of element
    * array: access element is constant time operation irrespective of element location



### unordered_<> and ordered_<>

> 原文链接：https://blog.csdn.net/haluoluo211/article/details/82468061

* Implementation
    * `set`基于红黑树实现，红黑树具有自动排序的功能，因此`map`内部所有的数据，在任何时候，都是有序的。
    * `unordered_set`基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存。

* Ordering
    * `set`: increasing order (by default)
    * `unordered_set`: no ordering

* Search time
    * `set`: log(n)
    * `unordered_set`: average -> O(1); worst case -> O(n)

* Insertion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Deletion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Key的类型

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	// unordered_set<vector<int>> usv; // unordered_set不能使用vector<int>作为key，因为vector<int>没有hash函数，除非自己定义一个
	set<vector<int>> sv;  // set可以使用vector<int>作为key，因为vector 重载了 operator<
	sv.insert({ 1, 2 });
	sv.insert({ 1, 3 });
	sv.insert({ 1, 2, 3 });
	sv.insert({ 4, 1 });
	for (vector<int> v : sv)
		cout << v << endl;
}
```

上面程序输出

```bash
1 2
1 2 3
1 3
4 1
```






### Pointer

#### 基本用法

```bash
a)	int** p;

b)	int *p[10];        // 指向int类型的指针数组p[10]

c)	int (*p)[10];      // 指向有10个int类型的数组的指针p

d)	int (*p)(int);     // 函数指针，指向有一个参数并且返回类型 均为int的函数

e)	int (*p[10])(int); // 函数指针的数组, 指向有一个参数并且返回类型均为int的函数的数组
```

#### 指针 vs. 引用

* 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
```c++
int a = 1;
int *p = &a;
int a = 1;
int &b = a;
```
上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

* 可以有const指针，但是没有const引用；
* 指针可以有多级，但是引用只能是一级（`int **p`；合法 而`int &&a`是不合法的）
* 指针的值可以为空，但是引用的值不能为`NULL`，并且引用在定义的时候必须初始化；
* 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
* `sizeof(引用)`得到的是所指向的变量(对象)的大小，而`sizeof(指针)`得到的是指针本身的大小；
* 指针和引用的自增(++)运算意义不一样；

#### shared_ptr


#### unique_ptr

#### 普通指针如何实现一块内存只有一个指针指向这种功能







### 函数






### 类

#### Basics

类的基本思想是数据抽象和封装。需要首先定义一个抽象数据类型。

数据抽象是一种依赖于接口和实现的分离的编程技术。

类的接口包括用户所能执行的操作；

类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。


#### 构造函数

在类内部定义：
```c++
Sales_data(const std::string &s):bookNo(s) {}
```

在类外部定义 (如果要调用别的函数)
```cpp
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);
}
```


#### `public`, `protected`, `private`

* `private`: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
* `protected`: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
* `public`: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问

注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数.


#### class vs. struct

默认的继承访问权限：`struct`是`public`的，`class`是`private`的。


#### 静态成员

#### 继承

#### 多态继承

定义： 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）。
操作：在基类的函数前加上virtual关键字，在派生类中重写该函数，
运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；
如果对象类型是基类，就调用基类的函数。


#### 虚函数

虚函数（virtual）：基类希望其派生类进行覆盖的函数。
纯虚（pure virtual, =0）： ```double net_price(std::size_t) const = 0;```
含有纯虚函数的类是抽象基类，不能创建抽象基类的对象。
在很多情况下，基类本身生成对象是不合情理的。
例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。



#### 内联函数

C++ 内联函数是通常与类一起使用。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.


#### const

> https://www.cnblogs.com/MATU/p/5283454.html

```c++
class Test(){
public:
    Test(){}
    const int foo(int a);  //当const在函数名前面的时候修饰的是函数返回值。
    const int foo(int a) const; //当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。
};
```








### 多线程

#### 实现方式




### 内存泄漏 (Memory Leak)



### RTTI (Runtime Type Information)








### OpenCV

#### cv::Mat如何析构




### cmake










### Eigen

#### 行优先还是列有限




### 数据结构

#### 四叉树

#### cv::Mat
