---
layout:     post
title:      "C++"
date:       2019-8-25
author:     Tong
catalog: true
tags:
    - Language
---

### Basics

#### 面向对象

面向对象的三大特性：封装、继承、多态

#### OOP: 面向对象程序设计

数据抽象，继承和动态绑定。


#### 左值，右值

* 左值是变量的地址，右值是变量存储的内容。变量本质即存储空间的名称，编译后变为对应地址。

* 左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用，而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。
* 左值引用

```c++
int a = 3;
int & ref_a = a; //指针是一种数据类型，而引用不是。当其用作函数传参时，传递的就是变量的左值即地址。
```

* 右值引用
    * 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
    * 能够更简洁明确地定义泛型函数；
    * 右值引用形式：类型 && a= 被引用的对象。与左值的区别在于：右值是临时变量，如函数返回值，且不变。
    * 右值引用可以理解为右值的引用，右值初始化后临时变量消失。

#### sizeof()

* sizeof是运算符，不是函数，因此不把它所要求得长度的对象叫做参数，习惯上叫做操作数。

* 基础数据类型

```c++
#include <iostream>

using namespace std;

int main()
{
    cout << sizeof(bool) << endl;           // 1
	cout << sizeof(char) << endl;			// 1
	cout << sizeof(short) << endl;			// 2
	cout << sizeof(int) << endl;			// 4
	cout << sizeof(long) << endl;			// 4
	cout << sizeof(long long) << endl;		// 8
	cout << sizeof(float) << endl;          // 4
	cout << sizeof(double) << endl;			// 8
}
```

* 指针

```c++
#include <iostream>

using namespace std;

int main()
{
	cout << sizeof(char*) << endl;			// 8 (x64); 4 (x86)
	cout << sizeof(long long*) << endl;		// 8 (x64); 4 (x86)

	// cout << sizeof(void) << endl;		// ERROR!!!
	cout << sizeof(void*) << endl;			// 8 (x64); 4 (x86)}
}
```

* 数组

```c++
#include <iostream>

using namespace std;

int main()
{
	int a[] = { 1, 2, 3 };
	cout << sizeof(a) << endl;					// 12
	cout << sizeof(a) / sizeof(a[0]) << endl;	// 3

	int* b = a;
	cout << sizeof(b) << endl;					// 4 (x86); 8 (x64). 指针是恒定大小

	int (&c)[3] = a;							// 这是对数组的引用
	cout << sizeof(c) << endl;					// 12

	int d[5] = { 1, 2, 3 };
	cout << sizeof(d) << endl;					// 20
	cout << sizeof(d) / sizeof(d[0]) << endl;	// 5
}
```

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

int main()
{
	char a[] = "abcdef";
	cout << sizeof(a) << endl;	// 7

	char b[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	cout << sizeof(b) << endl; // 6

	string c("abcdef");
	cout << sizeof(c) << endl; // 28, 这里不代表字符串的长度，而是string类的大小, 在不同编译器上是恒定的

	char d[] = { 'a', '\0', 'c', 'd', 'e', 'f' };
	cout << sizeof(d) << endl; // 6
	cout << strlen(d) << endl; // 1
}
```

* 表达式: `sizeof()`求得表达式的计算结果的类型大小

```c++
#include <iostream>

using namespace std;

int main()
{
	char c = '1';
	int n = 1;
	cout << sizeof(c + n) << endl;		// 4
	cout << sizeof(c += n) << endl;		// 1
}
```

* 函数：求得返回类型的大小，但是不执行函数体！

```c++
#include <iostream>

using namespace std;

int add(int& a, int& b)
{
	return a += b;
}

int main()
{
	int a = 1;
	int b = 1;
	cout << sizeof(add(a, b)) << endl;		// 4
	cout << a << endl;						// 1
}
```


* `union`
    * union的大小取决于它所有的成员中，占用空间最大的一个成员的大小，因union中的所有成员起始地址都是一样的。
    * 复合数据类型，如`union`，`struct`，`class`的对齐方式为成员中对齐方式最大的成员的对齐方式。
    * 通过程序可以改变编译器对界，使用`#pragma pack(x)`宏可以改变编译器的对界方式，默认是8。
    * C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，`int`类型的大小是4，则`int`的对界为2和4中较小的2。

```c++
#include <iostream>

using namespace std;

union u1
{
	char a;
	int b;
};

union u2
{
	char a[13];
	int b;
};

union u3
{
	char a[13];
	char b;
};

int main()
{
	cout << sizeof(u1) << endl;	// 4, 以4对齐
	cout << sizeof(u2) << endl;	// 16, 以4对齐, 4 * 4 = 16， 这是离13最近的对界。
	cout << sizeof(u3) << endl;	// 13, 以1对齐
}
```

```c++
#pragma pack(2)

#include <iostream>

using namespace std;

union u1
{
	char a;
	int b;
};

union u2
{
	char a[13];
	int b;
};

union u3
{
	char a[13];
	char b;
};

int main()
{
	cout << sizeof(u1) << endl;	// 4, 以2对齐
	cout << sizeof(u2) << endl;	// 14, 以2对齐, 2 * 7 = 14， 这是离13最近的对界。
	cout << sizeof(u3) << endl;	// 13, 以1对齐
}
```


* `struct`: 这里计算sizeof既要考虑数据对齐(整体上最大元素的size对齐，满足之后还要满足struct中其他元素的对齐)，又要考虑最节约存储空间的原则。

```c++
#include <iostream>

using namespace std;

struct s0
{

};

struct s1
{
	char a;
	double b;
	int c;
	char d;
};

struct s2
{
	char a;
	char d;
	int c;
	double b;
};

int main()
{
	// 空类型必须在内存中占有一定空间，否则无法使用那些实例。至于占用多少内存，由编译器决定
	cout << sizeof(s0) << endl; // 1

	// 以8对齐
	// 先放a, 从0开始放，下一个空闲起始位为1
	// 但是由于b占8位，要放到8的对界上，所以从8开始放，下一个空闲起始位为16
	// c占4位，下一个空闲起始位为20
	// d占1位，总共放了21位，但大小要在8的倍数处结束，所以24
	cout << sizeof(s1) << endl;	// 24

	// 以8对齐
	// 先放a, 从0开始放，下一个空闲起始位为1
	// 但是由于d占1位，下一个空闲起始位为2
	// c占4位，下一个空闲起始位为6
	// d占8位，要放到8的对界上，所以从8开始放，总共大小为16
	cout << sizeof(s2) << endl;	// 16
}
```

* 嵌套`struct`

```c++
#include <iostream>

using namespace std;

struct s1
{
	char a[8];
};

struct s2
{
	double a;
};

struct s3
{
	s1 s;
	char a;
};

struct s4
{
	s2 s;
	char a;
};

int main()
{
	cout << sizeof(s1) << endl;	// 8
	cout << sizeof(s2) << endl; // 8

	cout << sizeof(s3) << endl; // 9, 因为它的对齐方式还是1
	cout << sizeof(s4) << endl; // 16，因为它的对齐方式是8
}
```

* `class`无虚函数：成员函数(除了虚函数)不会分配空间，所以`sizeof`时只计算数据成员的大小，计算方法类似`struct`。

```c++
#include <iostream>

using namespace std;

// 1
class c0
{

};

// 16
class c1
{
private:
	char a;
	double b;
public:
};

// 16
class c2
{
private:
	char a;
	double b;
public:
	int foo() { return 1; }
};

int main()
{
	cout << sizeof(c0) << endl; // 1
	cout << sizeof(c1) << endl;	// 16
	cout << sizeof(c2) << endl;	// 16
}
```

* `class`包含虚函数（不管几个）：单继承情况下，只要`class`中存在`virtual`函数（不管几个虚函数），编译器在编译时就会自动插入一个指向虚函数表的指针vptr(大小为4字节). 为了效率问题，编译器(gcc 和 微软)一般会把虚指针放在类的内存空间的最前面的位置，不管虚函数声明的位置。

```c++
#include <iostream>

using namespace std;

// 8
class c3
{
public:
	virtual void foo() { }
	char a;
};


// 8
class c4
{
public:
	virtual void foo() { }
	int a;
};

// 12
class c5
{
public:
	virtual void foo() { }
	char a;
	int b;
};

// 8
class c6
{
public:
	virtual void foo() { }
	char a;
	char b;
	char c;
	char d;
};


// 8
class c7
{
public:
	short a;
	virtual void foo() { }
	char b;
};

// 8
class c8
{
public:
	short a;
	char b;
	virtual void foo() { }
};

// 24, NO IDEA WHY THIS IS 24???
class c9
{
public:
	double a;
	char b;
	virtual void foo() { }
};

// 24
class c10
{
public:
	char b;
	double a;
	virtual void foo() { }
};

int main()
{
	cout << sizeof(c3) << endl;	// 8
	cout << sizeof(c4) << endl;	// 8
	cout << sizeof(c5) << endl;	// 12, 以4对齐
	cout << sizeof(c6) << endl;	// 8, 以4对齐
	cout << sizeof(c7) << endl;	// 8, 以4对齐
	cout << sizeof(c8) << endl;	// 8, 以4对齐
	cout << sizeof(c9) << endl;	// 24, 以8对齐
	cout << sizeof(c10) << endl;// 24, 以8对齐
}
```

* `class`包含`static`：因为`static`成员是分配在全局区为类的所有对象共享（VC编译器可能为了方便将其放入文字常量表), `sizeof`时不应该计入`static`成员。

```c++
#include <iostream>

using namespace std;

// 16
class c1
{
private:
	char a;
	double b;
public:
};

// 16
class c2
{
private:
	char a;
	double b;
	static int c;
public:
};

int main()
{
	cout << sizeof(c1) << endl; // 16
	cout << sizeof(c2) << endl;	// 16
}
```

* `class`单继承：类似嵌套`struct`，注意以谁对齐

```c++
#include <iostream>

using namespace std;

// 13
class c1
{
private:
	char a[13];
public:
};

// 14
class c2 : public c1
{
private:
	char b;
};

// 20
class c3 : public c1
{
private:
	int c;
};

int main()
{
	cout << sizeof(c1) << endl; // 13
	cout << sizeof(c2) << endl;	// 14
	cout << sizeof(c3) << endl;	// 20, a占据13位，c从地址16开始，所以一共20
}
```

* `class`多继承

```c++
#include <iostream>

using namespace std;

// 13
class c1
{
private:
	char a[13];
public:
};

// 1
class c2
{
private:
	char b;
};

// 20
class c3 : public c1, c2
{
private:
	int c;
};

int main()
{
	cout << sizeof(c1) << endl; // 13
	cout << sizeof(c2) << endl;	// 1
	cout << sizeof(c3) << endl;	// 20, VS把c1, c2当作整体来看待，总共14，然后从16开始，总共20
}
```



#### STL - Standard Template Library

* 容器（Container），是一种数据结构，如list，vector，和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；

* 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；

* 算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；

* 仿函数（Function object）

* 迭代适配器（Adaptor）

* 空间配制器（allocator）



#### decltype()

```c++
#include <iostream>
#include <typeinfo>

using namespace std;

int main()
{
	long long n1 = 1;
	decltype(n1) n2 = 123;
	cout << typeid(n2).name() << endl; // __ int64
}
```









### 基本数据类型

#### float vs. double

* A float is a single precision, 32-bit floating-point data type that accommodates seven digits. Its range is approximately 1.5 × 10^−45 to 3.4 × 10^38.

* A double is a double-precision, 64-bit floating-point data type. It accommodates 15 to 16 digits, with a range of approximately 5.0 × 10^−345 to 1.7 × 10^308.








### string

#### initialization

```c++
#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s1 = "Tong";
	string s2("Tong");
	string s3(s2.begin(), s2.end());
	string s4(5, 'a');				// Attention: char instead of string as the second parameter, "aaaaa"
	string s5(s1, 2, 1);			// "n" (string, start, length)
	string s6 = s1.substr(2, 1);	// "n", (string, start, length)
	string s7 = to_string(123);		// "123"
	cout << s1 << endl << s2 << endl << s3 << endl << s4 << endl << s5 << endl << s6 << endl << s7;
}
```


#### c_str()

```c++
// #include <string>
const char* c_str() const noexcept;
```

```c++
#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s1 = "12345";
	cout << s1.size() << endl;		// 5
	cout << sizeof(string) << endl; // 28, 固定长度，和编译器有关
	cout << sizeof(s1) << endl;		// 28

	const char* c1 = s1.c_str();
	cout << c1 << endl;			// 12345
	cout << sizeof(c1) << endl; // 4, 因为指针是固定长度
}
```

#### `atoi()`

```c++
// #include <cstdlib>
int atoi (const char * str);
```

【函数说明】`atoi()` 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 `isspace()` 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回。

【返回值】返回转换后的整型数；如果 `str` 不能转换成 `int` 或者 `str` 为空字符串，那么将返回 0。

`atoi()`的参数是 `const char*` ,因此对于一个字符串`str`我们必须调用 `c_str()`的方法把这个`string`转换成 `const char*`类型的。

`atoi()`不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；

```c++
#include <iostream>
#include <cstdlib>	// atoi()
#include <string>	// c_str()

using namespace std;

int main()
{
	char s1[] = "-123";
	cout << atoi(s1) << endl; // -123

	const char* s2 = "aa-123";
	cout << atoi(s2) << endl; // 0

	string s = "aaa-";
	const char* s3 = s.c_str();
	cout << atoi(s3) << endl; // 0
}
```



#### `stoi()`

```c++
// #include <string>
int stoi (const string&  str, size_t* idx = 0, int base = 10);
int stoi (const wstring& str, size_t* idx = 0, int base = 10);
```

stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！

```c++
#include <iostream>
#include <string>	// stoi()

using namespace std;

int main()
{
	string s0 = "1234";
	cout << stoi(s0) << endl;	// 1234

	char s1[] = "-123";
	cout << stoi(s1) << endl;	// -123

	const char* s2 = "-12312";
	cout << stoi(s2) << endl;	// -12312

	string s3 = "aa-123";
	//cout << stoi(s3) << endl; // ERROR

	string s4 = "aaa-";
	//cout << stoi(s4) << endl; // ERROR
}
```














### vector

#### 初始化

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// initialization
	vector<int> v1{ 1, 2, 3 };  // [1, 2, 3]
	cout << "v1" << endl << v1 << endl << endl;
	vector<int> v2(5, 0);		// [0, 0, 0, 0, 0]
	cout << "v2" << endl << v2 << endl << endl;
	vector<int> v3(v2.begin(), v2.end());
	cout << "v3" << endl << v3 << endl << endl;
	int arr4[] = { 10, 20, 30 };
	vector<int> v4(arr4, arr4 + sizeof(arr4) / sizeof(arr4[0]));
	cout << "v4" << endl << v4 << endl << endl;
	vector<int> v5;
	v5.push_back(1);
	v5.push_back(2);
	cout << "v5" << endl << v5 << endl << endl;
	vector<vector<int>> v6(3, vector<int>(4, -1));  // 3 x 4
}
```




#### 添加元素

 * `push_back()`

 ```c++
void push_back (const value_type& val);
void push_back (value_type&& val);
```

在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。
引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。




 * `emplace_back()`

```c++
template <class... Args>
  void emplace_back (Args&&... args);
```

在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。

```c++
// https://blog.csdn.net/xiaolewennofollow/article/details/52559364

#include <vector>  
#include <string>  
#include <iostream>  

struct President
{
	std::string name;
	std::string country;
	int year;

	President(std::string p_name, std::string p_country, int p_year)
		: name(std::move(p_name)), country(std::move(p_country)), year(p_year)
	{
		std::cout << "I am being constructed.\n";
	}
	President(const President& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being copy constructed.\n";
	}
	President(President&& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being moved.\n";
	}
	President& operator=(const President& other);
};

int main()
{
	std::vector<President> elections;
	std::cout << "emplace_back:\n";
	elections.emplace_back("Nelson Mandela", "South Africa", 1994); //没有类的创建  

	std::vector<President> reElections;
	std::cout << "\npush_back:\n";
	reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));

	std::cout << "\nContents:\n";
	for (President const& president : elections) {
		std::cout << president.name << " was elected president of "
			<< president.country << " in " << president.year << ".\n";
	}
	for (President const& president : reElections) {
		std::cout << president.name << " was re-elected president of "
			<< president.country << " in " << president.year << ".\n";
	}

}
```


```bash
emplace_back:
I am being constructed.

push_back:
I am being constructed.
I am being moved.

Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.
```


#### 动态扩展

由下面例子可以看到，`vector`在添加元素时，会多次重新分配内存。但是，当vector在删除元素的时候，容量并不会随着减小。vector的增容方式为： 0  1  2  3  4  6 ... 从第三项开始基本遵循`capacity = capacity + capacity / 2`这个规律。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	cout << "orignal capacity: " << v.capacity() << endl;
	auto capacity = v.capacity();
	for (int i = 0; i < 1000; ++i)
	{
		v.push_back(i);
		if (v.capacity() != capacity)
		{
			cout << "new capacity: " << v.capacity() << endl;
			capacity = v.capacity();
		}
	}
}
```

```bash
orignal capacity: 0
new capacity: 1
new capacity: 2
new capacity: 3
new capacity: 4
new capacity: 6
new capacity: 9
new capacity: 13
new capacity: 19
new capacity: 28
new capacity: 42
new capacity: 63
new capacity: 94
new capacity: 141
new capacity: 211
new capacity: 316
new capacity: 474
new capacity: 711
new capacity: 1066
```

* `reserve()`

```c++
void reserve (size_type n);
```

`reserve()`使用空间置配器 ( allocator ) 来分配内存，也就是，没有存储元素的那部分内存是原生 ( raw ) 内存。要是`n`小于或等于`v.capacity()`，那么，`v`将忽略这个操作。
要是`n`大于`v.capacity()`，那么，v将会重新分配内存，并保证新的容量至少为n。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.reserve(500);
	cout << v.size() << endl;		// 0
	cout << v.capacity() << endl;   // 500
}
```

* `resize()`

```c++
void resize (size_type n);
void resize (size_type n, const value_type& val);
```

`resize()`的行为将取决于参数n，
    * 当`n`小于元素的个数，那么，容器的前`n`个元素将得到保留，其它的元素将被移除并销毁。
    * 当`n`大于元素的个数，那么，新的元素将被默认初始化，并添加到容器末尾。要是指定了`val`，那么，将使用`val`来初始化新的元素。
    * 要是`n`大于容器的容量，那么，在添加新元素之前，容器的内存将进行重新分配。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.resize(500);
	cout << v.size() << endl;		// 500
	cout << v.capacity() << endl;   // 500
}
```



#### 删除元素

* `pop_back()`: 删除尾部元素，内存没有被真正释放

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	// pop_back()
	vector<int> v{ 1, 2, 3 };
	cout << v.size() << endl;		// 3
	cout << v.capacity() << endl;   // 3
	v.pop_back();
	cout << v.size() << endl;		// 2
	cout << v.capacity() << endl;   // 3
}
```


* `erase()`: 从指定容器删除指定位置的元素或某段范围内的元素。返回值是一个迭代器，指向删除元素下一个元素；如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素。内存没有被真正释放。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const nt num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// iterator erase(const_iterator position);
	// iterator erase(const_iterator first, const_iterator last);
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	auto it = v.erase(v.begin() + 1);
	cout << * it << endl;				// 3
	cout << v << endl;					// 1 3 4 5 6 7 8
	cout << v.size() << endl;			// 7
	cout << v.capacity() << endl;       // 8

	it = v.erase(v.begin(), v.begin() + 3);
	cout << * it << endl;				// 5
	cout << v << endl;					// 5 6 7 8
	cout << v.size() << endl;			// 4
	cout << v.capacity() << endl;       // 8
}
```



* `clear()`: `size()`一定会变为0，但是`capacity()`不保证会变成0.

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
}
```

* `swap()`: `vector<T>().swap(x);   // clear x reallocating`. 这才是释放vector内存的方法。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	vector<int>().swap(v);
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```

* `shrink_to_fit()`: Requests the container to reduce its `capacity` to fit its `size`. 所以我们可以通过先调用`clear()`再调用`shrink_to_fit()`的方式来释放内存。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
	v.shrink_to_fit();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```



#### iterator失效情形

* `erase(it)`后并没由对`it`进行赋值。如下例：明显可以看到使用`erase`删除某一个结点之后，`vector`迭代器虽然还是指向当前位置，而且也引起了元素前挪，但是由于删除结点的迭代器就已经失效，指向删除点后面的元素的迭代器也全部失效，所以不能对当前迭代器进行任何操作；需要对迭代器重新赋值或者接收`erase`它的返回。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2)
			v.erase(it);
		cout << * it << " ";
	}
}
```

* `erase(it)`后`it`移动了多次，导致越界。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		cout << * it << " ";
	}
}
```

解决办法：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end();)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		else
			++it;
	}
}
```

* `push_back()`导致`capacity`变化，而`it`并未更新。当插入(push_back)一个元素后，`capacity`的返回值与没有插入元素之前相比有改变，进行了深拷贝，而迭代器所指向的位置已经被析构函数释放所以导致迭代器失效。而当你在不增容的情况下尾插数据并不会导致迭代器失效。`insert`使迭代器失效的与`push_back`类似。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

如果我们预留了足够的`capacity`，那么问题就能解决。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

* `end()`迭代器并未更新

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	vector<int>::iterator end = v.end();
	for (auto it = v.begin(); it != end; ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1); // push_back()导致v.end()发生了改变
		cout << *it << endl;
	}
}
```



* `push_back()`导致无限循环

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(0); // 0会导致一直添加0
		cout << * it << endl;
	}
}
```

#### 比较大小

类似Python，逐位比较。

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v1{ 1, 2 };
	vector<int> v2{ 1, 3 };
	vector<int> v3{ 1, 2, 3 };
	vector<int> v4{ 4, 1 };
	cout << (v1 < v2) << endl; // 1
	cout << (v1 < v3) << endl; // 1
	cout << (v2 < v3) << endl; // 0
	cout << (v2 < v4) << endl; // 1
}
```


#### vector vs. array

* creation:
    * vector: sequential container to store elements
    * array: original data structure, based on index concept
* Memory
    * vector: occupy more memory than array
    * array: memory-efficient
* Length
    * vector: length vary
    * array: fixed size length
* Usage
    * vector: frequent insertion and deletion
    * array: frequent element acces
* Resize
    * vector: resize vector is dynamic in nature
    * array: resizing arrays is expensiv
* Structure
    * vector: template class, c++ only construct.
    * array: contiguous memory location
* Indexing
    * vector: non-indexed based stuctrue
    * array: index based with the lowest address as first, and highest address as last
* Access
    * vector: access element is time-consuming although based on a position of element
    * array: access element is constant time operation irrespective of element location



### unordered_<> and ordered_<>

> 原文链接：https://blog.csdn.net/haluoluo211/article/details/82468061

* Implementation
    * `set`基于红黑树实现，红黑树具有自动排序的功能，因此`map`内部所有的数据，在任何时候，都是有序的。
    * `unordered_set`基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存。

* Ordering
    * `set`: increasing order (by default)
    * `unordered_set`: no ordering

* Search time
    * `set`: log(n)
    * `unordered_set`: average -> O(1); worst case -> O(n)

* Insertion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Deletion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Key的类型

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	// unordered_set<vector<int>> usv; // unordered_set不能使用vector<int>作为key，因为vector<int>没有hash函数，除非自己定义一个
	set<vector<int>> sv;  // set可以使用vector<int>作为key，因为vector 重载了 operator<
	sv.insert({ 1, 2 });
	sv.insert({ 1, 3 });
	sv.insert({ 1, 2, 3 });
	sv.insert({ 4, 1 });
	for (vector<int> v : sv)
		cout << v << endl;
}
```

上面程序输出

```bash
1 2
1 2 3
1 3
4 1
```






### Pointer

#### 基本用法

```bash
a)	int** p;

b)	int *p[10];        // 指向int类型的指针数组p[10]

c)	int (*p)[10];      // 指向有10个int类型的数组的指针p

d)	int (*p)(int);     // 函数指针，指向有一个参数并且返回类型 均为int的函数

e)	int (*p[10])(int); // 函数指针的数组, 指向有一个参数并且返回类型均为int的函数的数组
```

#### 指针 vs. 引用

* 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
```c++
int a = 1;
int *p = &a;
int a = 1;
int &b = a;
```
上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

* 可以有const指针，但是没有const引用；
* 指针可以有多级，但是引用只能是一级（`int **p`；合法 而`int &&a`是不合法的）
* 指针的值可以为空，但是引用的值不能为`NULL`，并且引用在定义的时候必须初始化；
* 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。
* `sizeof(引用)`得到的是所指向的变量(对象)的大小，而`sizeof(指针)`得到的是指针本身的大小；
* 指针和引用的自增(++)运算意义不一样；

#### shared_ptr


#### unique_ptr

#### 普通指针如何实现一块内存只有一个指针指向这种功能







### 函数






### 类

#### Basics

类的基本思想是数据抽象和封装。需要首先定义一个抽象数据类型。

数据抽象是一种依赖于接口和实现的分离的编程技术。

类的接口包括用户所能执行的操作；

类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。


#### 构造函数

在类内部定义：
```c++
Sales_data(const std::string &s):bookNo(s) {}
```

在类外部定义 (如果要调用别的函数)
```cpp
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);
}
```


#### `public`, `protected`, `private`

* `private`: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
* `protected`: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
* `public`: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问

注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数.


#### class vs. struct

默认的继承访问权限：`struct`是`public`的，`class`是`private`的。


#### 静态成员

#### 继承

#### 多态继承

定义： 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）。
操作：在基类的函数前加上virtual关键字，在派生类中重写该函数，
运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；
如果对象类型是基类，就调用基类的函数。


#### 虚函数

虚函数（virtual）：基类希望其派生类进行覆盖的函数。
纯虚（pure virtual, =0）： ```double net_price(std::size_t) const = 0;```
含有纯虚函数的类是抽象基类，不能创建抽象基类的对象。
在很多情况下，基类本身生成对象是不合情理的。
例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。



#### 内联函数

C++ 内联函数是通常与类一起使用。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.


#### const

> https://www.cnblogs.com/MATU/p/5283454.html

```c++
class Test(){
public:
    Test(){}
    const int foo(int a);  //当const在函数名前面的时候修饰的是函数返回值。
    const int foo(int a) const; //当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。
};
```








### 多线程

#### 实现方式




### 内存泄漏 (Memory Leak)



### RTTI (Runtime Type Information)








### OpenCV

#### cv::Mat如何析构




### cmake


```cmake
cmake_minimum_required(VERSION 2.8)
project(myslam)

set(CMAKE_BUILD_TYPE Release)

set(CMAKE_CXX_FLAGS "-std=c++11 -Wall")
set(CMAKE_CXX_FLAGS_RELEASE  "-std=c++11 -O3 -fopenmp -pthread")

list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

############### dependencies ######################
# Eigen
include_directories("/usr/include/eigen3")

# OpenCV
find_package(OpenCV 3.1 REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})

# pangolin
find_package(Pangolin REQUIRED)
include_directories(${Pangolin_INCLUDE_DIRS})

# Sophus
find_package(sophus REQUIRED)
include_directories(${sophus_INCLUDE_DIRS})

# G2O
# find_package(G2O REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/g2o/)

# glog
#find_package(Glog REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/glog/)

# gtest
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

# gflags
# find_package(GFlags REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/gflags/)

# csparse
find_package(CSparse REQUIRED)
include_directories(${CSPARSE_INCLUDE_DIR})

set(THIRD_PARTY_LIBS
        ${OpenCV_LIBS}
        ${sophus_LIBRARIES}
        ${Pangolin_LIBRARIES} GL GLU GLEW glut
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_core.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_stuff.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_types_sba.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_solver_csparse.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_csparse_extension.so
        ${GTEST_BOTH_LIBRARIES}
        ${PROJECT_SOURCE_DIR}/thirdparty/glog/build/libglog.a
        ${PROJECT_SOURCE_DIR}/thirdparty/gflags/build/lib/libgflags.a
        pthread
        ${CSPARSE_LIBRARY}
        )

enable_testing()
############### source and test ######################
include_directories(${PROJECT_SOURCE_DIR}/include)
add_subdirectory(src)
add_subdirectory(test)
add_subdirectory(app)
```







### Eigen

#### 行优先还是列有限




### 数据结构

#### 四叉树

#### cv::Mat
