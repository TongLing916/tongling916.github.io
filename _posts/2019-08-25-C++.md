---
layout:     post
title:      "C++"
date:       2019-8-25
author:     Tong
catalog: true
tags:
    - Language
---

### Basics

#### 面向对象 vs. 面向过程（C语言）

#### 面向对象

面向对象的三大特性：封装、继承、多态



#### 静态类型 (statically typed)

C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查 (type checking)。



#### `endl`

`endl`的作用是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。


#### C语言关键字`volatile`有何作用？

作用是指示编译器，即使代码不对变量做任何改动，该变量的值仍可能会被外界修改。操作系统，硬件或其他线程都有可能修改该变量。该变量的值有可能遭受意料之外的修改，因此，每一次使用时，编译器都会重新从内存中获取这个值。

可以方式编译器执行一些我们不想要的优化。

`volatile`在多线程程序也很有用，对应全局变量，任意线程都可能修改这些共享的变量。我们可能不希望编译器对这些变量进行优化。



#### 预处理器 (preprocessor)

* 在C++编译过程中执行的一段程序

* 确保头文件多次包含仍能安全工作的常用技术

* 头文件保护符 (header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。




#### Shallow vs Deep Copy

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

struct Test
{
	char* ptr;
};

void shallow_copy(Test& src, Test& dest)
{
	dest.ptr = src.ptr;
}

void deep_copy(Test& src, Test& dest)
{
	dest.ptr = (char*)malloc(strlen(src.ptr) + 1);
	strcpy_s(dest.ptr, strlen(src.ptr) + 1, src.ptr);
}

int main()
{
	Test src;
	char tmp = 'a';
	src.ptr = &tmp;
	cout << *src.ptr << endl;		// a

	Test dest_shallow;
	shallow_copy(src, dest_shallow);
	cout << *dest_shallow.ptr << endl;	// a

	Test dest_deep;
	deep_copy(src, dest_deep);
	cout << *dest_deep.ptr << endl;	// a

	*dest_shallow.ptr = 'b';
	cout << *src.ptr << endl;		// b

	cout << *dest_shallow.ptr << endl; // b

	cout << *dest_deep.ptr << endl; // c

	*dest_deep.ptr = 'c';
	cout << *src.ptr << endl;  // b

	cout << *dest_shallow.ptr << endl; // b

	cout << *dest_deep.ptr << endl; // c

	return 0;
}
```



### STL - Standard Template Library

* 容器（Container），是一种数据结构，如list，vector，和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；

* 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；

* 算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；

* 仿函数（Function object）

* 迭代适配器（Adaptor）

* 空间配制器（allocator）













### 变量与基本类型

#### 混用unsigned和signed类型

* 如果表达式里既有带符号数又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。

* 当从无符号数减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是一个负值。

```c++
#include <iostream>

using namespace std;

int main()
{
	unsigned u = 10, u2 = 42;
	cout << u2 - u << endl;	// 32

	cout << u - u2 << endl;	// 4294967264

	int i = 10, i2 = 42;

	cout << i2 - i << endl;	// 32

	cout << i - i2 << endl;	// -32

	cout << i - u << endl;	// 0

	cout << u - i << endl;	// 0

	cout << i - u2 << endl;	// 4294967264

	cout << u2 - i << endl; // 32
}
```

#### 字面值常量

* 整形字面值
    * 20 // 十进制，默认情况下是带符号数，类型是`int`, `long`, `long long`中能容下当前值并且尺寸最小的那个
    * 024 // 以`0`开头，八进制。
    * 0x14 // 以`0x`或者`0X`开头， 十六进制。
    * 八进制和十六进制的类型是能容下其数值的`int`, `unsigned int`, `long`, `unsigned long`, `long long`和`unsigned long long`中的尺寸最小者。如果一个都放不下，将产生错误。
    * 注意：十进制字面值不会是负数，`-40`的字面值仍然是`40`。

* 浮点型字面值
    * 默认的浮点型字面值是一个`double`
    * 表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识: `3.14159`, `3.1415926E0`, `0.`, `0e0`, `.001`。

#### 列表初始化 (list initialization)

* 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

```c++
#include <iostream>

using namespace std;

int main()
{
	int a = 1;

	int b = { 2 };

	int c{ 3 };	// 列表初始化

	int d(4);

	cout << "a: " << a << "; b: " << b << "; c: " << c << "; d: " << d << endl; // a: 1; b: 2; c: 3; d: 4

	long double ld = 3.1415;
	int a1(ld), b1 = ld;	// 转换执行，且确实丢失了部分值

	cout << "a1: " << a1 << "; b1: " << b1 << endl;	// a1: 3; b1: 3

	int c1{ ld }, d1 = { ld }; // ERROR!!! 转换未执行，因为存在丢失信息的危险
}

```

#### 默认初始化

* 如果内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。

* 一种例外情况是，定义在函数体内部的内置类型变量将 __不被初始化__。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

* 类的对象如果没有显式地初始化，则其值由类决定。

```c++
#include <iostream>

using namespace std;

string global_str;	// ""
int global_int;		// 0

int main()
{
	cout << "global_str: " << global_str << "; global_int: " << global_int << endl;
	// global_str: ; global_int: 0

	int local_int;		// Undefined
	string local_str;	// Undefined
}
```

#### `declaration` vs. `definition`

* __声明__ 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 __定义__ 负责创建与名字关联的实体。

* 如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显示地初始化变量。

* 在函数体内部，如果试图初始化一个由`extern`关键子标记的变量，将引发错误。

* 变量能且只能被定义一次，但是可以被多次声明。

```c++
extern int i; // 声明

int j; // 声明且定义

extern double pi = 3.14; // 定义
```


#### 作用域

```c++
#include <iostream>

using namespace std;

int reused = 42;

int main()
{
	int unique = 0;
	cout << reused << " " << unique << endl;	// 42 0

	int reused = 0;
	cout << reused << " " << unique << endl;	// 0 0

	cout << ::reused << " " << unique << endl;	// 42 0, 因为显式地访问全局变量

}

```

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 100, sum = 0;
	for (int i = 0; i != 10; ++i)
		sum += i;
	cout << i << " " << sum << endl;	// 100 45

}

```

#### 引用

```c++
#include <iostream>

using namespace std;

int main()
{
	int ival = 1.01;
	int& rvall = 1.01;	// ERROR: 引用类型的初始值必须是一个对象

	int& rval2 = ival;

	int& rval3;			// ERROR: 引用必须被初始化

    double& dval4 = ival; // ERROR: 类型必须相同，但有两个例外。

}

```


```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 0, &r1 = i;
	double d = 0, &r2 = d;
	r2 = 3.14159;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i: 0; r1: 0; d: 3.14159; r2: 3.14159

	r2 = r1;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i : 0; r1 : 0; d : 0; r2: 0

	i = r2;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i: 0; r1: 0; d: 0; r2: 0

	r1 = d;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i : 0; r1 : 0; d : 0; r2: 0
}
```


#### `const`

* 要想在多个文件间共享`const`对象，必须在变量的定义之前添加`extern`关键字。

* 在初始化常量引用时允许用任意表达式作为初始值（不一定要类型相同），只要该表达式的结果能转换成引用的类型即可。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	const int& r1 = i;			// 允许将const int&绑定到一个普通的int对象上

	const int& r2 = 42;			// 正确: r2是一个常量引用

	const int& r3 = r1 * 2;		// 正确: r3是一个常量引用

	int& r4 = r1 * 2;			// ERROR: r4是一个普通的非常量引用

	const double& r5 = i;		// 正确: r5是一个常量引用

}

```

* 常量指针 (const pointer)

从右往左阅读。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	int *const iptr = &i;

	*iptr = 0;	// 正确
	iptr = 0;   // ERROR: iptr是const

}
```


* 指向常量的指针 (pointer to const)

从右往左阅读


```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	const int* iptr = &i;

	*iptr = 0;	// ERROR: *iptr是const

	iptr = 0;   // 正确

}
```


#### 顶层`const` vs. 底层`const`

* 顶层`const`表示任意的对象是常量，例如指针本身

* 底层`const`表示指针所指的对象是一个常量

* 指针类型既可能是顶层也可能是底层`const`，这一点和其他类型相比区别明显

* 在执行对象的拷贝操作时，顶层`const`不受什么影响，但是拷入和拷出的对象必须具有相同的底层`const`资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

```c++
int i = 0;
int *const p1 = &i; // top-level const

const int ci = 42; // top-level const

const int *p2 = &ci; // low-level const
```

#### 常量表达式

* 常量表达式 (const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式。

* 字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式。

* (C++ 11) 允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。

* 一般来说，如果认定一个变量是常量表达式，那就把它声明成`constexpr`类型。

```c++
#include <iostream>

using namespace std;

int size()
{
	return 10;
}

constexpr int size2()
{
	return 20;
}

int main()
{
	constexpr int mf = 20;				// 正确
	constexpr int limit = mf + 1;		// 正确
	constexpr int sz = size();			// 错误，除非size()是个constexpr函数
	constexpr int sz2 = size2();		// 正确
}

```

* 指针如果定义为`constexpr`，它仅对指针有效，对指针所指的对象无效。

```c++
const int* p = nullptr;     // p是一个指向整型常量的指针

constexpr int *q = nullptr; // q是一个指向整数的常量指针
```

* 一个`constexpr`指针的初始值必须是`nullptr`或者0，或者是存储与某个固定地址中的对象。

* 函数体内定义的变量一般来说并非存放在固定地址中，因此`constexpr`指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化`constexpr`指针。除此之外，允许函数定义一类有效范围超出函数本身的变量，这类变量一样也有固定地址，`constexpr`指针也能指向这样的变量。

```c++
#include <iostream>

using namespace std;

constexpr int* np = nullptr;
int j = 0;
constexpr int i = 42;
// i, j都必须定义在函数体之外

int main()
{
	constexpr const int* p = &i;
	constexpr int* p1 = &j;
}
```


#### `auto`

* `auto`能在一条语句声明多个变量，但是该语句种所有变量的初始基本数据类型必须一样。

```c++
#include <iostream>

using namespace std;

int main()
{
	auto i = 0, *p = &i;		// 正确
	auto sz = 0, pi = 3.14;		// ERROR! sz和pi类型不一致
}
```

* `auto`一般会忽略顶层`const`，同时底层`const`则会保留下来。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 0, &r = i;
	auto a = r; // a是一个整数

	const int ci = i, &cr = ci;

	auto b = ci;	// b是一个整数 (ci的顶层const特性被忽略掉了)

	auto c = cr;	// c是一个整数

	auto d = &i;	// d是一个整形指针

	auto e = &ci;	// e是一个指向整数常量的指针 (对常量对象取地址是一种底层const)

}

```

* `auto`被设置成引用，原来的规则仍然适用

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 1;
	const int ci = i;

	auto& h = 42; // ERROR! 不能为非常量引用绑定字面值

	const auto& j = 42;	// 正确：可以为常量引用绑定字面值

	auto k = ci, & l = i;	// 正确：k是整数，l是整形引用

	auto& m = ci, * p = &ci;	// 正确：m是对整形常量的引用，p是指向整型常量的指针

	auto& n = i, * p2 = &ci;	// ERROR! i的类型是int，而&ci的类型是const int
}
```

```c++
#include <iostream>

using namespace std;

int main()
{
	const int i = 42;

	auto j = i;	// 整数

	++j;
	cout << j << endl;

	const auto& k = i;	// 整型常量的引用

	auto* p = &i;	// 指向一个整型常量的指针

	p = nullptr;

	const auto j2 = i, & k2 = i;	// j2是一个整数常量，k2是一个对整数常量的引用
}
```


#### `decltype()`

* `decltype((variable))` (双层括号)的结果永远是引用，而`decltype(variable)`结果只有当`variable`本身就是一个引用时才是引用。

* 如果`i`是`int`，那么表达式`i=x`的类型是`int&`。

```c++
#include <iostream>

using namespace std;

int main()
{
	const int ci = 0, &cj = ci;
	decltype(ci) x = 0; // x的类型是const int

	decltype(cj) y = x; // y的类型是const int&, y绑定到变量x

	decltype(cj) z;	// ERROR! z是一个引用，必须初始化


	int i = 42, *p = &i, &r = i;
	decltype(r + 0) b;	// 正确：加法的结果是int，因此b是一个int

	decltype(*p) c;	// ERROR! c是int&, 必须初始化

	decltype((i)) d; // ERROR! d是int&, 必须初始化

	decltype(i) e; // 正确：e是一个未初始化的int
}

```

```c++
#include <iostream>

using namespace std;

int main()
{
	int a = 3, b = 5;
	decltype(a) c = a;
	decltype((b)) d = a;
	--c;
	++d;
	cout << a << " " << b << " " << c << " " << d << endl;
	// 4 5 2 4

}
```

```c++
#include <iostream>

using namespace std;

int main()
{
	int a = 3, b = 4;
	decltype(a) c = a;
	decltype(a = b) d = a;
	d = 5;
	cout << a << " " << b << " " << c << " " << d << endl;
	// 5 4 3 5

}

```



### 指针 (Pointer)

#### 基本用法

```bash
a)	int** p;

b)	int *p[10];        // 指向int类型的指针数组p[10]

c)	int (*p)[10];      // 指向有10个int类型的数组的指针p

d)	int (*p)(int);     // 函数指针，指向有一个参数并且返回类型 均为int的函数

e)	int (*p[10])(int); // 函数指针的数组, 指向有一个参数并且返回类型均为int的函数的数组
```

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	int& r = i;
	int* p = &i;
	int& r2 = *p;
	cout << "i: " << i << endl;			// i: 42
	cout << "r: " << r << endl;			// r: 42
	cout << "p: " << p << endl;			// p: 0000005DB88FFB84
	cout << "*p: " << *p << endl;		// *p: 42
	cout << "r2: " << r2 << endl;		// r2: 42

	r2 = 10;
	cout << "i: " << i << endl;			// i: 10
	cout << "r: " << r << endl;			// r: 10
	cout << "p: " << p << endl;			// p: 0000005DB88FFB84
	cout << "*p: " << *p << endl;		// *p: 10
	cout << "r2: " << r2 << endl;		// r2: 10
}
```

```c++
int* a, b; // a是指向int的指针，b是int
```

```c++
#include <iostream>

using namespace std;

int main()
{
	char a = 'a';
	typedef char* pstring;
	const pstring cstr1 = &a; // 指向char的常量指针

	*cstr1 = 'b';	// 正确

	const char* cstr2 = &a;	// 指向const char的指针

	*cstr2 = 'c';	// ERROR! const char不能赋值

	const pstring* ps = &cstr1;	// ps是一个指针，它的对象是指向char的常量指针

}
```

#### 空指针

```c++
#include <iostream>
#include <cstdlib>	// NULL

using namespace std;

int main()
{
	int* p1 = nullptr;    // C++ 11
	int* p2 = NULL; // preprocesor variable
	int* p1 = 0;

	int* p2;
	int a = 0;
	p2 = a;			// ERROR: 不能把int变量赋给指针
}
```

#### `void*`指针

* `void*`可用于存放任意对象的地址。但我们不知道该地址中到底是个什么类型的对象。

* 作用：拿它和别的指针比较；作为函数的输入或输出；或者赋给另外一个`void*`指针。

* 不能直接操作`void*`指针所指的对象，因为我们并不知道这个对象是什么类型。



#### 指向指针的引用

```c++
#include <iostream>
using namespace std;

int main()
{
	int i = 42;
	int* p;
	int*& r = p;

	r = &i;
	cout << i << " " << * p << " " << * r << endl;
	// 42 42 42

	* r = 0;
	cout << i << " " << * p << " " << * r << endl;
	// 0 0 0
}
```

#### 指针 vs. 引用

* 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
```c++
int a = 1;
int *p = &a;
int a = 1;
int &b = a;
```
上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

* 可以有const指针，但是没有const引用；

* 指针可以有多级，但是引用只能是一级（`int **p`；合法 而`int &&a`是不合法的）

* 指针的值可以为空，但是引用的值不能为`NULL`，并且引用在定义的时候必须初始化；

* 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

* `sizeof(引用)`得到的是所指向的变量(对象)的大小，而`sizeof(指针)`得到的是指针本身的大小；

* 指针和引用的自增(++)运算意义不一样；


### Smart Pointer

* `#include <memory>`

* Always use smart pointers when the pointer should __own heap memory__

* __Only use them with heap memoery__

* Smart pointers are __all about ownership__


#### unique_ptr

* __No runtime overhead__ over a raw pointer

* Unique pointer __has no copy constructor__

* cannot be copied, __can be moved__

* Gurantees that memory is always owned by a single unique pointer

#### shared_ptr

* can be copied

* stores a usage counter and a raw pointer

* frees memory when counter reaches 0

* can be initialized from a `unique_ptr`


#### weak_ptr


#### Typical beginner error

```c++
#include <iostream>

#include <memory>

int main()
{
	int a = 0;
	auto a_ptr = std::unique_ptr<int>(&a);
	return 0;
}
```

* Create a smart pointer from a pointer to a stack-managed variable
* The variable ends up being owned both by the smart pointer and the stack and gets deleted twice → __Error!__


#### 普通指针如何实现一块内存只有一个指针指向这种功能




















### string

#### initialization

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s1 = "Tong";            // 拷贝初始化（使用了等号）
	string s2("Tong");             // 直接初始化
	string s3(s2.begin(), s2.end());
	string s4(5, 'a');				// Attention: char instead of string as the second parameter, "aaaaa"

	string s5(s1, 2, 1);			// "n" (string, start, length)

	string s6 = s1.substr(2, 1);	// "n", (string, start, length)

	string s7 = to_string(123);		// "123"

	cout << s1 << endl << s2 << endl << s3 << endl << s4 << endl << s5 << endl << s6 << endl << s7;
}
```

#### 默认初始化

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s;      // size() = 0
	char c = s[0]; // '\0'
	cout << c << endl;
	return 0;
}
```

#### `getline()`

* `cin`自动忽略空白字符，`getline`会接收。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string line;
	while (getline(cin, line))
		cout << line << endl;
}
```


#### `size()`

* `string::size_type`是个无符号类型

* 如果一条表达式中已经有了`size()`函数就不要再使用`int`了，这样可以避免混用`int`和`unsigned`可能带来的问题。


#### 相加

* C++语言中的字符串字面值并不是标准库类型`string`的对象。

```c++
string a = "Hello " + "Tong"; // ERROR! 不能直接运算两个字符串字面值
```


#### `c_str()`

```c++
// #include <string>
const char* c_str() const noexcept;
```

```c++
#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s1 = "12345";
	cout << s1.size() << endl;		// 5

	cout << sizeof(string) << endl; // 28, 固定长度，和编译器有关

	cout << sizeof(s1) << endl;		// 28

	const char* c1 = s1.c_str();
	cout << c1 << endl;			// 12345

	cout << sizeof(c1) << endl; // 4, 因为指针是固定长度
}
```

#### `atoi()`

```c++
// #include <cstdlib>
int atoi (const char * str);
```

【函数说明】`atoi()` 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 `isspace()` 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回。

【返回值】返回转换后的整型数；如果 `str` 不能转换成 `int` 或者 `str` 为空字符串，那么将返回 0。

`atoi()`的参数是 `const char*` ,因此对于一个字符串`str`我们必须调用 `c_str()`的方法把这个`string`转换成 `const char*`类型的。

`atoi()`不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；

```c++
#include <iostream>
#include <cstdlib>	// atoi()
#include <string>	// c_str()

using namespace std;

int main()
{
	char s1[] = "-123";
	cout << atoi(s1) << endl; // -123

	const char* s2 = "aa-123";
	cout << atoi(s2) << endl; // 0

	string s = "aaa-";
	const char* s3 = s.c_str();
	cout << atoi(s3) << endl; // 0
}
```



#### `stoi()`

```c++
// #include <string>
int stoi (const string&  str, size_t* idx = 0, int base = 10);
int stoi (const wstring& str, size_t* idx = 0, int base = 10);
```

stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！

```c++
#include <iostream>
#include <string>	// stoi()

using namespace std;

int main()
{
	string s0 = "1234";
	cout << stoi(s0) << endl;	// 1234

	char s1[] = "-123";
	cout << stoi(s1) << endl;	// -123

	const char* s2 = "-12312";
	cout << stoi(s2) << endl;	// -12312

	string s3 = "aa-123";
	//cout << stoi(s3) << endl; // ERROR

	string s4 = "aaa-";
	//cout << stoi(s4) << endl; // ERROR

}
```














### vector

#### 初始化

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// initialization

	vector<int> v1{ 1, 2, 3 };  // [1, 2, 3]

	cout << "v1" << endl << v1 << endl << endl;

	vector<int> v2(5, 0);		// [0, 0, 0, 0, 0]

	cout << "v2" << endl << v2 << endl << endl;

	vector<int> v3(v2.begin(), v2.end());
	cout << "v3" << endl << v3 << endl << endl;
	int arr4[] = { 10, 20, 30 };
	vector<int> v4(arr4, arr4 + sizeof(arr4) / sizeof(arr4[0]));
	cout << "v4" << endl << v4 << endl << endl;
	vector<int> v5;
	v5.push_back(1);
	v5.push_back(2);
	cout << "v5" << endl << v5 << endl << endl;
	vector<vector<int>> v6(3, vector<int>(4, -1));  // 3 x 4

    vector<string> v7{10, "hi"}; // ATTENTION! 尽量避免这种方式。系统检测出10无法初始化为string，所以最后v7是包含10个"hi"的vector

}
```


#### 值初始化

* 如果`vector`对象的元素是内置类型，比如`int`，则元素初始值自动设为0。如果元素是某种类型，比如`string`，则元素由类默认初始化。

```c++
#include <iostream>

#include <string>

#include <vector>

using namespace std;

int main()
{
	vector<int> ivec(10);
	cout << ivec[0] << endl;	// 10个元素，每个都初始化为0

	vector<string> svec(10);
	cout << svec[0] << endl;	// 10个元素，每个都是空string对象
}

```

#### size_type

```bash
vector<int>::size_type  // 正确
vector::size_type       // 错误
```


#### 缓冲区溢出 (buffer overflow)

指通过下标访问不存在的元素的行为。

```c++
vector<int> ivec;
cout << ivec[0];

vector<int> ivec2(10);
cout << ivec2[10];
```


#### 添加元素

* 范围`for`语句体内不应改变其所遍历序列的大小

* `push_back()`

 ```c++
void push_back (const value_type& val);
void push_back (value_type&& val);
```

在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。
引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。




* `emplace_back()`

```c++
template <class... Args>
  void emplace_back (Args&&... args);
```

在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。

```c++
// https://blog.csdn.net/xiaolewennofollow/article/details/52559364

#include <vector>  
#include <string>  
#include <iostream>  

struct President
{
	std::string name;
	std::string country;
	int year;

	President(std::string p_name, std::string p_country, int p_year)
		: name(std::move(p_name)), country(std::move(p_country)), year(p_year)
	{
		std::cout << "I am being constructed.\n";
	}
	President(const President& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being copy constructed.\n";
	}
	President(President&& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being moved.\n";
	}
	President& operator=(const President& other);
};

int main()
{
	std::vector<President> elections;
	std::cout << "emplace_back:\n";
	elections.emplace_back("Nelson Mandela", "South Africa", 1994); //没有类的创建  

	std::vector<President> reElections;
	std::cout << "\npush_back:\n";
	reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));

	std::cout << "\nContents:\n";
	for (President const& president : elections) {
		std::cout << president.name << " was elected president of "
			<< president.country << " in " << president.year << ".\n";
	}
	for (President const& president : reElections) {
		std::cout << president.name << " was re-elected president of "
			<< president.country << " in " << president.year << ".\n";
	}

}
```


```bash
emplace_back:
I am being constructed.

push_back:
I am being constructed.
I am being moved.

Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.
```


#### 动态扩展

* 由下面例子可以看到，`vector`在添加元素时，会多次重新分配内存。但是，当vector在删除元素的时候，容量并不会随着减小。vector的增容方式为： 0  1  2  3  4  6 ... 从第三项开始基本遵循`capacity = capacity + capacity / 2`这个规律。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	cout << "orignal capacity: " << v.capacity() << endl;
	auto capacity = v.capacity();
	for (int i = 0; i < 1000; ++i)
	{
		v.push_back(i);
		if (v.capacity() != capacity)
		{
			cout << "new capacity: " << v.capacity() << endl;
			capacity = v.capacity();
		}
	}
}
```

```bash
orignal capacity: 0
new capacity: 1
new capacity: 2
new capacity: 3
new capacity: 4
new capacity: 6
new capacity: 9
new capacity: 13
new capacity: 19
new capacity: 28
new capacity: 42
new capacity: 63
new capacity: 94
new capacity: 141
new capacity: 211
new capacity: 316
new capacity: 474
new capacity: 711
new capacity: 1066
```

* `reserve()`

```c++
void reserve (size_type n);
```

`reserve()`使用空间置配器 ( allocator ) 来分配内存，也就是，没有存储元素的那部分内存是原生 ( raw ) 内存。要是`n`小于或等于`v.capacity()`，那么，`v`将忽略这个操作。
要是`n`大于`v.capacity()`，那么，v将会重新分配内存，并保证新的容量至少为n。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.reserve(500);
	cout << v.size() << endl;		// 0
	cout << v.capacity() << endl;   // 500
}
```

* `resize()`

```c++
void resize (size_type n);
void resize (size_type n, const value_type& val);
```

`resize()`的行为将取决于参数n，
    * 当`n`小于元素的个数，那么，容器的前`n`个元素将得到保留，其它的元素将被移除并销毁。
    * 当`n`大于元素的个数，那么，新的元素将被默认初始化，并添加到容器末尾。要是指定了`val`，那么，将使用`val`来初始化新的元素。
    * 要是`n`大于容器的容量，那么，在添加新元素之前，容器的内存将进行重新分配。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.resize(500);
	cout << v.size() << endl;		// 500
	cout << v.capacity() << endl;   // 500
}
```



#### 删除元素

* `pop_back()`: 删除尾部元素，内存没有被真正释放

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	// pop_back()
	vector<int> v{ 1, 2, 3 };
	cout << v.size() << endl;		// 3
	cout << v.capacity() << endl;   // 3
	v.pop_back();
	cout << v.size() << endl;		// 2
	cout << v.capacity() << endl;   // 3
}
```


* `erase()`: 从指定容器删除指定位置的元素或某段范围内的元素。返回值是一个迭代器，指向删除元素下一个元素；如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素。内存没有被真正释放。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// iterator erase(const_iterator position);
	// iterator erase(const_iterator first, const_iterator last);
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	auto it = v.erase(v.begin() + 1);
	cout << * it << endl;				// 3
	cout << v << endl;					// 1 3 4 5 6 7 8
	cout << v.size() << endl;			// 7
	cout << v.capacity() << endl;       // 8

	it = v.erase(v.begin(), v.begin() + 3);
	cout << * it << endl;				// 5
	cout << v << endl;					// 5 6 7 8
	cout << v.size() << endl;			// 4
	cout << v.capacity() << endl;       // 8
}
```



* `clear()`: `size()`一定会变为0，但是`capacity()`不保证会变成0.

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
}
```

* `swap()`: `vector<T>().swap(x);   // clear x reallocating`. 这才是释放vector内存的方法。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	vector<int>().swap(v);
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```

* `shrink_to_fit()`: Requests the container to reduce its `capacity` to fit its `size`. 所以我们可以通过先调用`clear()`再调用`shrink_to_fit()`的方式来释放内存。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
	v.shrink_to_fit();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```


#### 比较大小

类似Python，逐位比较。

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v1{ 1, 2 };
	vector<int> v2{ 1, 3 };
	vector<int> v3{ 1, 2, 3 };
	vector<int> v4{ 4, 1 };
	cout << (v1 < v2) << endl; // 1
	cout << (v1 < v3) << endl; // 1
	cout << (v2 < v3) << endl; // 0
	cout << (v2 < v4) << endl; // 1
}
```



### 迭代器 (iterator)

#### 迭代器类型

```c++
vector<int>::iterator it;           // 可读写
string::iterator it2;               // 可读写

vector<int>::const_iterator it3;    // 只读，不能写
string::const_iterator it4;         // 只读，不能写
```

* `being()`和`end()`返回的具体类型由对象是否是常量决定。

* `cbegin()` `cend()`返回的一定是`const_iterator`


#### 迭代器运算

* 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，就能将其相减，所得结果是两个迭代器的距离。其类型是名为`difference_type`的带符号整型数，可正可负。


#### iterator失效情形

* `erase(it)`后并没由对`it`进行赋值。如下例：明显可以看到使用`erase`删除某一个结点之后，`vector`迭代器虽然还是指向当前位置，而且也引起了元素前挪，但是由于删除结点的迭代器就已经失效，指向删除点后面的元素的迭代器也全部失效，所以不能对当前迭代器进行任何操作；需要对迭代器重新赋值或者接收`erase`它的返回。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2)
			v.erase(it);
		cout << * it << " ";
	}
}
```

* `erase(it)`后`it`移动了多次，导致越界。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		cout << * it << " ";
	}
}
```

解决办法：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end();)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		else
			++it;
	}
}
```

* `push_back()`导致`capacity`变化，而`it`并未更新。当插入(push_back)一个元素后，`capacity`的返回值与没有插入元素之前相比有改变，进行了深拷贝，而迭代器所指向的位置已经被析构函数释放所以导致迭代器失效。而当你在不增容的情况下尾插数据并不会导致迭代器失效。`insert`使迭代器失效的与`push_back`类似。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

如果我们预留了足够的`capacity`，那么问题就能解决。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

* `end()`迭代器并未更新

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	vector<int>::iterator end = v.end();
	for (auto it = v.begin(); it != end; ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1); // push_back()导致v.end()发生了改变
		cout << *it << endl;
	}
}
```



* `push_back()`导致无限循环

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(0); // 0会导致一直添加0
		cout << * it << endl;
	}
}
```



### 数组 (array)

#### vector vs. array

* creation:
    * vector: sequential container to store elements
    * array: original data structure, based on index concept
* Memory
    * vector: occupy more memory than array
    * array: memory-efficient
* Length
    * vector: length vary
    * array: fixed size length
* Usage
    * vector: frequent insertion and deletion
    * array: frequent element acces
* Resize
    * vector: resize vector is dynamic in nature
    * array: resizing arrays is expensiv
* Structure
    * vector: template class, c++ only construct.
    * array: contiguous memory location
* Indexing
    * vector: non-indexed based stuctrue
    * array: index based with the lowest address as first, and highest address as last
* Access
    * vector: access element is time-consuming although based on a position of element
    * array: access element is constant time operation irrespective of element location

#### 初始化

* 如果在函数内部体内定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

```c++
#include <iostream>

#include <string>

#include <vector>

using namespace std;

int a1[10];

int main()
{
	cout << a1[0] << endl;	// 0

	int a2[10];
	cout << a2[0] << endl;	// -858993460

	vector<int> v(10);
	cout << v[0] << endl;		// 0
}
```

* 如果对数组显式初始化，并且维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int a1[5] = { 0, 1, 2 }; // 等价于 a1[] = {0, 1, 2, 0, 0}

	string a2[3] = { "hi", "bye" }; // 等价于 a2[] = {"hi", "bye", ""}

	int a3[2] = { 0, 1, 2, 3 }; // ERROR! 初始值太多
}
```

* 不允许用数组拷贝或者赋值

```bash
int a[] = {0, 1, 2};

int a2[] = a; // ERROR!

a2 = a; // ERROR!
```


* size必须是`const`(变量)或者`constexpr`(函数返回值)

```c++
#include <iostream>

#include <string>

using namespace std;

int txt_size()
{
	return 10;
}

int main()
{
	unsigned buf_size = 1024;

	int ia1[buf_size]; // ERROR! buf_size不是constant

	int ia2[4 * 7 - 14]; // 正确

	int ia3[txt_size()]; // 返回值必须是constexpr

	char st[11] = "fundamental"; // 容量小1, 应该为st[12]
}
```


#### 复杂的声明

* 从右向左

* 从内向外

```bash
int *ptrs[10]; // ptrs是含有10个整型指针的数组

int &refs[10]; // ERROR! 不存在引用的数组

int (*Parray)[10] = &arr; // Parray指向一个含有10个整数的数组

int (&arrRef)[10] = arr; // arrRef引用一个含有是个整数的数组

int *(&arry)[10] = ptrs; // arry是数组的引用，该数组含有10个指针

```


#### size类型

* 在使用数组下标的时候，通常将其定义为`size_t`类型。`size_t`是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在`<cstddef>`中定义了它。


#### 指针与数组

* 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

* 当使用数组作为一个`auto`变量的初始值时，推断得到的类型时指针而非数组。

* `decltype(array)`返回的类型还是数组，长度为array的长度。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string nums[] = { "one", "two", "three" };

	string* p = &nums[0]; // p指向nums的第一个元素

	string* p2 = nums; // 等价于 p2 = &nums[0]

	auto p3(nums); // p3是一个string指针，指向nums的第一个元素

	// p3 = 2; // ERROR!

	auto p4(&nums[0]); // 等价于p3

	decltype(nums) nums2 = { "hello" };	// nums2 = {"hello", "", ""}

}
```

#### begin(), end()

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string nums[] = { "one", "two", "three" };

	string* pbeg = begin(nums);

	string* pend = end(nums);
}

```


#### 指针相减

* 两个指针相减的结果的类型是`ptrdiff_t`，也是定义在`<cstddef>`中。



#### 下标（与vector不同）

* 数组用的下标是有符号的，`vector`用的是无符号的。

* 虽然可以处理负值，但是结果地址必须指向原来指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string nums[] = { "one", "two", "three" };

	string* p = &nums[2];

	string k = p[-2]; // 得到nums[0]

}
```


#### 多维数组

* 注意多层`for`循环的使用

* 要使用`for`处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

* 当使用多维数组的名字时，其会被自动转换成指向数组首元素的指针。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int ia[5][5];

	for (size_t i = 0; i != 5; ++i)
		for (size_t j = 0; j != 5; ++j)
			ia[i][j] = i * 5 + j;


	size_t cnt = 0;
	for (auto& row : ia)
		for (auto& col : row)
		{
			col = cnt;
			++cnt;
		}


	// 声明成了引用类型，为了避免数组被自动转成指针

	for (const auto& row : ia)		
		for (auto col : row)
			cout << col << endl;


	// ERROR! row 的类型是int*, 无法遍历
	for (auto row : ia)
		for (auto col : row)
			cout << col << endl;
}
```

```c++

#include <iostream>

#include <string>

using namespace std;

int main()
{
	int ia[3][4];

	int(*p)[4] = ia; //	p是指向含有4个整数的数组

	p = &ia[2];		 // p指向ia的尾元素

}

```















### 表达式

#### 左值，右值

* 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

* 左值是变量的地址，右值是变量存储的内容。变量本质即存储空间的名称，编译后变为对应地址。

* 左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用，而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。

* 左值引用

```c++
int a = 3;
int & ref_a = a; //指针是一种数据类型，而引用不是。当其用作函数传参时，传递的就是变量的左值即地址。
```

* 右值引用
    * 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
    * 能够更简洁明确地定义泛型函数；
    * 右值引用形式：类型 && a= 被引用的对象。与左值的区别在于：右值是临时变量，如函数返回值，且不变。
    * 右值引用可以理解为右值的引用，右值初始化后临时变量消失。


#### 求值顺序

```c++
#include <iostream>

#include <vector>

using namespace std;

int f1()
{
	return 1;
}

int f2()
{
	return 2;
}

int main()
{
	int i = f1() * f2(); // 我们无法知道f1()先运行还是f2()先运行

	int n = 0;
	cout << n << " " << ++n << endl; // UNDEFINED, 但可以输出，例如 1 1
}
```

```c++
f() + g() * h() + j(); // 函数的调用顺序没有明确规定
```

#### 算数运算

* 小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转变成同一类型。

* (C++ 11) 商一律向0取整。`(-m)/n`和`m/(-n)`等价于`-(m/n)`。`m %(-n)`等于`m%n`。`(-m)%n`等于`-(m%n)`。

```c++
bool b = true;
bool b2 = -b; // b2仍然是true!!!
```


#### 逻辑与关系运算符

* `&&`和`||`采取短路求值策略 (short-circuit evaluation)。
    * 对于`&&`，当且仅当左侧运算对象为真时才对右侧运算对象求值。
    * 对于`||`，当且仅当左侧运算对象为假时才对右侧运算对象求值。

* `==`和`!=`会先计算左右两侧的值，然后再进行比较。哪边的值先算是未定义的。


```c++
#include <iostream>

#include <vector>

using namespace std;

int f1()
{
	return 1;
}

int f2()
{
	return 2;
}

int main()
{
	const char* cp = "Hello world";
	if (cp && *cp)
	{ // 这里会输出

		cout << cp << endl; // Hello world

		cout << * cp << endl; // H
	}
	else
		cout << "NOT OK" << endl;


	int i = 0, j = 20, k = 21;
	cout << (i != j < k) << endl; // 等价于 i != (j < k)

}
```


#### 赋值运算符

* 赋值运算符的优先级低于关系运算符的优先级。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i;
	cout << (i = 2 < 3) << endl;	// 1, 等价于 i = (2 < 3)

	cout << i << endl;				// 1

	cout << ((i = 2) < 3) << endl;	// 1

    cout << i << endl;				// 2

}

```

```c++
#include <iostream>

using namespace std;

int getPtr()
{
	return 20;
}

int main()
{
	int p = 10;
	p = getPtr() != 20; // 等价于 p = (getPtr() != 20)

	cout << "p: " << p << endl;	// p: 0
}

```


#### 递增运算符

* 前置版本的递增运算符`++i`避免了不必要的工作，它把值加1后直接返回改变了的运算对象。

* 后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。

* 后置递增运算符的优先级高于解引用运算符。

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3 };
	auto pbeg = v.begin();
	while (pbeg != v.end() && *pbeg >= 0)
		cout << *pbeg++ << endl;
        // 相当于*(pbeg++)，pbeg的值加1，然后返回初始值（加1之前），最后解引用
    	// 1 2 3

}
```

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3 };
	auto pbeg = v.begin();
	while (pbeg != v.end() && *pbeg >= 0)
		cout << *++pbeg << endl;
		// 2, 3, 最后ERROR!!!

}
```

```c++
vec[ival++] <= vec[ival]; // undefined, 我们不知道哪边会先算
```



#### 成员访问运算符

* 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s1 = "a string";
	string* p = &s1;
	auto n = s1.size();	// 运行string对象s1的size成员

	n = (*p).size(); // 正确

    n = p->size();	// 正确

    n = *p.size(); // ERROR!!!
}

```


#### 移位运算符

* 移位运算符比算数运算符低，但比关系运算符，赋值运算符和条件运算符的优先级高。

```bash
cout << 42 + 10; // right
cout << (10 < 42)； // right
cout  << 10 < 42; // ERROR!!!
```


#### sizeof()

* sizeof是运算符，不是函数，因此不把它所要求得长度的对象叫做参数，习惯上叫做操作数。

* 基础数据类型

```c++
#include <iostream>

using namespace std;

int main()
{
    cout << sizeof(bool) << endl;           // 1
	cout << sizeof(char) << endl;			// 1
	cout << sizeof(short) << endl;			// 2
	cout << sizeof(int) << endl;			// 4
	cout << sizeof(long) << endl;			// 4
	cout << sizeof(long long) << endl;		// 8
	cout << sizeof(float) << endl;          // 4
	cout << sizeof(double) << endl;			// 8
}
```

* 指针

```c++
#include <iostream>

using namespace std;

int main()
{
	cout << sizeof(char*) << endl;			// 8 (x64); 4 (x86)
	cout << sizeof(long long*) << endl;		// 8 (x64); 4 (x86)

	// cout << sizeof(void) << endl;		// ERROR!!!
	cout << sizeof(void*) << endl;			// 8 (x64); 4 (x86)}
}
```

* 数组

```c++
#include <iostream>

using namespace std;

int main()
{
	int a[] = { 1, 2, 3 };
	cout << sizeof(a) << endl;					// 12
	cout << sizeof(a) / sizeof(a[0]) << endl;	// 3

	int* b = a;
	cout << sizeof(b) << endl;					// 4 (x86); 8 (x64). 指针是恒定大小

	int (&c)[3] = a;							// 这是对数组的引用
	cout << sizeof(c) << endl;					// 12

	int d[5] = { 1, 2, 3 };
	cout << sizeof(d) << endl;					// 20
	cout << sizeof(d) / sizeof(d[0]) << endl;	// 5
}
```

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

int main()
{
	char a[] = "abcdef";
	cout << sizeof(a) << endl;	// 7

	char b[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	cout << sizeof(b) << endl; // 6

	string c("abcdef");
	cout << sizeof(c) << endl; // 28, 这里不代表字符串的长度，而是string类的大小, 在不同编译器上是恒定的

	char d[] = { 'a', '\0', 'c', 'd', 'e', 'f' };
	cout << sizeof(d) << endl; // 6
	cout << strlen(d) << endl; // 1
}
```

* 表达式: `sizeof()`求得表达式的计算结果的类型大小

```c++
#include <iostream>

using namespace std;

int main()
{
	char c = '1';
	int n = 1;
	cout << sizeof(c + n) << endl;		// 4
	cout << sizeof(c += n) << endl;		// 1
}
```

* 函数：求得返回类型的大小，但是不执行函数体！

```c++
#include <iostream>

using namespace std;

int add(int& a, int& b)
{
	return a += b;
}

int main()
{
	int a = 1;
	int b = 1;
	cout << sizeof(add(a, b)) << endl;		// 4
	cout << a << endl;						// 1
}
```


* `union`
    * union的大小取决于它所有的成员中，占用空间最大的一个成员的大小，因union中的所有成员起始地址都是一样的。
    * 复合数据类型，如`union`，`struct`，`class`的对齐方式为成员中对齐方式最大的成员的对齐方式。
    * 通过程序可以改变编译器对界，使用`#pragma pack(x)`宏可以改变编译器的对界方式，默认是8。
    * C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，`int`类型的大小是4，则`int`的对界为2和4中较小的2。

```c++
#include <iostream>

using namespace std;

union u1
{
	char a;
	int b;
};

union u2
{
	char a[13];
	int b;
};

union u3
{
	char a[13];
	char b;
};

int main()
{
	cout << sizeof(u1) << endl;	// 4, 以4对齐
	cout << sizeof(u2) << endl;	// 16, 以4对齐, 4 * 4 = 16， 这是离13最近的对界。
	cout << sizeof(u3) << endl;	// 13, 以1对齐
}
```

```c++
#pragma pack(2)

#include <iostream>

using namespace std;

union u1
{
	char a;
	int b;
};

union u2
{
	char a[13];
	int b;
};

union u3
{
	char a[13];
	char b;
};

int main()
{
	cout << sizeof(u1) << endl;	// 4, 以2对齐
	cout << sizeof(u2) << endl;	// 14, 以2对齐, 2 * 7 = 14， 这是离13最近的对界。
	cout << sizeof(u3) << endl;	// 13, 以1对齐
}
```


* `struct`: 这里计算sizeof既要考虑数据对齐(整体上最大元素的size对齐，满足之后还要满足struct中其他元素的对齐)，又要考虑最节约存储空间的原则。

```c++
#include <iostream>

using namespace std;

struct s0
{

};

struct s1
{
	char a;
	double b;
	int c;
	char d;
};

struct s2
{
	char a;
	char d;
	int c;
	double b;
};

int main()
{
	// 空类型必须在内存中占有一定空间，否则无法使用那些实例。至于占用多少内存，由编译器决定
	cout << sizeof(s0) << endl; // 1

	// 以8对齐
	// 先放a, 从0开始放，下一个空闲起始位为1
	// 但是由于b占8位，要放到8的对界上，所以从8开始放，下一个空闲起始位为16
	// c占4位，下一个空闲起始位为20
	// d占1位，总共放了21位，但大小要在8的倍数处结束，所以24
	cout << sizeof(s1) << endl;	// 24

	// 以8对齐
	// 先放a, 从0开始放，下一个空闲起始位为1
	// 但是由于d占1位，下一个空闲起始位为2
	// c占4位，下一个空闲起始位为6
	// d占8位，要放到8的对界上，所以从8开始放，总共大小为16
	cout << sizeof(s2) << endl;	// 16
}
```

* 嵌套`struct`

```c++
#include <iostream>

using namespace std;

struct s1
{
	char a[8];
};

struct s2
{
	double a;
};

struct s3
{
	s1 s;
	char a;
};

struct s4
{
	s2 s;
	char a;
};

int main()
{
	cout << sizeof(s1) << endl;	// 8
	cout << sizeof(s2) << endl; // 8

	cout << sizeof(s3) << endl; // 9, 因为它的对齐方式还是1
	cout << sizeof(s4) << endl; // 16，因为它的对齐方式是8
}
```

* `class`无虚函数：成员函数(除了虚函数)不会分配空间，所以`sizeof`时只计算数据成员的大小，计算方法类似`struct`。

```c++
#include <iostream>

using namespace std;

// 1
class c0
{

};

// 16
class c1
{
private:
	char a;
	double b;
public:
};

// 16
class c2
{
private:
	char a;
	double b;
public:
	int foo() { return 1; }
};

int main()
{
	cout << sizeof(c0) << endl; // 1
	cout << sizeof(c1) << endl;	// 16
	cout << sizeof(c2) << endl;	// 16
}
```

* `class`包含虚函数（不管几个）：单继承情况下，只要`class`中存在`virtual`函数（不管几个虚函数），编译器在编译时就会自动插入一个指向虚函数表的指针vptr(大小为4字节). 为了效率问题，编译器(gcc 和 微软)一般会把虚指针放在类的内存空间的最前面的位置，不管虚函数声明的位置。

```c++
#include <iostream>

using namespace std;

// 8
class c3
{
public:
	virtual void foo() { }
	char a;
};


// 8
class c4
{
public:
	virtual void foo() { }
	int a;
};

// 12
class c5
{
public:
	virtual void foo() { }
	char a;
	int b;
};

// 8
class c6
{
public:
	virtual void foo() { }
	char a;
	char b;
	char c;
	char d;
};


// 8
class c7
{
public:
	short a;
	virtual void foo() { }
	char b;
};

// 8
class c8
{
public:
	short a;
	char b;
	virtual void foo() { }
};

// 24, NO IDEA WHY THIS IS 24???
class c9
{
public:
	double a;
	char b;
	virtual void foo() { }
};

// 24
class c10
{
public:
	char b;
	double a;
	virtual void foo() { }
};

int main()
{
	cout << sizeof(c3) << endl;	// 8
	cout << sizeof(c4) << endl;	// 8
	cout << sizeof(c5) << endl;	// 12, 以4对齐
	cout << sizeof(c6) << endl;	// 8, 以4对齐
	cout << sizeof(c7) << endl;	// 8, 以4对齐
	cout << sizeof(c8) << endl;	// 8, 以4对齐
	cout << sizeof(c9) << endl;	// 24, 以8对齐
	cout << sizeof(c10) << endl;// 24, 以8对齐
}
```

* `class`包含`static`：因为`static`成员是分配在全局区为类的所有对象共享（VC编译器可能为了方便将其放入文字常量表), `sizeof`时不应该计入`static`成员。

```c++
#include <iostream>

using namespace std;

// 16
class c1
{
private:
	char a;
	double b;
public:
};

// 16
class c2
{
private:
	char a;
	double b;
	static int c;
public:
};

int main()
{
	cout << sizeof(c1) << endl; // 16
	cout << sizeof(c2) << endl;	// 16
}
```

* `class`单继承：类似嵌套`struct`，注意以谁对齐

```c++
#include <iostream>

using namespace std;

// 13
class c1
{
private:
	char a[13];
public:
};

// 14
class c2 : public c1
{
private:
	char b;
};

// 20
class c3 : public c1
{
private:
	int c;
};

int main()
{
	cout << sizeof(c1) << endl; // 13
	cout << sizeof(c2) << endl;	// 14
	cout << sizeof(c3) << endl;	// 20, a占据13位，c从地址16开始，所以一共20
}
```

* `class`多继承

```c++
#include <iostream>

using namespace std;

// 13
class c1
{
private:
	char a[13];
public:
};

// 1
class c2
{
private:
	char b;
};

// 20
class c3 : public c1, c2
{
private:
	int c;
};

int main()
{
	cout << sizeof(c1) << endl; // 13
	cout << sizeof(c2) << endl;	// 1
	cout << sizeof(c3) << endl;	// 20, VS把c1, c2当作整体来看待，总共14，然后从16开始，总共20
}
```


#### 类型转换

* 何时发生隐式类型转换？
    * 整型提升 (integral promotion): 在大多数表达式中，比`int`类型小的整型值首先提升为较大的整数类型。
    * 在条件中，非布尔值转换成布尔值。
    * 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
    * 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
    * 函数调用时也会发生类型转换。

* 整型提升
    * `bool`, `char`, `signed char`, `unsigned char`, `short`, `unsgined short` --> `int`
    * `wchar_t`, `char16_t`, `char32_t` --> `int`, `unsigned int`, `long`, `unsigned long`, `long long`, `unsigned long long`中的最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。


* 如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。

* 首先，执行整型提升，如果结果的类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象类型要么都是带符号的，要么都是无符号的，则小类型的运算对象转换成较大的类型。

* 如果一个运算对象是无符号类型，另一个是有符号类型。
    * 如果无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。
    * 如果带符号类型大于无符号类型，那么转换的结果依赖于机器。
        * 如果无符号类型的所有值都能存在该带符号类型中，则无符号类型转换成带符号类型。
        * 如果不能，带符号类型转换成无符号类型。


* 强制类型转换
    * `statci_cast`: 任何具有明确定义的类型转换，只要不包含`底层const`，都可以使用`static_cast`。
    * `dynamic_cast`
    * `const_cast`
    * `reinterpret_cast`


* `statci_cast`: 任何具有明确定义的类型转换，只要不包含`底层const`，都可以使用`static_cast`。
    * 把一个较大的算术类型赋值给较小类型（精度损失警告信息就会被关闭）
    * 找回存在于`void*`中的值（我们应确保指针的值保持不变，确保转换后的类型就是指针所指的类型，否则会有`Undefined`的后果）

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int i = 3;
	int j = 2;
	double slope = static_cast<double>(j) / i;
	cout << slope << endl;

	void* p = &slope;
	double* dp = static_cast<double*>(p);
	cout << *dp << endl;
}

```

* `const_cast`: 只能改变运算对象的`底层const`，不能改变类型。
    * 将常量对象转换成非常量对象，但是执行写操作就会产生`Undefined`的后果

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	const char* pc;
	char* p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
}
```

* `reinterpret_cast`: 通常为运算对象的位模式提供较低层次上的重新解释。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int* ip;
	char* pc = reinterpret_cast<char*>(ip);
	string str(pc); // 危险!!! 可能会有异常的行为

}

```


### unordered_<> and ordered_<>

> 原文链接：https://blog.csdn.net/haluoluo211/article/details/82468061

* Implementation
    * `set`基于红黑树实现，红黑树具有自动排序的功能，因此`map`内部所有的数据，在任何时候，都是有序的。
    * `unordered_set`基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存。

* Ordering
    * `set`: increasing order (by default)
    * `unordered_set`: no ordering

* Search time
    * `set`: log(n)
    * `unordered_set`: average -> O(1); worst case -> O(n)

* Insertion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Deletion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Key的类型

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	// unordered_set<vector<int>> usv; // unordered_set不能使用vector<int>作为key，因为vector<int>没有hash函数，除非自己定义一个
	set<vector<int>> sv;  // set可以使用vector<int>作为key，因为vector 重载了 operator<
	sv.insert({ 1, 2 });
	sv.insert({ 1, 3 });
	sv.insert({ 1, 2, 3 });
	sv.insert({ 4, 1 });
	for (vector<int> v : sv)
		cout << v << endl;
}
```

上面程序输出

```bash
1 2
1 2 3
1 3
4 1
```







### 函数

#### Print last K lines

```c++
#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>

using namespace std;

void printLast10Lines(char* fileName)
{
	const int K = 10;
	ifstream file(fileName);
	string L[K];
	int size = 0;

	/* read file line by line into circular array */
	/* peek() so an EOF following a line ending is not considered a separate line */
	while (file.peek() != EOF)
	{
		getline(file, L[size % K]);
		++size;
	}

	/* compute start of circular array, and the size of it*/
	int start = size > K ? (size % K) : 0;
	int count = min(K, size);

	/* print elements int the order they were read * /
	for (int i = 0; i < count; ++i)
		cout << L[(start + i) % K] << endl;
}

int main()
{
	return 0;
}
```


#### Reverse String

```c++
#include <iostream>
#include <algorithm> // swap
#include <string>

using namespace std;

void reverse(string& s)
{
	if (s.size() == 0) return;
	int start = 0;
	int end = s.size() - 1;
	while (start < end)
		swap(s[start++], s[end--]);
}

int main()
{
	string s = "Tong";
	reverse(s);
	cout << s << endl;
	return 0;
}
```


#### Copy Node

编写方法，传入参数为指向`Node`结构的指针，返回传入数据结构的完整拷贝。其中，`Node`数据结构含有两个指向其他`Node`的指针。

```c++
#include <iostream>
#include <map>

using namespace std;

struct Node
{
	Node* ptr1;
	Node* ptr2;
};

typedef map<Node*, Node*> NodeMap;

Node* copy_recursive(Node* cur, NodeMap& node_map)
{
	if (!cur) return nullptr;

	NodeMap::iterator i = node_map.find(cur);
	if (i != node_map.end()) return i->second; // we have been here before, return the copy

	Node* node = new Node;
	node_map[cur] = node; // map current before traversing links

	node->ptr1 = copy_recursive(cur->ptr1, node_map);
	node->ptr2 = copy_recursive(cur->ptr2, node_map);
	return node;
}

Node* copy_structure(Node* root)
{
	NodeMap node_map;	// we will need an empty map

	return copy_recursive(root, node_map);
}


int main()
{

	return 0;
}
```



















### 类

#### Basics

类的基本思想是数据抽象和封装。需要首先定义一个抽象数据类型。

数据抽象是一种依赖于接口和实现的分离的编程技术。

类的接口包括用户所能执行的操作；

类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。


#### 构造函数

在类内部定义：
```c++
Sales_data(const std::string &s):bookNo(s) {}
```

在类外部定义 (如果要调用别的函数)
```cpp
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this);
}
```


#### `public`, `protected`, `private`

* `private`: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
* `protected`: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
* `public`: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问

注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数.


#### class vs. struct

默认的继承访问权限：`struct`是`public`的，`class`是`private`的。


#### 静态成员

#### 继承

#### 多态继承

定义： 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）。
操作：在基类的函数前加上virtual关键字，在派生类中重写该函数，
运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；
如果对象类型是基类，就调用基类的函数。


#### 析构函数

* 基类的析构函数为何要声明为`virtual`?

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

class Foo
{
public:
	void f() { cout << "I am Foo" << endl; }
};

class Bar : public Foo
{
public:
	void f() { cout << "I am Bar" << endl; }
};


int main()
{
	Foo* p = new Bar();
	p->f();		// I am Foo

	return 0;
}
```
上述程序最后会调用`Foo::f()`，这是因为`p`是指向`Foo`的指针，而`f()`不是虚拟的。为确保`p->f()`会调用继承关系最末端的子类的`f()`实现，我们需要将`f()`声明为虚函数。

析构函数用于释放内存和资源。`Foo`的析构函数若不是虚拟的，那么，即使`p`实际上是`Bar`类型的，还是会调用`Foo`的析构函数。

所以，原因就是确保正确调用继承关系最末端的子类的析构函数。

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

class Foo
{
public:
	virtual void f() { cout << "I am Foo" << endl; }
};

class Bar : public Foo
{
public:
	void f() { cout << "I am Bar" << endl; }
};


int main()
{
	Foo* p = new Bar();
	p->f();		// I am Bar

	return 0;
}
```

* 调用顺序

```c++
#include <iostream>

using namespace std;

class Shape
{
public:
	int edge_length;
	virtual ~Shape()
	{
		cout << "Shape deleted\n";
	}
};

class Triangle : public Shape
{
public:
	~Triangle()
	{
		cout << "Triangle deleted\n";
	}
};

int main()
{
	Triangle* x = new Triangle();
	delete x;

	cout << endl << endl;

	Shape* y = new Triangle();
	delete y;
	return 0;
}
```

```bash
Triangle deleted
Shape deleted


Triangle deleted
Shape deleted
```


#### 虚函数

* 虚函数（virtual）：基类希望其派生类进行覆盖的函数。虚函数(virtual function) 需要虚函数表(vtable, Virtual Table)才能实现。如果一个类由函数声明成虚拟的，就会生成vtable，存放这个类的虚函数地址。此外，编译器还会在类里加入隐藏的`vptr`变量。若子类没有覆写虚函数，该子类的vtable就会存放父类的函数地址。调用这个虚函数时，就会通过vtable解析函数的地址。在C++里，动态绑定（dynamic binding）就是通过vtable机制实现的。由此，将子类对象赋值给基类指针时，`vptr`变量就会指向子类的vtable。这样一来，就能确保继承关系最末端的子类虚函数会被调用到。

```c++
#include <iostream>

using namespace std;

class Shape
{
public:
	int edge_length;
	virtual int circumference()
	{
		cout << "Circumference of Base Class\n";
		return 0;
	}
};

class Triangle : public Shape
{
public:
	int circumference()
	{
		cout << "Circumference of Triangle Class\n";
		return 3 * edge_length;
	}
};

int main()
{
	Shape* x = new Shape();
	x->circumference(); // "Circumference of Base Class"
	Shape* y = new Triangle();
	y->circumference(); // "Circumference of Triangle Class"
	return 0;
}
```



* 纯虚（pure virtual, =0）： ```double net_price(std::size_t) const = 0;```
    * 含有纯虚函数的类是抽象基类，不能创建抽象基类的对象。




#### 内联函数

C++ 内联函数是通常与类一起使用。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.


#### const

> https://www.cnblogs.com/MATU/p/5283454.html

```c++
class Test(){
public:
    Test(){}
    const int foo(int a);  //当const在函数名前面的时候修饰的是函数返回值。
    const int foo(int a) const; //当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。
};
```




### 初始化问题

```c++
#include <iostream>

using namespace std;

class A
{
private:
	int value;

public:
	A(int n) { value = n; }

	// PROBLEM: 复制构造函数A(A other)传入的参数是A的一个实例。由于是传值函数，我们把形参复制到实参会调用复制构造函数。因此，如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成无休止的递归调用从而导致栈溢出

	A(A other) { value = other.value; }  

	void Print() { cout << value << endl; }
};

int main()
{
	A a = 10;
	A b = a;
	b.Print();

	return 0;
}
```

将上述代码修改如下后才能运行

```c++
#include <iostream>

using namespace std;

class A
{
private:
	int value;

public:
	A(int n) { value = n; }
	A(const A& other) { value = other.value; }  

	void Print() { cout << value << endl; }
};

int main()
{
	A a = 10;
	A b = a;
	b.Print();

	return 0;
}
```


#### 输出问题

在C++中，成员变量的初始化顺序只与它们在类中声明的顺序有关，而与在初始化列表中的顺序无关。在下列程序中，`n1`先于`n2`被声明，因为`n1`也会在`n2`之前被初始化。所以，`n1`的值是随机的，`n2`的值为0.

```c++
#include <iostream>

using namespace std;

class A
{
private:
	int n1;
	int n2;
public:
	A() : n2(0), n1(n2 + 2)
	{

	}

	void Print()
	{
		cout << "n1: " << n1 << ", n2: " << n2 << endl;
	}
};

int main()
{
	A a;
	a.Print();		// n1: 不确定，n2: 0

	return 0;
}
```

#### 编写一个智能指针类

智能指针是一种数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录`SmartPointer<T*>`对象的引用计数，一旦`T`类型对象的引用计数为零，就会释放该对象。

```c++
#include <iostream>

using namespace std;

template <class T>
class SmartPointer
{
public:
	SmartPointer(T* ptr)
	{
		ref = ptr;
		ref_count = (unsigned*)malloc(sizeof(unsigned));
		*ref_count = 1;
	}

	SmartPointer(SmartPointer<T>& sptr)
	{
		ref = sptr.ref;
		ref_count = sptr.ref_count;
		++(*ref_count);
	}

	SmartPointer<T>& operator=(SmartPointer<T>& sptr)
	{
		if (this == &sptr) return *this;

		/* If already assigned to an object, remove one reference */
		if (*ref_count > 0) remove();

		ref = sptr.ref;
		ref_count = sptr.ref_count;
		++(*ref_count);
		return *this;
	}

	~SmartPointer()
	{
		remove(); // Remove one reference to object

	}

	T getValue()
	{
		return *ref;
	}

protected:
	void remove()
	{
		--(*ref_count);
		if (*ref_count == 0) delete ref;
		free(ref_count);
		ref = nullptr;
		ref_count = nullptr;
	}

	T* ref;
	unsigned* ref_count;
};


int main()
{
	return 0;
}
```


#### OOP: 面向对象程序设计

数据抽象，继承和动态绑定。





### Templates

```c++


```














### 多线程

#### 实现方式




### 内存泄漏 (Memory Leak)

Memory leak if nobody has freed the memory.

* 忘记`delete`或者`delete`两次同一个地址

```c++
#include <iostream>

using namespace std;

int main()
{
	double* ptr_1 = nullptr;
	double* ptr_2 = nullptr;
	int size = 10;

	// Allocate memory for two arrays on the heap

	ptr_1 = new double[size];
	ptr_2 = new double[size];
	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;		// 1: 00FF5670 2: 00FF5398

	ptr_2 = ptr_1; // ptr_2 overwritten. PROBLEM: no change to access the previous memory of ptr_2， 之前的内存没法删除了

	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;		// 1: 00FF5670 2: 00FF5670

	delete[] ptr_1;
	delete[] ptr_2;    // 同一个地址删了两次

	return 0;
}
```

* If we run out of memory, `std::bad_alloc` error is thrown.

```c++
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

int main()
{
	double* data = nullptr;
	size_t size = pow(1024, 3) / 8; // Produce 1 GB

	for (int i = 0; i < 5; ++i)
	{
		// Allocate memory for the data

		data = new double[size];
		fill(data, data + size, 1.23);

		cout << "Iteration: " << i << " done!" << endl;
	}

	delete[] data; // PROBLEM: This will only free the last allocation!!!

	return 0;
}
```

### 悬挂指针（Dangling pointer）

Dangling pointer if somebody has freed the memory in a function.

```c++
#include <iostream>

using namespace std;

int main()
{
	int size = 5;
	int* ptr_1 = new int[size];
	int* ptr_2 = ptr_1;

	ptr_1[0] = 100;
	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;	// 1: 01245D78 2: 01245D78
	cout << "ptr_2 [0]: " << ptr_2[0] << endl;	// ptr_2 [0]: 100

	delete[] ptr_1; // Free memory.

	ptr_1 = nullptr;
	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;	// 1: 00000000 2: 01245D78

	// PROBLEM: Data under ptr_2 does not exist anymore!

	cout << "ptr_2 [0]: " << ptr_2[0] << endl; // ptr_2[0]: -572662307

	return 0;
}
```



### RTTI (Runtime Type Information)








### OpenCV

#### cv::Mat如何析构




### cmake


```cmake
cmake_minimum_required(VERSION 2.8)
project(myslam)

set(CMAKE_BUILD_TYPE Release)

set(CMAKE_CXX_FLAGS "-std=c++11 -Wall")
set(CMAKE_CXX_FLAGS_RELEASE  "-std=c++11 -O3 -fopenmp -pthread")

list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

############### dependencies ######################
# Eigen
include_directories("/usr/include/eigen3")

# OpenCV
find_package(OpenCV 3.1 REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})

# pangolin
find_package(Pangolin REQUIRED)
include_directories(${Pangolin_INCLUDE_DIRS})

# Sophus
find_package(sophus REQUIRED)
include_directories(${sophus_INCLUDE_DIRS})

# G2O
# find_package(G2O REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/g2o/)

# glog
#find_package(Glog REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/glog/)

# gtest
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

# gflags
# find_package(GFlags REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/gflags/)

# csparse
find_package(CSparse REQUIRED)
include_directories(${CSPARSE_INCLUDE_DIR})

set(THIRD_PARTY_LIBS
        ${OpenCV_LIBS}
        ${sophus_LIBRARIES}
        ${Pangolin_LIBRARIES} GL GLU GLEW glut
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_core.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_stuff.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_types_sba.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_solver_csparse.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_csparse_extension.so
        ${GTEST_BOTH_LIBRARIES}
        ${PROJECT_SOURCE_DIR}/thirdparty/glog/build/libglog.a
        ${PROJECT_SOURCE_DIR}/thirdparty/gflags/build/lib/libgflags.a
        pthread
        ${CSPARSE_LIBRARY}
        )

enable_testing()
############### source and test ######################
include_directories(${PROJECT_SOURCE_DIR}/include)
add_subdirectory(src)
add_subdirectory(test)
add_subdirectory(app)
```


```cmake
# src/CMakeLists.txt
add_library(myslam SHARED
        frame.cc
        mappoint.cc
        map.cc
        camera.cc
        config.cc
        feature.cc
        frontend.cc
        backend.cc
        viewer.cc
        visual_odometry.cc
        dataset.cc)

target_link_libraries(myslam
        ${THIRD_PARTY_LIBS})
```




### Eigen

#### 行优先还是列有限




### 数据结构

#### 四叉树

#### cv::Mat
