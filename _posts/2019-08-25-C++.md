---
layout:     post
title:      "C++"
date:       2019-8-25
author:     Tong
catalog: true
tags:
    - Language
---

### Basics

#### 面向对象 vs. 面向过程（C语言）

#### 面向对象

面向对象的三大特性：封装、继承、多态



#### 静态类型 (statically typed)

C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查 (type checking)。



#### `endl`

`endl`的作用是结束当前行，并将与设备关联的缓冲区(buffer)中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。


#### C语言关键字`volatile`有何作用？

作用是指示编译器，即使代码不对变量做任何改动，该变量的值仍可能会被外界修改。操作系统，硬件或其他线程都有可能修改该变量。该变量的值有可能遭受意料之外的修改，因此，每一次使用时，编译器都会重新从内存中获取这个值。

可以方式编译器执行一些我们不想要的优化。

`volatile`在多线程程序也很有用，对应全局变量，任意线程都可能修改这些共享的变量。我们可能不希望编译器对这些变量进行优化。



#### 预处理器 (preprocessor)

* 在C++编译过程中执行的一段程序

* 确保头文件多次包含仍能安全工作的常用技术

* 头文件保护符 (header guard)，头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。




#### Shallow vs Deep Copy

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

struct Test
{
	char* ptr;
};

void shallow_copy(Test& src, Test& dest)
{
	dest.ptr = src.ptr;
}

void deep_copy(Test& src, Test& dest)
{
	dest.ptr = (char*)malloc(strlen(src.ptr) + 1);
	strcpy_s(dest.ptr, strlen(src.ptr) + 1, src.ptr);
}

int main()
{
	Test src;
	char tmp = 'a';
	src.ptr = &tmp;
	cout << *src.ptr << endl;		// a

	Test dest_shallow;
	shallow_copy(src, dest_shallow);
	cout << *dest_shallow.ptr << endl;	// a

	Test dest_deep;
	deep_copy(src, dest_deep);
	cout << *dest_deep.ptr << endl;	// a

	*dest_shallow.ptr = 'b';
	cout << *src.ptr << endl;		// b

	cout << *dest_shallow.ptr << endl; // b

	cout << *dest_deep.ptr << endl; // c

	*dest_deep.ptr = 'c';
	cout << *src.ptr << endl;  // b

	cout << *dest_shallow.ptr << endl; // b

	cout << *dest_deep.ptr << endl; // c

	return 0;
}
```



### STL - Standard Template Library

* 容器（Container），是一种数据结构，如list，vector，和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器；

* 迭代器（Iterator），提供了访问容器中对象的方法。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。迭代器就如同一个指针。事实上，C++的指针也是一种迭代器。但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符地方法的类对象；

* 算法（Algorithm），是用来操作容器中的数据的模板函数。例如，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以在从简单数组到高度复杂容器的任何数据结构上使用；

* 仿函数（Function object）

* 迭代适配器（Adaptor）

* 空间配制器（allocator）













### 变量与基本类型

#### 混用unsigned和signed类型

* 如果表达式里既有带符号数又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。

* 当从无符号数减去一个值时，不管这个值是不是无符号数，都必须确保结果不能是一个负值。

```c++
#include <iostream>

using namespace std;

int main()
{
	unsigned u = 10, u2 = 42;
	cout << u2 - u << endl;	// 32

	cout << u - u2 << endl;	// 4294967264

	int i = 10, i2 = 42;

	cout << i2 - i << endl;	// 32

	cout << i - i2 << endl;	// -32

	cout << i - u << endl;	// 0

	cout << u - i << endl;	// 0

	cout << i - u2 << endl;	// 4294967264

	cout << u2 - i << endl; // 32
}
```

#### 字面值常量

* 整形字面值
    * 20 // 十进制，默认情况下是带符号数，类型是`int`, `long`, `long long`中能容下当前值并且尺寸最小的那个
    * 024 // 以`0`开头，八进制。
    * 0x14 // 以`0x`或者`0X`开头， 十六进制。
    * 八进制和十六进制的类型是能容下其数值的`int`, `unsigned int`, `long`, `unsigned long`, `long long`和`unsigned long long`中的尺寸最小者。如果一个都放不下，将产生错误。
    * 注意：十进制字面值不会是负数，`-40`的字面值仍然是`40`。

* 浮点型字面值
    * 默认的浮点型字面值是一个`double`
    * 表现为一个小数或以科学计数法表示的指数，其中指数部分用`E`或`e`标识: `3.14159`, `3.1415926E0`, `0.`, `0e0`, `.001`。

#### 列表初始化 (list initialization)

* 如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。

```c++
#include <iostream>

using namespace std;

int main()
{
	int a = 1;

	int b = { 2 };

	int c{ 3 };	// 列表初始化

	int d(4);

	cout << "a: " << a << "; b: " << b << "; c: " << c << "; d: " << d << endl; // a: 1; b: 2; c: 3; d: 4

	long double ld = 3.1415;
	int a1(ld), b1 = ld;	// 转换执行，且确实丢失了部分值

	cout << "a1: " << a1 << "; b1: " << b1 << endl;	// a1: 3; b1: 3

	int c1{ ld }, d1 = { ld }; // ERROR!!! 转换未执行，因为存在丢失信息的危险
}

```

#### 默认初始化

* 如果内置类型的变量未被显式初始化，它的值由定义的位置决定。定义于任何函数体之外的变量被初始化为0。

* 一种例外情况是，定义在函数体内部的内置类型变量将 __不被初始化__。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。

* 类的对象如果没有显式地初始化，则其值由类决定。

```c++
#include <iostream>

using namespace std;

string global_str;	// ""
int global_int;		// 0

int main()
{
	cout << "global_str: " << global_str << "; global_int: " << global_int << endl;
	// global_str: ; global_int: 0

	int local_int;		// Undefined
	string local_str;	// Undefined
}
```

#### `declaration` vs. `definition`

* __声明__ 使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而 __定义__ 负责创建与名字关联的实体。

* 如果想声明一个变量而非定义它，就在变量名前添加关键字`extern`，而且不要显示地初始化变量。

* 在函数体内部，如果试图初始化一个由`extern`关键子标记的变量，将引发错误。

* 变量能且只能被定义一次，但是可以被多次声明。

```c++
extern int i; // 声明

int j; // 声明且定义

extern double pi = 3.14; // 定义
```


#### 作用域

```c++
#include <iostream>

using namespace std;

int reused = 42;

int main()
{
	int unique = 0;
	cout << reused << " " << unique << endl;	// 42 0

	int reused = 0;
	cout << reused << " " << unique << endl;	// 0 0

	cout << ::reused << " " << unique << endl;	// 42 0, 因为显式地访问全局变量

}

```

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 100, sum = 0;
	for (int i = 0; i != 10; ++i)
		sum += i;
	cout << i << " " << sum << endl;	// 100 45

}

```

#### 引用

```c++
#include <iostream>

using namespace std;

int main()
{
	int ival = 1.01;
	int& rvall = 1.01;	// ERROR: 引用类型的初始值必须是一个对象

	int& rval2 = ival;

	int& rval3;			// ERROR: 引用必须被初始化

    double& dval4 = ival; // ERROR: 类型必须相同，但有两个例外。

}

```


```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 0, &r1 = i;
	double d = 0, &r2 = d;
	r2 = 3.14159;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i: 0; r1: 0; d: 3.14159; r2: 3.14159

	r2 = r1;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i : 0; r1 : 0; d : 0; r2: 0

	i = r2;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i: 0; r1: 0; d: 0; r2: 0

	r1 = d;
	cout << "i: " << i << "; r1: " << r1 << "; d: " << d << "; r2: " << r2 << endl;
	// i : 0; r1 : 0; d : 0; r2: 0
}
```


#### `const`

* 要想在多个文件间共享`const`对象，必须在变量的定义之前添加`extern`关键字。

* 在初始化常量引用时允许用任意表达式作为初始值（不一定要类型相同），只要该表达式的结果能转换成引用的类型即可。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	const int& r1 = i;			// 允许将const int&绑定到一个普通的int对象上

	const int& r2 = 42;			// 正确: r2是一个常量引用

	const int& r3 = r1 * 2;		// 正确: r3是一个常量引用

	int& r4 = r1 * 2;			// ERROR: r4是一个普通的非常量引用

	const double& r5 = i;		// 正确: r5是一个常量引用

}

```

* 常量指针 (const pointer)

从右往左阅读。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	int *const iptr = &i;

	*iptr = 0;	// 正确
	iptr = 0;   // ERROR: iptr是const

}
```


* 指向常量的指针 (pointer to const)

从右往左阅读


```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	const int* iptr = &i;

	*iptr = 0;	// ERROR: *iptr是const

	iptr = 0;   // 正确

}
```


#### 顶层`const` vs. 底层`const`

* 顶层`const`表示任意的对象是常量，例如指针本身

* 底层`const`表示指针所指的对象是一个常量

* 指针类型既可能是顶层也可能是底层`const`，这一点和其他类型相比区别明显

* 在执行对象的拷贝操作时，顶层`const`不受什么影响，但是拷入和拷出的对象必须具有相同的底层`const`资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之则不行。

```c++
int i = 0;
int *const p1 = &i; // top-level const

const int ci = 42; // top-level const

const int *p2 = &ci; // low-level const
```

#### 常量表达式

* 常量表达式 (const expression)是指值不会改变并且在编译过程就能得到计算结果的表达式。

* 字面值属于常量表达式，用常量表达式初始化的`const`对象也是常量表达式。

* (C++ 11) 允许将变量声明为`constexpr`类型以便由编译器来验证变量的值是否是一个常量表达式。

* 一般来说，如果认定一个变量是常量表达式，那就把它声明成`constexpr`类型。

```c++
#include <iostream>

using namespace std;

int size()
{
	return 10;
}

constexpr int size2()
{
	return 20;
}

int main()
{
	constexpr int mf = 20;				// 正确
	constexpr int limit = mf + 1;		// 正确
	constexpr int sz = size();			// 错误，除非size()是个constexpr函数
	constexpr int sz2 = size2();		// 正确
}

```

* 指针如果定义为`constexpr`，它仅对指针有效，对指针所指的对象无效。

```c++
const int* p = nullptr;     // p是一个指向整型常量的指针

constexpr int *q = nullptr; // q是一个指向整数的常量指针
```

* 一个`constexpr`指针的初始值必须是`nullptr`或者0，或者是存储与某个固定地址中的对象。

* 函数体内定义的变量一般来说并非存放在固定地址中，因此`constexpr`指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化`constexpr`指针。除此之外，允许函数定义一类有效范围超出函数本身的变量，这类变量一样也有固定地址，`constexpr`指针也能指向这样的变量。

```c++
#include <iostream>

using namespace std;

constexpr int* np = nullptr;
int j = 0;
constexpr int i = 42;
// i, j都必须定义在函数体之外

int main()
{
	constexpr const int* p = &i;
	constexpr int* p1 = &j;
}
```


#### `auto`

* `auto`能在一条语句声明多个变量，但是该语句种所有变量的初始基本数据类型必须一样。

```c++
#include <iostream>

using namespace std;

int main()
{
	auto i = 0, *p = &i;		// 正确
	auto sz = 0, pi = 3.14;		// ERROR! sz和pi类型不一致
}
```

* `auto`一般会忽略顶层`const`，同时底层`const`则会保留下来。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 0, &r = i;
	auto a = r; // a是一个整数

	const int ci = i, &cr = ci;

	auto b = ci;	// b是一个整数 (ci的顶层const特性被忽略掉了)

	auto c = cr;	// c是一个整数

	auto d = &i;	// d是一个整形指针

	auto e = &ci;	// e是一个指向整数常量的指针 (对常量对象取地址是一种底层const)

}

```

* `auto`被设置成引用，原来的规则仍然适用

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 1;
	const int ci = i;

	auto& h = 42; // ERROR! 不能为非常量引用绑定字面值

	const auto& j = 42;	// 正确：可以为常量引用绑定字面值

	auto k = ci, & l = i;	// 正确：k是整数，l是整形引用

	auto& m = ci, * p = &ci;	// 正确：m是对整形常量的引用，p是指向整型常量的指针

	auto& n = i, * p2 = &ci;	// ERROR! i的类型是int，而&ci的类型是const int
}
```

```c++
#include <iostream>

using namespace std;

int main()
{
	const int i = 42;

	auto j = i;	// 整数

	++j;
	cout << j << endl;

	const auto& k = i;	// 整型常量的引用

	auto* p = &i;	// 指向一个整型常量的指针

	p = nullptr;

	const auto j2 = i, & k2 = i;	// j2是一个整数常量，k2是一个对整数常量的引用
}
```


#### `decltype()`

* `decltype((variable))` (双层括号)的结果永远是引用，而`decltype(variable)`结果只有当`variable`本身就是一个引用时才是引用。

* 如果`i`是`int`，那么表达式`i=x`的类型是`int&`。

```c++
#include <iostream>

using namespace std;

int main()
{
	const int ci = 0, &cj = ci;
	decltype(ci) x = 0; // x的类型是const int

	decltype(cj) y = x; // y的类型是const int&, y绑定到变量x

	decltype(cj) z;	// ERROR! z是一个引用，必须初始化


	int i = 42, *p = &i, &r = i;
	decltype(r + 0) b;	// 正确：加法的结果是int，因此b是一个int

	decltype(*p) c;	// ERROR! c是int&, 必须初始化

	decltype((i)) d; // ERROR! d是int&, 必须初始化

	decltype(i) e; // 正确：e是一个未初始化的int
}

```

```c++
#include <iostream>

using namespace std;

int main()
{
	int a = 3, b = 5;
	decltype(a) c = a;
	decltype((b)) d = a;
	--c;
	++d;
	cout << a << " " << b << " " << c << " " << d << endl;
	// 4 5 2 4

}
```

```c++
#include <iostream>

using namespace std;

int main()
{
	int a = 3, b = 4;
	decltype(a) c = a;
	decltype(a = b) d = a;
	d = 5;
	cout << a << " " << b << " " << c << " " << d << endl;
	// 5 4 3 5

}

```



### 指针 (Pointer)

#### 基本用法

```bash
a)	int** p;

b)	int *p[10];        // 指向int类型的指针数组p[10]

c)	int (*p)[10];      // 指向有10个int类型的数组的指针p

d)	int (*p)(int);     // 函数指针，指向有一个参数并且返回类型 均为int的函数

e)	int (*p[10])(int); // 函数指针的数组, 指向有一个参数并且返回类型均为int的函数的数组
```

```c++
#include <iostream>

using namespace std;

int main()
{
	int i = 42;
	int& r = i;
	int* p = &i;
	int& r2 = *p;
	cout << "i: " << i << endl;			// i: 42
	cout << "r: " << r << endl;			// r: 42
	cout << "p: " << p << endl;			// p: 0000005DB88FFB84
	cout << "*p: " << *p << endl;		// *p: 42
	cout << "r2: " << r2 << endl;		// r2: 42

	r2 = 10;
	cout << "i: " << i << endl;			// i: 10
	cout << "r: " << r << endl;			// r: 10
	cout << "p: " << p << endl;			// p: 0000005DB88FFB84
	cout << "*p: " << *p << endl;		// *p: 10
	cout << "r2: " << r2 << endl;		// r2: 10
}
```

```c++
int* a, b; // a是指向int的指针，b是int
```

```c++
#include <iostream>

using namespace std;

int main()
{
	char a = 'a';
	typedef char* pstring;
	const pstring cstr1 = &a; // 指向char的常量指针

	*cstr1 = 'b';	// 正确

	const char* cstr2 = &a;	// 指向const char的指针

	*cstr2 = 'c';	// ERROR! const char不能赋值

	const pstring* ps = &cstr1;	// ps是一个指针，它的对象是指向char的常量指针

}
```

#### 空指针

```c++
#include <iostream>
#include <cstdlib>	// NULL

using namespace std;

int main()
{
	int* p1 = nullptr;    // C++ 11
	int* p2 = NULL; // preprocesor variable
	int* p1 = 0;

	int* p2;
	int a = 0;
	p2 = a;			// ERROR: 不能把int变量赋给指针
}
```

#### `void*`指针

* `void*`可用于存放任意对象的地址。但我们不知道该地址中到底是个什么类型的对象。

* 作用：拿它和别的指针比较；作为函数的输入或输出；或者赋给另外一个`void*`指针。

* 不能直接操作`void*`指针所指的对象，因为我们并不知道这个对象是什么类型。



#### 指向指针的引用

```c++
#include <iostream>
using namespace std;

int main()
{
	int i = 42;
	int* p;
	int*& r = p;

	r = &i;
	cout << i << " " << * p << " " << * r << endl;
	// 42 42 42

	* r = 0;
	cout << i << " " << * p << " " << * r << endl;
	// 0 0 0
}
```

#### 指针 vs. 引用

* 指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元。而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。如：
```c++
int a = 1;
int *p = &a;
int a = 1;
int &b = a;
```
上面定义了一个整形变量和一个指针变量p，该指针变量指向a的存储单元，即p的值是a存储单元的地址。而下面2句定义了一个整形变量a和这个整形a的引用b，事实上a和b是同一个东西，在内存占有同一个存储单元。

* 可以有const指针，但是没有const引用；

* 指针可以有多级，但是引用只能是一级（`int **p`；合法 而`int &&a`是不合法的）

* 指针的值可以为空，但是引用的值不能为`NULL`，并且引用在定义的时候必须初始化；

* 指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

* `sizeof(引用)`得到的是所指向的变量(对象)的大小，而`sizeof(指针)`得到的是指针本身的大小；

* 指针和引用的自增(++)运算意义不一样；
















### string

#### initialization

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s1 = "Tong";            // 拷贝初始化（使用了等号）
	string s2("Tong");             // 直接初始化
	string s3(s2.begin(), s2.end());
	string s4(5, 'a');				// Attention: char instead of string as the second parameter, "aaaaa"

	string s5(s1, 2, 1);			// "n" (string, start, length)

	string s6 = s1.substr(2, 1);	// "n", (string, start, length)

	string s7 = to_string(123);		// "123"

	cout << s1 << endl << s2 << endl << s3 << endl << s4 << endl << s5 << endl << s6 << endl << s7;
}
```

#### 默认初始化

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s;      // size() = 0
	char c = s[0]; // '\0'
	cout << c << endl;
	return 0;
}
```

#### `getline()`

* `cin`自动忽略空白字符，`getline`会接收。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string line;
	while (getline(cin, line))
		cout << line << endl;
}
```


#### `size()`

* `string::size_type`是个无符号类型

* 如果一条表达式中已经有了`size()`函数就不要再使用`int`了，这样可以避免混用`int`和`unsigned`可能带来的问题。


#### 相加

* C++语言中的字符串字面值并不是标准库类型`string`的对象。

```c++
string a = "Hello " + "Tong"; // ERROR! 不能直接运算两个字符串字面值
```


#### `c_str()`

```c++
// #include <string>
const char* c_str() const noexcept;
```

```c++
#include <iostream>
#include <string>

using namespace std;

int main()
{
	string s1 = "12345";
	cout << s1.size() << endl;		// 5

	cout << sizeof(string) << endl; // 28, 固定长度，和编译器有关

	cout << sizeof(s1) << endl;		// 28

	const char* c1 = s1.c_str();
	cout << c1 << endl;			// 12345

	cout << sizeof(c1) << endl; // 4, 因为指针是固定长度
}
```

#### `atoi()`

```c++
// #include <cstdlib>
int atoi (const char * str);
```

【函数说明】`atoi()` 函数会扫描参数 str 字符串，跳过前面的空白字符（例如空格，tab缩进等，可以通过 `isspace()` 函数来检测），直到遇上数字或正负符号才开始做转换，而再遇到非数字或字符串结束时('\0')才结束转换，并将结果返回。

【返回值】返回转换后的整型数；如果 `str` 不能转换成 `int` 或者 `str` 为空字符串，那么将返回 0。

`atoi()`的参数是 `const char*` ,因此对于一个字符串`str`我们必须调用 `c_str()`的方法把这个`string`转换成 `const char*`类型的。

`atoi()`不会做范围检查，如果超出范围的话，超出上界，则输出上界，超出下界，则输出下界；

```c++
#include <iostream>
#include <cstdlib>	// atoi()
#include <string>	// c_str()

using namespace std;

int main()
{
	char s1[] = "-123";
	cout << atoi(s1) << endl; // -123

	const char* s2 = "aa-123";
	cout << atoi(s2) << endl; // 0

	string s = "aaa-";
	const char* s3 = s.c_str();
	cout << atoi(s3) << endl; // 0
}
```



#### `stoi()`

```c++
// #include <string>
int stoi (const string&  str, size_t* idx = 0, int base = 10);
int stoi (const wstring& str, size_t* idx = 0, int base = 10);
```

stoi()会做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error！

```c++
#include <iostream>
#include <string>	// stoi()

using namespace std;

int main()
{
	string s0 = "1234";
	cout << stoi(s0) << endl;	// 1234

	char s1[] = "-123";
	cout << stoi(s1) << endl;	// -123

	const char* s2 = "-12312";
	cout << stoi(s2) << endl;	// -12312

	string s3 = "aa-123";
	//cout << stoi(s3) << endl; // ERROR

	string s4 = "aaa-";
	//cout << stoi(s4) << endl; // ERROR

}
```

#### 搜索操作

```bash
搜索操作返回指定字符出现的下标，如果未找到时则返回`npos`。

s.find(args)            // 查找s中args第一次出现的位置
s.rfind(args)           // 查找s中args最后一次出现的位置
s.find_first_of(args)   // 在s中查找args任何一个字符第一次出现的位置
s.find_last_of(args)    // 在s中查找args任何一个字符最后一次出现的位置
s.find_first_not_of(args) // 在s中查找第一个不在args的字符
s.find_last_not_of(args)  // 在s中查找最后一个不在args中的字符
```


#### 寻找所有子字符串出现的所有位置

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s;
	cin >> s;
	string numbers("0123456789");

	string::size_type pos = 0;
	while ((pos = s.find_first_of(numbers, pos)) != string::npos)
	{
		cout << "Found number at index: " << pos << " element is " << s[pos] << endl;
		++pos;
	}
}
```


#### 函数-替换string

```c++
#include <iostream>

#include <string>

using namespace std;

void replaceFcn(string& s, const string& old_val, const string& new_val)
{
	int len = old_val.size();
	int new_len = new_val.size();
	for (int i = 0; i < s.size() - len + 1;)
	{
		if (s.substr(i, len) == old_val)
		{
			s.erase(i, len);
			s.insert(i, new_val);
			i += new_len;
		}
		else
			++i;
	}
}

int main()
{
	string s;
	cin >> s;
	replaceFcn(s, "tho", "though");
	cout << s << endl;
}
```














### vector

#### 初始化

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// initialization

	vector<int> v1{ 1, 2, 3 };  // [1, 2, 3]

	cout << "v1" << endl << v1 << endl << endl;

	vector<int> v2(5, 0);		// [0, 0, 0, 0, 0]

	cout << "v2" << endl << v2 << endl << endl;

	vector<int> v3(v2.begin(), v2.end());
	cout << "v3" << endl << v3 << endl << endl;
	int arr4[] = { 10, 20, 30 };
	vector<int> v4(arr4, arr4 + sizeof(arr4) / sizeof(arr4[0]));
	cout << "v4" << endl << v4 << endl << endl;
	vector<int> v5;
	v5.push_back(1);
	v5.push_back(2);
	cout << "v5" << endl << v5 << endl << endl;
	vector<vector<int>> v6(3, vector<int>(4, -1));  // 3 x 4

    vector<string> v7{10, "hi"}; // ATTENTION! 尽量避免这种方式。系统检测出10无法初始化为string，所以最后v7是包含10个"hi"的vector

}
```


#### 值初始化

* 如果`vector`对象的元素是内置类型，比如`int`，则元素初始值自动设为0。如果元素是某种类型，比如`string`，则元素由类默认初始化。

```c++
#include <iostream>

#include <string>

#include <vector>

using namespace std;

int main()
{
	vector<int> ivec(10);
	cout << ivec[0] << endl;	// 10个元素，每个都初始化为0

	vector<string> svec(10);
	cout << svec[0] << endl;	// 10个元素，每个都是空string对象
}

```

#### size_type

```bash
vector<int>::size_type  // 正确
vector::size_type       // 错误
```


#### 缓冲区溢出 (buffer overflow)

指通过下标访问不存在的元素的行为。

```c++
vector<int> ivec;
cout << ivec[0];

vector<int> ivec2(10);
cout << ivec2[10];
```


#### 添加元素

* 范围`for`语句体内不应改变其所遍历序列的大小

* `push_back()`

 ```c++
void push_back (const value_type& val);
void push_back (value_type&& val);
```

在引入右值引用，转移构造函数，转移复制运算符之前，通常使用push_back()向容器中加入一个右值元素（临时对象）的时候，首先会调用构造函数构造这个临时对象，然后需要调用拷贝构造函数将这个临时对象放入容器中。原来的临时变量释放。这样造成的问题是临时变量申请的资源就浪费。
引入了右值引用，转移构造函数（请看这里）后，push_back()右值时就会调用构造函数和转移构造函数。




* `emplace_back()`

```c++
template <class... Args>
  void emplace_back (Args&&... args);
```

在容器尾部添加一个元素，这个元素原地构造，不需要触发拷贝构造和转移构造。而且调用形式更加简洁，直接根据参数初始化临时对象的成员。

```c++
// https://blog.csdn.net/xiaolewennofollow/article/details/52559364

#include <vector>  
#include <string>  
#include <iostream>  

struct President
{
	std::string name;
	std::string country;
	int year;

	President(std::string p_name, std::string p_country, int p_year)
		: name(std::move(p_name)), country(std::move(p_country)), year(p_year)
	{
		std::cout << "I am being constructed.\n";
	}
	President(const President& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being copy constructed.\n";
	}
	President(President&& other)
		: name(std::move(other.name)), country(std::move(other.country)), year(other.year)
	{
		std::cout << "I am being moved.\n";
	}
	President& operator=(const President& other);
};

int main()
{
	std::vector<President> elections;
	std::cout << "emplace_back:\n";
	elections.emplace_back("Nelson Mandela", "South Africa", 1994); //没有类的创建  

	std::vector<President> reElections;
	std::cout << "\npush_back:\n";
	reElections.push_back(President("Franklin Delano Roosevelt", "the USA", 1936));

	std::cout << "\nContents:\n";
	for (President const& president : elections) {
		std::cout << president.name << " was elected president of "
			<< president.country << " in " << president.year << ".\n";
	}
	for (President const& president : reElections) {
		std::cout << president.name << " was re-elected president of "
			<< president.country << " in " << president.year << ".\n";
	}

}
```


```bash
emplace_back:
I am being constructed.

push_back:
I am being constructed.
I am being moved.

Contents:
Nelson Mandela was elected president of South Africa in 1994.
Franklin Delano Roosevelt was re-elected president of the USA in 1936.
```


#### 动态扩展

* 由下面例子可以看到，`vector`在添加元素时，会多次重新分配内存。但是，当vector在删除元素的时候，容量并不会随着减小。vector的增容方式为： 0  1  2  3  4  6 ... 从第三项开始基本遵循`capacity = capacity + capacity / 2`这个规律。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	cout << "orignal capacity: " << v.capacity() << endl;
	auto capacity = v.capacity();
	for (int i = 0; i < 1000; ++i)
	{
		v.push_back(i);
		if (v.capacity() != capacity)
		{
			cout << "new capacity: " << v.capacity() << endl;
			capacity = v.capacity();
		}
	}
}
```

```bash
orignal capacity: 0
new capacity: 1
new capacity: 2
new capacity: 3
new capacity: 4
new capacity: 6
new capacity: 9
new capacity: 13
new capacity: 19
new capacity: 28
new capacity: 42
new capacity: 63
new capacity: 94
new capacity: 141
new capacity: 211
new capacity: 316
new capacity: 474
new capacity: 711
new capacity: 1066
```

* `reserve()`

```c++
void reserve (size_type n);
```

`reserve()`使用空间置配器 ( allocator ) 来分配内存，也就是，没有存储元素的那部分内存是原生 ( raw ) 内存。要是`n`小于或等于`v.capacity()`，那么，`v`将忽略这个操作。
要是`n`大于`v.capacity()`，那么，v将会重新分配内存，并保证新的容量至少为n。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.reserve(500);
	cout << v.size() << endl;		// 0
	cout << v.capacity() << endl;   // 500
}
```

* `resize()`

```c++
void resize (size_type n);
void resize (size_type n, const value_type& val);
```

`resize()`的行为将取决于参数n，
    * 当`n`小于元素的个数，那么，容器的前`n`个元素将得到保留，其它的元素将被移除并销毁。
    * 当`n`大于元素的个数，那么，新的元素将被默认初始化，并添加到容器末尾。要是指定了`val`，那么，将使用`val`来初始化新的元素。
    * 要是`n`大于容器的容量，那么，在添加新元素之前，容器的内存将进行重新分配。

```c++
#include <iostream>
#include <vector>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v;
	v.resize(500);
	cout << v.size() << endl;		// 500
	cout << v.capacity() << endl;   // 500
}
```



#### 删除元素

* `pop_back()`: 删除尾部元素，内存没有被真正释放

```c++
#include <iostream>
#include <vector>

using namespace std;

int main()
{
	// pop_back()
	vector<int> v{ 1, 2, 3 };
	cout << v.size() << endl;		// 3
	cout << v.capacity() << endl;   // 3
	v.pop_back();
	cout << v.size() << endl;		// 2
	cout << v.capacity() << endl;   // 3
}
```


* `erase()`: 从指定容器删除指定位置的元素或某段范围内的元素。返回值是一个迭代器，指向删除元素下一个元素；如果是删除某范围内的元素时：返回值也表示一个迭代器，指向最后一个删除元素的下一个元素。内存没有被真正释放。

```c++
#include <iostream>
#include <vector>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	// iterator erase(const_iterator position);
	// iterator erase(const_iterator first, const_iterator last);
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	auto it = v.erase(v.begin() + 1);
	cout << * it << endl;				// 3
	cout << v << endl;					// 1 3 4 5 6 7 8
	cout << v.size() << endl;			// 7
	cout << v.capacity() << endl;       // 8

	it = v.erase(v.begin(), v.begin() + 3);
	cout << * it << endl;				// 5
	cout << v << endl;					// 5 6 7 8
	cout << v.size() << endl;			// 4
	cout << v.capacity() << endl;       // 8
}
```



* `clear()`: `size()`一定会变为0，但是`capacity()`不保证会变成0.

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
}
```

* `swap()`: `vector<T>().swap(x);   // clear x reallocating`. 这才是释放vector内存的方法。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	vector<int>().swap(v);
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```

* `shrink_to_fit()`: Requests the container to reduce its `capacity` to fit its `size`. 所以我们可以通过先调用`clear()`再调用`shrink_to_fit()`的方式来释放内存。

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5, 6, 7, 8 };
	cout << v.size() << endl;			// 8
	cout << v.capacity() << endl;		// 8
	v.clear();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 8
	v.shrink_to_fit();
	cout << v.size() << endl;			// 0
	cout << v.capacity() << endl;		// 0
}
```


#### 比较大小

类似Python，逐位比较。

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v1{ 1, 2 };
	vector<int> v2{ 1, 3 };
	vector<int> v3{ 1, 2, 3 };
	vector<int> v4{ 4, 1 };
	cout << (v1 < v2) << endl; // 1
	cout << (v1 < v3) << endl; // 1
	cout << (v2 < v3) << endl; // 0
	cout << (v2 < v4) << endl; // 1
}
```



### 迭代器 (iterator)

#### 迭代器类型

```c++
vector<int>::iterator it;           // 可读写
string::iterator it2;               // 可读写

vector<int>::const_iterator it3;    // 只读，不能写
string::const_iterator it4;         // 只读，不能写
```

* `being()`和`end()`返回的具体类型由对象是否是常量决定。

* `cbegin()` `cend()`返回的一定是`const_iterator`


#### 迭代器运算

* 只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一个位置，就能将其相减，所得结果是两个迭代器的距离。其类型是名为`difference_type`的带符号整型数，可正可负。


#### iterator失效情形

* `erase(it)`后并没由对`it`进行赋值。如下例：明显可以看到使用`erase`删除某一个结点之后，`vector`迭代器虽然还是指向当前位置，而且也引起了元素前挪，但是由于删除结点的迭代器就已经失效，指向删除点后面的元素的迭代器也全部失效，所以不能对当前迭代器进行任何操作；需要对迭代器重新赋值或者接收`erase`它的返回。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2)
			v.erase(it);
		cout << * it << " ";
	}
}
```

* `erase(it)`后`it`移动了多次，导致越界。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		cout << * it << " ";
	}
}
```

解决办法：

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4 };
	for (auto it = v.begin(); it != v.end();)
	{
		if (*it % 2 == 0)
			it = v.erase(it);
		else
			++it;
	}
}
```

* `push_back()`导致`capacity`变化，而`it`并未更新。当插入(push_back)一个元素后，`capacity`的返回值与没有插入元素之前相比有改变，进行了深拷贝，而迭代器所指向的位置已经被析构函数释放所以导致迭代器失效。而当你在不增容的情况下尾插数据并不会导致迭代器失效。`insert`使迭代器失效的与`push_back`类似。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

如果我们预留了足够的`capacity`，那么问题就能解决。

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1);
		cout << * it << endl;
	}
}
```

* `end()`迭代器并未更新

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	v.reserve(500); // IMPORTANT!!!
	vector<int>::iterator end = v.end();
	for (auto it = v.begin(); it != end; ++it)
	{
		if (*it % 2 == 0)
			v.push_back(1); // push_back()导致v.end()发生了改变
		cout << *it << endl;
	}
}
```



* `push_back()`导致无限循环

```c++
#include <iostream>
#include <vector>
using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	for (auto it = v.begin(); it != v.end(); ++it)
	{
		if (*it % 2 == 0)
			v.push_back(0); // 0会导致一直添加0
		cout << * it << endl;
	}
}
```



### 数组 (array)

#### vector vs. array

* creation:
    * vector: sequential container to store elements
    * array: original data structure, based on index concept
* Memory
    * vector: occupy more memory than array
    * array: memory-efficient
* Length
    * vector: length vary
    * array: fixed size length
* Usage
    * vector: frequent insertion and deletion
    * array: frequent element acces
* Resize
    * vector: resize vector is dynamic in nature
    * array: resizing arrays is expensiv
* Structure
    * vector: template class, c++ only construct.
    * array: contiguous memory location
* Indexing
    * vector: non-indexed based stuctrue
    * array: index based with the lowest address as first, and highest address as last
* Access
    * vector: access element is time-consuming although based on a position of element
    * array: access element is constant time operation irrespective of element location

#### 初始化

* 如果在函数内部体内定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。

```c++
#include <iostream>

#include <string>

#include <vector>

using namespace std;

int a1[10];

int main()
{
	cout << a1[0] << endl;	// 0

	int a2[10];
	cout << a2[0] << endl;	// -858993460

	vector<int> v(10);
	cout << v[0] << endl;		// 0
}
```

* 如果对数组显式初始化，并且维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int a1[5] = { 0, 1, 2 }; // 等价于 a1[] = {0, 1, 2, 0, 0}

	string a2[3] = { "hi", "bye" }; // 等价于 a2[] = {"hi", "bye", ""}

	int a3[2] = { 0, 1, 2, 3 }; // ERROR! 初始值太多
}
```

* 不允许用数组拷贝或者赋值

```bash
int a[] = {0, 1, 2};

int a2[] = a; // ERROR!

a2 = a; // ERROR!
```


* size必须是`const`(变量)或者`constexpr`(函数返回值)

```c++
#include <iostream>

#include <string>

using namespace std;

int txt_size()
{
	return 10;
}

int main()
{
	unsigned buf_size = 1024;

	int ia1[buf_size]; // ERROR! buf_size不是constant

	int ia2[4 * 7 - 14]; // 正确

	int ia3[txt_size()]; // 返回值必须是constexpr

	char st[11] = "fundamental"; // 容量小1, 应该为st[12]
}
```


#### 复杂的声明

* 从右向左

* 从内向外

```bash
int *ptrs[10]; // ptrs是含有10个整型指针的数组

int &refs[10]; // ERROR! 不存在引用的数组

int (*Parray)[10] = &arr; // Parray指向一个含有10个整数的数组

int (&arrRef)[10] = arr; // arrRef引用一个含有是个整数的数组

int *(&arry)[10] = ptrs; // arry是数组的引用，该数组含有10个指针

```


#### size类型

* 在使用数组下标的时候，通常将其定义为`size_t`类型。`size_t`是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。在`<cstddef>`中定义了它。


#### 指针与数组

* 在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。

* 当使用数组作为一个`auto`变量的初始值时，推断得到的类型时指针而非数组。

* `decltype(array)`返回的类型还是数组，长度为array的长度。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string nums[] = { "one", "two", "three" };

	string* p = &nums[0]; // p指向nums的第一个元素

	string* p2 = nums; // 等价于 p2 = &nums[0]

	auto p3(nums); // p3是一个string指针，指向nums的第一个元素

	// p3 = 2; // ERROR!

	auto p4(&nums[0]); // 等价于p3

	decltype(nums) nums2 = { "hello" };	// nums2 = {"hello", "", ""}

}
```

#### begin(), end()

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string nums[] = { "one", "two", "three" };

	string* pbeg = begin(nums);

	string* pend = end(nums);
}

```


#### 指针相减

* 两个指针相减的结果的类型是`ptrdiff_t`，也是定义在`<cstddef>`中。



#### 下标（与vector不同）

* 数组用的下标是有符号的，`vector`用的是无符号的。

* 虽然可以处理负值，但是结果地址必须指向原来指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string nums[] = { "one", "two", "three" };

	string* p = &nums[2];

	string k = p[-2]; // 得到nums[0]

}
```


#### 多维数组

* 注意多层`for`循环的使用

* 要使用`for`处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。

* 当使用多维数组的名字时，其会被自动转换成指向数组首元素的指针。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int ia[5][5];

	for (size_t i = 0; i != 5; ++i)
		for (size_t j = 0; j != 5; ++j)
			ia[i][j] = i * 5 + j;


	size_t cnt = 0;
	for (auto& row : ia)
		for (auto& col : row)
		{
			col = cnt;
			++cnt;
		}


	// 声明成了引用类型，为了避免数组被自动转成指针

	for (const auto& row : ia)		
		for (auto col : row)
			cout << col << endl;


	// ERROR! row 的类型是int*, 无法遍历
	for (auto row : ia)
		for (auto col : row)
			cout << col << endl;
}
```

```c++

#include <iostream>

#include <string>

using namespace std;

int main()
{
	int ia[3][4];

	int(*p)[4] = ia; //	p是指向含有4个整数的数组

	p = &ia[2];		 // p指向ia的尾元素

}

```















### 表达式

#### 左值，右值

* 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

* 左值是变量的地址，右值是变量存储的内容。变量本质即存储空间的名称，编译后变为对应地址。

* 左值就是有名字的变量（对象），可以被赋值，可以在多条语句中使用，而右值呢，就是临时变量（对象），没有名字，只能在一条语句中出现，不能被赋值。

* 左值引用

```c++
int a = 3;
int & ref_a = a; //指针是一种数据类型，而引用不是。当其用作函数传参时，传递的就是变量的左值即地址。
```

* 右值引用
    * 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率；
    * 能够更简洁明确地定义泛型函数；
    * 右值引用形式：类型 && a= 被引用的对象。与左值的区别在于：右值是临时变量，如函数返回值，且不变。
    * 右值引用可以理解为右值的引用，右值初始化后临时变量消失。


#### 求值顺序

```c++
#include <iostream>

#include <vector>

using namespace std;

int f1()
{
	return 1;
}

int f2()
{
	return 2;
}

int main()
{
	int i = f1() * f2(); // 我们无法知道f1()先运行还是f2()先运行

	int n = 0;
	cout << n << " " << ++n << endl; // UNDEFINED, 但可以输出，例如 1 1
}
```

```c++
f() + g() * h() + j(); // 函数的调用顺序没有明确规定
```

#### 算数运算

* 小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转变成同一类型。

* (C++ 11) 商一律向0取整。`(-m)/n`和`m/(-n)`等价于`-(m/n)`。`m %(-n)`等于`m%n`。`(-m)%n`等于`-(m%n)`。

```c++
bool b = true;
bool b2 = -b; // b2仍然是true!!!
```


#### 逻辑与关系运算符

* `&&`和`||`采取短路求值策略 (short-circuit evaluation)。
    * 对于`&&`，当且仅当左侧运算对象为真时才对右侧运算对象求值。
    * 对于`||`，当且仅当左侧运算对象为假时才对右侧运算对象求值。

* `==`和`!=`会先计算左右两侧的值，然后再进行比较。哪边的值先算是未定义的。


```c++
#include <iostream>

#include <vector>

using namespace std;

int f1()
{
	return 1;
}

int f2()
{
	return 2;
}

int main()
{
	const char* cp = "Hello world";
	if (cp && *cp)
	{ // 这里会输出

		cout << cp << endl; // Hello world

		cout << * cp << endl; // H
	}
	else
		cout << "NOT OK" << endl;


	int i = 0, j = 20, k = 21;
	cout << (i != j < k) << endl; // 等价于 i != (j < k)

}
```


#### 赋值运算符

* 赋值运算符的优先级低于关系运算符的优先级。

```c++
#include <iostream>

using namespace std;

int main()
{
	int i;
	cout << (i = 2 < 3) << endl;	// 1, 等价于 i = (2 < 3)

	cout << i << endl;				// 1

	cout << ((i = 2) < 3) << endl;	// 1

    cout << i << endl;				// 2

}

```

```c++
#include <iostream>

using namespace std;

int getPtr()
{
	return 20;
}

int main()
{
	int p = 10;
	p = getPtr() != 20; // 等价于 p = (getPtr() != 20)

	cout << "p: " << p << endl;	// p: 0
}

```


#### 递增运算符

* 前置版本的递增运算符`++i`避免了不必要的工作，它把值加1后直接返回改变了的运算对象。

* 后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。

* 后置递增运算符的优先级高于解引用运算符。

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3 };
	auto pbeg = v.begin();
	while (pbeg != v.end() && *pbeg >= 0)
		cout << *pbeg++ << endl;
        // 相当于*(pbeg++)，pbeg的值加1，然后返回初始值（加1之前），最后解引用
    	// 1 2 3

}
```

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> v{ 1, 2, 3 };
	auto pbeg = v.begin();
	while (pbeg != v.end() && *pbeg >= 0)
		cout << *++pbeg << endl;
		// 2, 3, 最后ERROR!!!

}
```

```c++
vec[ival++] <= vec[ival]; // undefined, 我们不知道哪边会先算
```



#### 成员访问运算符

* 解引用运算符的优先级低于点运算符，所以执行解引用运算的子表达式两端必须加上括号。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	string s1 = "a string";
	string* p = &s1;
	auto n = s1.size();	// 运行string对象s1的size成员

	n = (*p).size(); // 正确

    n = p->size();	// 正确

    n = *p.size(); // ERROR!!!
}

```


#### 移位运算符

* 移位运算符比算数运算符低，但比关系运算符，赋值运算符和条件运算符的优先级高。

```bash
cout << 42 + 10; // right
cout << (10 < 42)； // right
cout  << 10 < 42; // ERROR!!!
```


#### sizeof()

* sizeof是运算符，不是函数，因此不把它所要求得长度的对象叫做参数，习惯上叫做操作数。

* 基础数据类型

```c++
#include <iostream>

using namespace std;

int main()
{
    cout << sizeof(bool) << endl;           // 1
	cout << sizeof(char) << endl;			// 1
	cout << sizeof(short) << endl;			// 2
	cout << sizeof(int) << endl;			// 4
	cout << sizeof(long) << endl;			// 4
	cout << sizeof(long long) << endl;		// 8
	cout << sizeof(float) << endl;          // 4
	cout << sizeof(double) << endl;			// 8
}
```

* 指针

```c++
#include <iostream>

using namespace std;

int main()
{
	cout << sizeof(char*) << endl;			// 8 (x64); 4 (x86)
	cout << sizeof(long long*) << endl;		// 8 (x64); 4 (x86)

	// cout << sizeof(void) << endl;		// ERROR!!!
	cout << sizeof(void*) << endl;			// 8 (x64); 4 (x86)}
}
```

* 数组

```c++
#include <iostream>

using namespace std;

int main()
{
	int a[] = { 1, 2, 3 };
	cout << sizeof(a) << endl;					// 12
	cout << sizeof(a) / sizeof(a[0]) << endl;	// 3

	int* b = a;
	cout << sizeof(b) << endl;					// 4 (x86); 8 (x64). 指针是恒定大小

	int (&c)[3] = a;							// 这是对数组的引用
	cout << sizeof(c) << endl;					// 12

	int d[5] = { 1, 2, 3 };
	cout << sizeof(d) << endl;					// 20
	cout << sizeof(d) / sizeof(d[0]) << endl;	// 5
}
```

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

int main()
{
	char a[] = "abcdef";
	cout << sizeof(a) << endl;	// 7

	char b[] = { 'a', 'b', 'c', 'd', 'e', 'f' };
	cout << sizeof(b) << endl; // 6

	string c("abcdef");
	cout << sizeof(c) << endl; // 28, 这里不代表字符串的长度，而是string类的大小, 在不同编译器上是恒定的

	char d[] = { 'a', '\0', 'c', 'd', 'e', 'f' };
	cout << sizeof(d) << endl; // 6
	cout << strlen(d) << endl; // 1
}
```

* 表达式: `sizeof()`求得表达式的计算结果的类型大小

```c++
#include <iostream>

using namespace std;

int main()
{
	char c = '1';
	int n = 1;
	cout << sizeof(c + n) << endl;		// 4
	cout << sizeof(c += n) << endl;		// 1
}
```

* 函数：求得返回类型的大小，但是不执行函数体！

```c++
#include <iostream>

using namespace std;

int add(int& a, int& b)
{
	return a += b;
}

int main()
{
	int a = 1;
	int b = 1;
	cout << sizeof(add(a, b)) << endl;		// 4
	cout << a << endl;						// 1
}
```


* `union`
    * union的大小取决于它所有的成员中，占用空间最大的一个成员的大小，因union中的所有成员起始地址都是一样的。
    * 复合数据类型，如`union`，`struct`，`class`的对齐方式为成员中对齐方式最大的成员的对齐方式。
    * 通过程序可以改变编译器对界，使用`#pragma pack(x)`宏可以改变编译器的对界方式，默认是8。
    * C++固有类型的对界取编译器对界方式与自身大小中较小的一个。例如，指定编译器按2对界，`int`类型的大小是4，则`int`的对界为2和4中较小的2。

```c++
#include <iostream>

using namespace std;

union u1
{
	char a;
	int b;
};

union u2
{
	char a[13];
	int b;
};

union u3
{
	char a[13];
	char b;
};

int main()
{
	cout << sizeof(u1) << endl;	// 4, 以4对齐
	cout << sizeof(u2) << endl;	// 16, 以4对齐, 4 * 4 = 16， 这是离13最近的对界。
	cout << sizeof(u3) << endl;	// 13, 以1对齐
}
```

```c++
#pragma pack(2)

#include <iostream>

using namespace std;

union u1
{
	char a;
	int b;
};

union u2
{
	char a[13];
	int b;
};

union u3
{
	char a[13];
	char b;
};

int main()
{
	cout << sizeof(u1) << endl;	// 4, 以2对齐
	cout << sizeof(u2) << endl;	// 14, 以2对齐, 2 * 7 = 14， 这是离13最近的对界。
	cout << sizeof(u3) << endl;	// 13, 以1对齐
}
```


* `struct`: 这里计算sizeof既要考虑数据对齐(整体上最大元素的size对齐，满足之后还要满足struct中其他元素的对齐)，又要考虑最节约存储空间的原则。

```c++
#include <iostream>

using namespace std;

struct s0
{

};

struct s1
{
	char a;
	double b;
	int c;
	char d;
};

struct s2
{
	char a;
	char d;
	int c;
	double b;
};

int main()
{
	// 空类型必须在内存中占有一定空间，否则无法使用那些实例。至于占用多少内存，由编译器决定
	cout << sizeof(s0) << endl; // 1

	// 以8对齐
	// 先放a, 从0开始放，下一个空闲起始位为1
	// 但是由于b占8位，要放到8的对界上，所以从8开始放，下一个空闲起始位为16
	// c占4位，下一个空闲起始位为20
	// d占1位，总共放了21位，但大小要在8的倍数处结束，所以24
	cout << sizeof(s1) << endl;	// 24

	// 以8对齐
	// 先放a, 从0开始放，下一个空闲起始位为1
	// 但是由于d占1位，下一个空闲起始位为2
	// c占4位，下一个空闲起始位为6
	// d占8位，要放到8的对界上，所以从8开始放，总共大小为16
	cout << sizeof(s2) << endl;	// 16
}
```

* 嵌套`struct`

```c++
#include <iostream>

using namespace std;

struct s1
{
	char a[8];
};

struct s2
{
	double a;
};

struct s3
{
	s1 s;
	char a;
};

struct s4
{
	s2 s;
	char a;
};

int main()
{
	cout << sizeof(s1) << endl;	// 8
	cout << sizeof(s2) << endl; // 8

	cout << sizeof(s3) << endl; // 9, 因为它的对齐方式还是1
	cout << sizeof(s4) << endl; // 16，因为它的对齐方式是8
}
```

* `class`无虚函数：成员函数(除了虚函数)不会分配空间，所以`sizeof`时只计算数据成员的大小，计算方法类似`struct`。

```c++
#include <iostream>

using namespace std;

// 1
class c0
{

};

// 16
class c1
{
private:
	char a;
	double b;
public:
};

// 16
class c2
{
private:
	char a;
	double b;
public:
	int foo() { return 1; }
};

int main()
{
	cout << sizeof(c0) << endl; // 1
	cout << sizeof(c1) << endl;	// 16
	cout << sizeof(c2) << endl;	// 16
}
```

* `class`包含虚函数（不管几个）：单继承情况下，只要`class`中存在`virtual`函数（不管几个虚函数），编译器在编译时就会自动插入一个指向虚函数表的指针vptr(大小为4字节). 为了效率问题，编译器(gcc 和 微软)一般会把虚指针放在类的内存空间的最前面的位置，不管虚函数声明的位置。

```c++
#include <iostream>

using namespace std;

// 8
class c3
{
public:
	virtual void foo() { }
	char a;
};


// 8
class c4
{
public:
	virtual void foo() { }
	int a;
};

// 12
class c5
{
public:
	virtual void foo() { }
	char a;
	int b;
};

// 8
class c6
{
public:
	virtual void foo() { }
	char a;
	char b;
	char c;
	char d;
};


// 8
class c7
{
public:
	short a;
	virtual void foo() { }
	char b;
};

// 8
class c8
{
public:
	short a;
	char b;
	virtual void foo() { }
};

// 24, NO IDEA WHY THIS IS 24???
class c9
{
public:
	double a;
	char b;
	virtual void foo() { }
};

// 24
class c10
{
public:
	char b;
	double a;
	virtual void foo() { }
};

int main()
{
	cout << sizeof(c3) << endl;	// 8
	cout << sizeof(c4) << endl;	// 8
	cout << sizeof(c5) << endl;	// 12, 以4对齐
	cout << sizeof(c6) << endl;	// 8, 以4对齐
	cout << sizeof(c7) << endl;	// 8, 以4对齐
	cout << sizeof(c8) << endl;	// 8, 以4对齐
	cout << sizeof(c9) << endl;	// 24, 以8对齐
	cout << sizeof(c10) << endl;// 24, 以8对齐
}
```

* `class`包含`static`：因为`static`成员是分配在全局区为类的所有对象共享（VC编译器可能为了方便将其放入文字常量表), `sizeof`时不应该计入`static`成员。

```c++
#include <iostream>

using namespace std;

// 16
class c1
{
private:
	char a;
	double b;
public:
};

// 16
class c2
{
private:
	char a;
	double b;
	static int c;
public:
};

int main()
{
	cout << sizeof(c1) << endl; // 16
	cout << sizeof(c2) << endl;	// 16
}
```

* `class`单继承：类似嵌套`struct`，注意以谁对齐

```c++
#include <iostream>

using namespace std;

// 13
class c1
{
private:
	char a[13];
public:
};

// 14
class c2 : public c1
{
private:
	char b;
};

// 20
class c3 : public c1
{
private:
	int c;
};

int main()
{
	cout << sizeof(c1) << endl; // 13
	cout << sizeof(c2) << endl;	// 14
	cout << sizeof(c3) << endl;	// 20, a占据13位，c从地址16开始，所以一共20
}
```

* `class`多继承

```c++
#include <iostream>

using namespace std;

// 13
class c1
{
private:
	char a[13];
public:
};

// 1
class c2
{
private:
	char b;
};

// 20
class c3 : public c1, c2
{
private:
	int c;
};

int main()
{
	cout << sizeof(c1) << endl; // 13
	cout << sizeof(c2) << endl;	// 1
	cout << sizeof(c3) << endl;	// 20, VS把c1, c2当作整体来看待，总共14，然后从16开始，总共20
}
```


#### 类型转换

* 何时发生隐式类型转换？
    * 整型提升 (integral promotion): 在大多数表达式中，比`int`类型小的整型值首先提升为较大的整数类型。
    * 在条件中，非布尔值转换成布尔值。
    * 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
    * 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型。
    * 函数调用时也会发生类型转换。

* 整型提升
    * `bool`, `char`, `signed char`, `unsigned char`, `short`, `unsgined short` --> `int`
    * `wchar_t`, `char16_t`, `char32_t` --> `int`, `unsigned int`, `long`, `unsigned long`, `long long`, `unsigned long long`中的最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。


* 如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。

* 首先，执行整型提升，如果结果的类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象类型要么都是带符号的，要么都是无符号的，则小类型的运算对象转换成较大的类型。

* 如果一个运算对象是无符号类型，另一个是有符号类型。
    * 如果无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。
    * 如果带符号类型大于无符号类型，那么转换的结果依赖于机器。
        * 如果无符号类型的所有值都能存在该带符号类型中，则无符号类型转换成带符号类型。
        * 如果不能，带符号类型转换成无符号类型。


* 强制类型转换
    * `statci_cast`: 任何具有明确定义的类型转换，只要不包含`底层const`，都可以使用`static_cast`。
    * `dynamic_cast`
    * `const_cast`
    * `reinterpret_cast`


* `statci_cast`: 任何具有明确定义的类型转换，只要不包含`底层const`，都可以使用`static_cast`。
    * 把一个较大的算术类型赋值给较小类型（精度损失警告信息就会被关闭）
    * 找回存在于`void*`中的值（我们应确保指针的值保持不变，确保转换后的类型就是指针所指的类型，否则会有`Undefined`的后果）

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int i = 3;
	int j = 2;
	double slope = static_cast<double>(j) / i;
	cout << slope << endl;

	void* p = &slope;
	double* dp = static_cast<double*>(p);
	cout << *dp << endl;
}

```

* `const_cast`: 只能改变运算对象的`底层const`，不能改变类型。
    * 将常量对象转换成非常量对象，但是执行写操作就会产生`Undefined`的后果
    * 将非常量转换成常量，运用于函数重载。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	const char* pc;
	char* p = const_cast<char*>(pc); // 正确：但是通过p写值是未定义的行为
}
```

```c++
#include <iostream>
#include <string>

using namespace std;

const string& shorterString(const string& s1, const string& s2)
{
	return s1.size() <= s2.size() ? s1 : s2;
}

string& shorterString(string& s1, string& s2)
{
	auto& r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
	return const_cast<string&>(r);
}

int main()
{
	string s1 = "Hello";
	string s2 = "Tong";
	string& res = shorterString(s1, s2);
	res = "April";
	cout << "res: " << res << endl;	// April

	cout << "s1: " << s1 << endl;	// Hello

    cout << "s2: " << s2 << endl;	// April
}

```

* `reinterpret_cast`: 通常为运算对象的位模式提供较低层次上的重新解释。

```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	int* ip;
	char* pc = reinterpret_cast<char*>(ip);
	string str(pc); // 危险!!! 可能会有异常的行为

}

```










### 语句

#### 条件语句

* 悬垂else (dangling else): `else`离它最近的尚未匹配的`if`匹配。

* `switch`有多个case时

```c++
#include <iostream>

using namespace std;

int main()
{
	unsigned evenCnt = 0, oddCnt = 0;
	int digit = 5;

	switch (digit)
	{
	case 1: case 3: case 5: case 7: case 9:
		oddCnt++;
		break;

	case 2: case 4: case 6: case 8: case 10:
		evenCnt++;
		break;
	}
}

```

* `switch`的`case label`必须是整形常量表达式。


```c++
#include <iostream>

#include <string>

using namespace std;

int main()
{
	double d = 3.14;

	// d 不能用在switch里

	switch (d) {
		/* * /
	}
}
```


```c++
#include <iostream>

using namespace std;

int main()
{
	constexpr unsigned ival = 512, jval = 1024, kval = 4096; // 注意!!! 这里使用了constexpr
	unsigned bufsize;
	unsigned swt = 512;
	switch (swt) {
	case ival:
		bufsize = ival * sizeof(int);
		break;
	case jval:
		bufsize = jval * sizeof(int);
		break;
	case kval:
		bufsize = kval * sizeof(int);
		break;
	}
}

```


#### 跳转语句

* `goto`跳转到同一函数内的另一条语句。注意：不能将程序的控制权从变量的作用域之外转移到作用域之内。

```c++
#include <iostream>

using namespace std;

int main()
{
	goto end;			// ERROR!
	int ix = 10;
end:
	ix = 42;
}

```

```c++
#include <iostream>

using namespace std;

int main()
{
begin:
	int sz = 10;
	goto begin;			// OK. 因为每次都会生成一个新的sz
}

```


#### 异常处理

* 组成部分
    * `throw`表达式，异常检测部分使用`throw`表达式来表示它遇到了无法处理的问题。`throw`引发 (raise) 了异常。
    * `try`语句块，异常处理部分使用`try`语句块处理异常。`try`语句块中代码抛出的异常通常会被某个`catch`子句处理。因为`catch`子句“处理”异常，所以它们也被称作 __异常处理代码 (exception handler)__。
    * 一套异常类 (exception class)，用于在`throw`表达式和相关的`catch`子句之间传递异常的具体信息。

* 异常类的头文件
    * `exception`头文件定义了最通用的异常类`exception`。它只报告异常的发生，不提供任何额外信息。
    * `stdexcept`头文件定义了几种常用的异常类。
    * `new`头文件定义了`bad_alloc`异常类型。
    * `type_info`头文件定义了`bad_cast`异常类型。

* `stdexcept`
    * `exception`最常见的问题
    * `run_time_error`只有在运行时才能检测出的问题
    * `range_error`运行时错误：生成的结果超出了有意义的值域范围
    * `overflow_error`运行时错误：计算上溢
    * `underflow_error`运行时错误：计算下溢
    * `logic_error`程序逻辑错误
    * `domain_error`逻辑错误：参数对应的结果值不存在
    * `invalid_argument`逻辑错误：无效参数
    * `length_error`逻辑错误：试图创建一个超出该类型最大长度的对象
    * `out_of_range`逻辑错误：使用一个超出的有效范围的值

* 程序在遇到抛出异常的代码前，其执行路径可能已经经过了多个`try`语句块，一个`try`语句块可能调用了包含另一个`try`语句块的函数。寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的`catch`子句，终止该函数，并在调用该函数的函数中继续寻找。以此类推，直到找到适当类型的`catch`子句为止。如果最终还是没能找到任何匹配的`catch`子句，程序转到名为`terminate`的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。

* 如果一段程序没有`try`语句块且发生了异常，系统会调用`terminate`函数并终止当前程序的执行。

```c++
#include <iostream>

#include <stdexcept>

using namespace std;

int main()
{
	int a, b;
	cin >> a >> b;
	try
	{
		if (b == 0) throw runtime_error("Divide by 0.");
		cout << a / b << endl;
	}
	catch (runtime_error err)
	{
		cout << err.what() << endl;
	}
}
```




### 函数

#### Basics

* 局部静态对象 (local static object)
    * 在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止时才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。
    * 如果局部静态对象没有显示的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。

```c++
#include <iostream>

using namespace std;

size_t count_calls()
{
	static size_t ctr = 0;
	return ++ctr;
}

int main()
{
	for (size_t i = 0; i != 10; ++i)
		cout << count_calls() << endl;
	return 0;
}
```


* 相同名字的函数必须有具有明显区别的函数形参列表。

```c++
#include <iostream>

using namespace std;

void fcn(const int i)
{
	return;
}

void fcn(int i)	// ERROR! 因为顶层const被忽略掉了，所以传入这两个fcn的参数可以完全一样
{
	return;
}



int main()
{
	fcn(10);
	return 0;
}
```


* 尽量使用常量引用，因为我们不能把`const`对象，字面值或者需要类型转换的对象传递给普通的引用形参。


#### 数组形参

* 声明方式
    * `void print(const int*);`
    * `void print(const int[]);`
    * `void print(const int[10]);` 这里为维度表示我们期望数组含有多少元素，实际不一定。

```bash
int i = 0, j[2] = {0, 1};
print(&i); // OK
print(j); // OK
```

* 管理指针形参
    * 使用标记指定数组长度。要求数组本身包含一个结束标记，例如C风格字符串。
    * 使用标准库规范，例如`begin(j)`, `end(j)`。
    * 显示传递一个表示数组大小的形参。

```c++
#include <iostream>

using namespace std;

void print(const char* cp)
{
	if (cp)
		while (*cp)
			cout << * cp++;
	cout << endl;
}

void print(const int* beg, const int* end)
{
	while (beg != end)
		cout << * beg++ << endl;
}

void print(const int ia[], size_t size)
{
	for (size_t i = 0; i != size; ++i)
		cout << ia[i] << endl;
}

int main()
{
	print("Hello Tong!");

	int j[2] = { 0, 1 };
	print(begin(j), end(j));

	print(j, end(j) - begin(j));
}
```

* 数组的引用形参 （必须声明长度）

```c++
#include <iostream>

using namespace std;

void print(int(&arr)[10])
{
	for (auto elem : arr)
		cout << elem << endl;
}

int main()
{
	int i = 0;
	int j[2] = { 0, 1 };
	int k[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	print(&i);		// ERROR
	print(j);		// ERROR, 没有10个整数
	print(k);		// OK
}
```

* 传递多维数组

```c++
void print(int (*matrix)[10], int rowSize) {}
void print(int matrix[][10], int rowSize) {}
```



#### `initializer_list`

* 如果函数的实参类型数量未知但是全部实参的类型都相同，我们可以使用`initializer_list`类型的形参。

* `initializer_list`对象中的元素永远是常量值，我们无法改变`initializer_list`对象中元素的值。

```c++
#include <iostream>
#include <initializer_list>

using namespace std;

void error_msg(initializer_list<string> il)
{
	// 注意!!! auto后面不能加&, 因为il.begin()不是左值，所以没法引用

	for (auto beg = il.begin(); beg != il.end(); ++beg)
		cout << * beg << " ";
	cout << endl;
}

int main()
{
	error_msg({ "functionX", "expected: 10", "actual: 11" });
}
```

#### 返回值

* 什么情况返回常量的引用无效？

```c++
#include <iostream>

using namespace std;

const string& getString()
{
	string s("Hello");
	if (s.size() > 2)
		return s;		// ERROR! 返回局部对象的引用
	else
		return "Tong";	// ERROR! "Tong"是一个局部临时量
}

int main()
{
	auto a = getString();
}

```

```c++
#include <iostream>

using namespace std;

// Legal program

int& get(int* arry, int index)
{
	return arry[index];
}

int main()
{
	int ia[10];
	for (int i = 0; i != 10; ++i)
    	get(ia, i) = i;
	for (auto i : ia)
		cout << i << " ";
	cout << endl;
}
```

* 返回数组指针

```c++
// arrT是个类型别名，它表示含有10个整数的数组

typedef int arrT[10];
using arrT = int[10];


// 返回一个指向含有10个整数的数组的指针

arrT* func(int i);
int (*func(int i))[10];

auto func(int i) -> int(*)[10]; // C++ 11

decltype(odd)* func(int i);
```

```c++
#include <iostream>

using namespace std;

int odd[] = { 1, 3, 5, 7, 9 };
int even[] = { 0, 2, 4, 6, 8 };

// 注意：要想表示arrPtr返回指针还必须在函数声明时加一个*符号

decltype(odd)* arrPtr(int i)       
{
	return (i % 2) ? &odd : &even; // 返回一个指向数组的指针

}

int main()
{
	decltype(5);
}
```


#### 函数重载

* `顶层const`不影响传入函数的对象。一个拥有`顶层const`的形参无法和另一个没有`顶层const`的形参区分开来。

```c++
Record lookup(Phone);
Record lookup(const Phone); // 重复声明了

Record lookup(Phone*);
Record lookup(Phone* const); // 重复声明了
```

* 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的`const`是底层的。
    * 我们只能把`const`对象 (或者指向`const`的指针)传递给`const`形参。
    * 但是非常量可以转换成`const`。
    * 当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。

```c++
Record lookup(Phone&);
Record lookup(const Phone&); // 新函数

Record lookup(Phone*);
Record lookup(const Phone*); // 新函数
```


* 调用重载函数的三个结果
    * 编译器找到一个与实参 __最佳匹配 (best match)__ 的函数，并生成调用该函数的代码。
    * 找不到任何一个函数与调用的实参匹配，此时编译器发出 __无匹配 (no match)__ 的错误信息。
    * 有多余一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也会发生错误，称为 __二义性调用 (ambiguous call)__ 。


* 不允许两个函数除了返回类型之外的其他要素都相同。但是，如果返回类型不同，而且形参也不同，那也没问题。

```c++
#include <iostream>
#include <string>

using namespace std;

int* reset(int* i) {
	return i;
}

// OK

double* reset(double* d)
{
	return d;
}

int main()
{
	double d = 10;
	double* p = reset(&d);
}
```


#### 默认实参

* 一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。

* 函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。

* 局部变量不能作为默认实参。

* 只要表达式的类型能转换成形参所需的类型，该表达式就能作为默认实参。



#### 内联函数

* 将函数指定为内联函数 (inline)，通常就是将它在每个调用点上“内联地”展开。

* 内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。

* 一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。

* `constexpr`函数被隐式地指定为内联函数。

* `constexpr`函数不一定返回常量表达式。

```c++
#include <iostream>
#include <string>

using namespace std;

constexpr int new_sz() { return 42; }

constexpr int foo = new_sz(); // OK

constexpr size_t scale(size_t cnt) { return new_sz() * cnt; } // 如果cnt是常量表达式，那么scale(cnt)也是

int main()
{
	int arr[scale(2)]; // OK

	int i = 2;
	int a2[scale(i)]; // ERROR!!! i不是常量表达式

}
```


#### 调试帮助

* `assert`是一种 __预处理宏 (preprocessor marco)__ 。所谓预处理宏其实是一个预处理变量，行为类似内联函数。

* `assert`在`<cassert>`头文件里。应该使用`assert`而不是`std::assert`。

* `assert`的行为依赖于一个名为`NDEBUG`的预处理变量的状态。如果定义了`NDEBUG`，则`assert`什么也不做。默认状态下没有定义`NDEBUG`，此时`assert`将执行运行时检查。

* C++编译器定义了`_ _func_ _` （输出当前调试的函数的名字）。

* 预处理器定义了
    * `_ _FILE_ _` 存放文件名的字符串字面值
    * `_ _LINE_ _` 存放当前行号的整型字面值
    * `_ _TIME_ _` 存放文件编译时间的字符串字面值
    * `_ _DATE_ _` 存放文件编译日期的字符串字面值



#### 函数匹配

* 函数匹配第一步是选定本次调用对应的重载函数集，集合中的函数称为 __候选函数 (candidate function)__。
    * 候选函数有两个特征：1）与被调用的函数同名，2）其声明在调用点可见。

* 第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为 __可行函数 (viable function)__。
    * 可行函数有两个特征：1）其形参数量与本次调用提供的实参数量相等，2）每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。

* 第三步是从可行函数中选择与本次调用最匹配的函数。 这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。
    * 基本思想是，实参类型与形参类型越接近，它们匹配得越好。

* 如果有且只有一个函数满足下列条件，则匹配成功：
    * 该函数的实参的匹配都不劣于其他可行函数需要的匹配。
    * 至少有一个实参的匹配优于其他可行函数提供的匹配。


* 如果函数含有默认实参，则我们在调用该函数时传入的实参数量可能少于它实际使用的实参数量。

```c++
#include <iostream>
#include <string>

using namespace std;

void f()
{
	cout << "I am f()" << endl;
}

void f(int i)
{
	cout << "I am f(int)" << endl;
}

void f(int a, int b)
{
	cout << "I am f(int, int)" << endl;
}

void f(double a, double b = 3.14)
{
	cout << "I am f(double, double)" << endl;
}

int main()
{
	f(5.6);		// I am f(double, double)

	f(42);		// I am f(int)

	f(42, 0);   // I am f(int, int)

	f(2.56, 3.5); // I am f(double, double)

	f(2.5, 42); // ERROR!

}
```

* 为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成5个等级
    1. 精确匹配
        * 实参和形参类型相同。
        * 实参从数组类型或函数类型转换成对应的指针类型。
        * 向实参添加`顶层const`或者从实参中删除`顶层const`。
    2. 通过`const`转换实现的匹配。
    3. 通过类型提升实现的匹配。（小整数型一般都会提升到`int`类型或者更大的整数类型）
    4. 通过算数类型转换实现的匹配。（所有算数类型转换的级别都一样）
    5. 通过类类型转换实现的匹配。

```c++
#include <iostream>

using namespace std;

void f(short i)
{
	cout << "I am f(short)" << endl;
}

void f(int i)
{
	cout << "I am f(int)" << endl;
}

void f(long i)
{
	cout << "I am f(long)" << endl;
}

void f(float i)
{
	cout << "I am f(float)" << endl;
}

int main()
{
	f('a');	// f(int), 因为char --> int

	f(3.14); // ERROR! 二义性调用，算术类型转换成long和float都有可能

}
```

* 如果重载函数的区别在于它们的引用类型的形参是否引用了`const`，或者指针类型的形参是否指向`const`，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。

```c++
#include <iostream>

using namespace std;

void f(int& i)
{
	cout << "I am f(int&)" << endl;
}

void f(const int& i)
{
	cout << "I am f(const int&)" << endl;
}

int main()
{
	f('a');	// I am f(const int&)

	const int a = 5;
	f(a);	// I am f(const int&)

	int b = 5;
	f(b);	// I am f(int&)

}
```



#### 函数指针

* 声明

```c++
#include <iostream>

using namespace std;

bool lengthCompare(const string& a, const string& b)
{
	return a.length() < b.length();
}

int main()
{
	bool (*pf)(const string&, const string&); // pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类型

	bool* f(const string&, const string&); // 声明一个名为f的函数，该函数返回bool*

	pf = lengthCompare; // OK, &可加可不加

	pf = &lengthCompare; // OK

	bool b1 = pf("hello", "goodbye"); // OK, *可加可不加

	bool b2 = (*pf)("hello", "goodbye"); // OK

	bool b3 = lengthCompare("hello", "goodbye"); // OK

}
```

* 函数指针形参

```c++
#include <iostream>

using namespace std;

bool lengthCompare(const string& a, const string& b)
{
	return a.length() >= b.length();
}

// 等价于 void getLonger(const string& a, const string& b, bool (*pf)(const string&, const string&))
void getLonger(const string& a, const string& b, bool pf(const string&, const string&))
{
	if (pf(a, b))
		cout << a + " is longer" << endl;
	else
		cout << b + " is longer" << endl;
}

int main()
{
	getLonger("Tong", "Yihui", lengthCompare); // 自动将函数lengthCompare转换成指向该函数的指针
}
```

* 声明函数类型

```c++
// Func, Func2是函数类型

typedef bool Func(const string&, const string&);
typedef decltype(lengthCompare) Func2;

// FuncP, FuncP2是指向函数的指针

typedef bool (*FuncP)(const string&, const string&);
typedef decltype(lengthCompare)* FuncP2;
```

* 返回指向函数的指针 （我们必须把返回类型写成指针形式）

```c++
using F = int(int*, int); // F是函数类型，不是指针

using PF = int(*)(int*, int); // PF是指针类型

PF f1(int); // OK

F f1(int);  // ERROR： F是函数，我们不能返回函数

F* f1(int); // OK

auto f1(int) - > int (*)(int*, int); // OK

decltype(f1)* f2(int); // decltype返回函数类型而非指针类型。我们必须加上一个*。
```

```c++
#include <iostream>

#include <vector>

using namespace std;

int add(int a, int b)
{
	return a + b;
}

int sub(int a, int b)
{
	return a - b;
}

int mul(int a, int b)
{
	return a * b;
}

int divide(int a, int b)
{
	return a / b;
}


int main()
{
	vector<int(*)(int, int)> v;

	v.push_back(add);
	v.push_back(sub);
	v.push_back(mul);
	v.push_back(divide);
	cout << v[0](5, 3) << endl;
	cout << v[1](5, 3) << endl;
	cout << v[2](5, 3) << endl;
	cout << v[3](5, 3) << endl;
}
```


#### Print last K lines

```c++
#include <iostream>
#include <fstream>
#include <algorithm>
#include <string>

using namespace std;

void printLast10Lines(char* fileName)
{
	const int K = 10;
	ifstream file(fileName);
	string L[K];
	int size = 0;

	/* read file line by line into circular array */
	/* peek() so an EOF following a line ending is not considered a separate line */
	while (file.peek() != EOF)
	{
		getline(file, L[size % K]);
		++size;
	}

	/* compute start of circular array, and the size of it*/
	int start = size > K ? (size % K) : 0;
	int count = min(K, size);

	/* print elements int the order they were read * /
	for (int i = 0; i < count; ++i)
		cout << L[(start + i) % K] << endl;
}

int main()
{
	return 0;
}
```


#### Reverse String

```c++
#include <iostream>
#include <algorithm> // swap
#include <string>

using namespace std;

void reverse(string& s)
{
	if (s.size() == 0) return;
	int start = 0;
	int end = s.size() - 1;
	while (start < end)
		swap(s[start++], s[end--]);
}

int main()
{
	string s = "Tong";
	reverse(s);
	cout << s << endl;
	return 0;
}
```


#### Copy Node

编写方法，传入参数为指向`Node`结构的指针，返回传入数据结构的完整拷贝。其中，`Node`数据结构含有两个指向其他`Node`的指针。

```c++
#include <iostream>
#include <map>

using namespace std;

struct Node
{
	Node* ptr1;
	Node* ptr2;
};

typedef map<Node*, Node*> NodeMap;

Node* copy_recursive(Node* cur, NodeMap& node_map)
{
	if (!cur) return nullptr;

	NodeMap::iterator i = node_map.find(cur);
	if (i != node_map.end()) return i->second; // we have been here before, return the copy

	Node* node = new Node;
	node_map[cur] = node; // map current before traversing links

	node->ptr1 = copy_recursive(cur->ptr1, node_map);
	node->ptr2 = copy_recursive(cur->ptr2, node_map);
	return node;
}

Node* copy_structure(Node* root)
{
	NodeMap node_map;	// we will need an empty map

	return copy_recursive(root, node_map);
}


int main()
{

	return 0;
}
```































### 类

#### Basics

* 类的基本思想是 __数据抽象 (data abstraction)__ 和 __封装 (encapsulation)__。
    * 数据抽象是一种依赖于 __接口 (interface)__ 和 __实现 (implementation)__ 的分离的编程技术。
    * 类的接口包括用户所能执行的操作；
    * 类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。
    * 封装实现了类的接口和实现的分离。类的用户只能使用接口而无法访问实现部分。

* 类有两项基本能力：一是数据抽象，即定义数据成员和函数成员的能力；二是封装，即保护类的成员不被随意访问的能力。通过将类的实现细节设为`private`，我们就能完成类的封装。

* 类要想实现数据抽象和封装，需要首先定义一个 __抽象数据类型 (abstract data type)__。


#### 定义抽象数据类型

* 定义在类内部的函数是隐式的`inline`函数。

* 成员函数通过一个名为`this`的额外的隐式参数来访问调用它的那个对象。`this`是一个常量指针，我们不允许改变`this`中保存的地址。默认情况下，`this`的类型是指向类类型非常量版本的常量指针。

* 在参数列表后面加`const`表示`this`是一个指向常量的指针。像这样使用`const`的成员函数被称作为 __常量成员函数 (const member function)__。

* 常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

* 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。

* 一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个文件内。


#### 构造函数 (constructor)

* 无论何时只要类的对象被创建，就会执行构造函数。

* 构造函数不能被声明为`const`。

* 构造函数在`const`对象的构造过程中可以向其写值。

* 只有当类没有声明任何构造函数时，编译器才会自动地生成 __默认构造函数 (default constructor)__。

* 编译器创建的构造函数又被称为 __合成的默认构造函数 (synthesized default constructor)__。
    * 如果存在类内的初始值，用它来初始化成员。
    * 否则，默认初始化该成员。

* 如果类包含有内置类型或者复合类型地成员，则只有当这些成员全都被赋予了类内地初始值时，这个类才适合于使用合成的默认构造函数。


* 如果成员是`const`或者是引用的话，必须将其初始化。

* 如果成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。

* 如果成员是`const`, 引用，或者属于某种未提供默认构造函数的类类型，我们必须通过 __构造函数初始值列表__ 为这些成员提供初值。

```c++
class ConstRef
{
public:
	ConstRef(int ii);
private:
	int i;
	const int ci;
	int& ri;
};

ConstRef::ConstRef(int ii)
{
	i = ii;			// OK

	ci = ii;		// ERROR! 不能给const赋值

	ri = i;			// ERROR! ri没被初始化
}

ConstRef::ConstRef(int ii) : i(ii),  ci(ii), ri(i) { } // OK, 这里必须使用构造函数初始值列表
```

* 成员的初始化顺序与它们在类定义中的出现顺序一致。构造初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。

```c++
class X
{
	int i;
	int j;
public:
	X(int val) : j(val), i (j) { } // Undefined, i会被先初始化

};
```

* 类只能有一个默认构造函数。

```c++
#include <iostream>

using namespace std;

class X
{
	int i;
	int j;
public:
	X(int val = 1) : j(val), i (val) { }
	X(istream& is = cin) { is >> i >> j; }			// ERROR! 两个默认构造函数了
};
```


* 委托构造函数 (delegating constructor): 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。

```c++
#include <iostream>

#include <string>

using namespace std;

class Sales_data
{
	friend istream& read(istream&, Sales_data&);
public:
	Sales_data(string s, unsigned cnt, double price) : bookNo(s), units_sold(cnt), revenue(cnt*price) { }
	Sales_data() : Sales_data("", 0, 0) {}
	Sales_data(string s) : Sales_data(s, 0, 0) {}
	Sales_data(istream& is) : Sales_data() { read(is, *this); }

private:
	string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};

istream& read(istream& is, Sales_data& item)
{
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}
```


* 当对象被默认初始化或值初始化时自动执行默认构造函数。

* 默认初始化在以下情况发生：
    * 当我们在块作用域内不适用任何初始值定义一个非静态变量或者数组时。
    * 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
    * 当类类型的成员没有在构造函数初始值列表中显示地初始化时。

* 值初始化在以下情况发生：
    * 在数组初始化地过程中如果我们提供的初始值数量少于数组的大小时。
    * 当我们不使用初始值定义一个局部静态变量时。
    * 当我们通过书写形如`T()`的表达式显式地请求值初始化时，其中`T`是类型名。


* 如果构造函数只接受 __一个__ 实参，则它实际上定义了转换为此类类型的隐式转换机制，这种构造函数称作 __转换构造函数 (converting constructor)__。

* 编译器只会自动地执行一步类型转换。

```c++
string null_book = "9-999-99999-9";
item.combine(null_book); // OK, 我们只需要把string转换成Sales_data


item.combine("9-999-99999-9"); // ERROR! 我们要进行两步转换，先把"99...99"换成string, 再换成Sales_data

item.combine(string("9-999-99999-9")); // OK

item.combine(Sales_data("9-999-99999-9")); // OK
```

* 在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为`explicit`加以阻止。

* `explicit`只对一个实参的构造函数有效。

* 只能在类内声明构造函数时使用`explicit`，在类外定义时不应重复。

* 当我们使用`explicit`关键字声明构造函数时，它将只能以直接初始化的形式使用。

#### 访问控制与封装

* 我们使用 __访问说明符 (access specifiers)__ 加强类的封装性。

* `public`, `protected`, `private`
    * `private`: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.
    * `protected`: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问
    * `public`: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问
    * 注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数.

* 默认的访问权限：`struct`是`public`的，`class`是`private`的。

* 类可以允许其他类或者函数访问它地非公有成员，方法是令其他类或者函数成为它的 __友元 (friend)__。如果类想把一个函数作为它的友元，只需要增加一条以`friend`关键字开始的函数声明语句即可。
    * 友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限，友元不是类的成员也不受它所在区域访问控制级别的约束。

* 封装的优点
    * 确保用户代码不会无意间破坏封装对象的状态。
    * 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

* 尽管当类的定义发生改变时无须更改用户代码，但是使用了该类的源文件必须重新编译。


#### 类的其他特性

* 可以在类的内部把`inline`作为声明的一部分显示地声明成员函数，同样的，也能在类的外部用`inline`关键字修饰函数地定义。

* 可变数据成员 (mutable data member)永远不会是`const`，即使它是`const`对象的成员。任何成员函数，包括`const`函数在内部都能改变它的值。

* 通过区分成员函数是否是`const`的，我们可以对其进行重载。

* __前向声明 (forward declaration)__。在类声明之后，定义之前是一个 __不完全类型 (incomplete type)__。

* 不完全类型只能在非常有限的情境下使用
    * 可以定义指向这种类型的指针或引用。
    * 可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。


* 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。

* 友元关系不存在传递性。每个类负责控制自己的友元类或友元函数。

* 如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。

* 友元本身不一定真的声明在当前作用域中。

* 就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。


#### 类的作用域

* 一个类就是一个作用域。

* 编译器处理完类中的全部声明后才会处理成员函数的定义。

* 在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。

* 类型名通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。


#### 聚合类 (aggregate class)

* 聚合类是的用户可以直接访问其成员，并且具有特殊的初始化语法形式。

* 聚合类的条件
    * 所有成员都是`public`的。
    * 没有定义任何构造函数。
    * 没有类内初始值。
    * 没有基类，也没有`virtual`函数。

* 与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。

```c++
#include <string>

using namespace std;

struct Data
{
	int ival;
	string s;
};

Data vall = { 0, "Anna" };
```

#### 字面值常量类

* 数据成员都是字面值类型的聚合类是字面值常量类。

* 如果一个类不是聚合类，但它符合下述要求，也是一个字面值常量类：
    * 数据成员都必须是字面值类型。（整型，浮点型）
    * 类必须至少含有一个`constexpr`函数。
    * 如果一个数据成员含有类初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`函数。
    * 类必须使用析构函数的默认定义，该成员负责销毁类的对象。

* 一个字面值常量类必须至少提供一个`constexpr`构造函数。

* `constexpr`构造函数必须初始化所有数据成员，初始值或者使用`constexpr`构造函数，或者是一条常量表达式。

* `constexpr`构造函数体一般来说应该是空的。


#### 静态成员

* 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。

* 静态成员函数不与任何对象绑定在一起，它们不包含`this`指针。所以我们不能在`static`函数体内使用`this`指针。

* 静态成员函数不能声明成`const`的。

* 我们既可以在类的内部也可以在类的外部定义静态成员函数。

* 当在类的外部定义静态成员时，不能重复`static`关键字，该关键字只出现在类内部的声明语句。

* 静态数据成员不是由类的构造函数初始化的。一般来说，我们不能在类的内部初始化静态成员。必须在类的外部定义和初始化每个静态成员。一个静态成员只能定义一次。

* 如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了。

* 通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供`const`整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的`constexpr`。初始值必须是常量表达式。

* 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义以下该成员。

* 静态成员和普通成员的一个区别是我们可以使用静态成员作为默认实参。

* 静态成员可以是不完全类型。特别的，静态数据成员的类型可以就是它所属的类类型，而非静态数据成员则受到限制，只能声明成它所属类的指针或引用。


```c++
class Bar
{
public:
	int i;
private:
	static Bar mem1;	// OK
	Bar* mem2;			// OK
	Bar mem3;			// ERROR!
};
```




#### 继承

#### 多态继承

定义： 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用）。
操作：在基类的函数前加上virtual关键字，在派生类中重写该函数，
运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；
如果对象类型是基类，就调用基类的函数。


#### 析构函数

* 基类的析构函数为何要声明为`virtual`?

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

class Foo
{
public:
	void f() { cout << "I am Foo" << endl; }
};

class Bar : public Foo
{
public:
	void f() { cout << "I am Bar" << endl; }
};


int main()
{
	Foo* p = new Bar();
	p->f();		// I am Foo

	return 0;
}
```
上述程序最后会调用`Foo::f()`，这是因为`p`是指向`Foo`的指针，而`f()`不是虚拟的。为确保`p->f()`会调用继承关系最末端的子类的`f()`实现，我们需要将`f()`声明为虚函数。

析构函数用于释放内存和资源。`Foo`的析构函数若不是虚拟的，那么，即使`p`实际上是`Bar`类型的，还是会调用`Foo`的析构函数。

所以，原因就是确保正确调用继承关系最末端的子类的析构函数。

```c++
#include <iostream>
#include <cstring> // strlen()

using namespace std;

class Foo
{
public:
	virtual void f() { cout << "I am Foo" << endl; }
};

class Bar : public Foo
{
public:
	void f() { cout << "I am Bar" << endl; }
};


int main()
{
	Foo* p = new Bar();
	p->f();		// I am Bar

	return 0;
}
```

* 调用顺序

```c++
#include <iostream>

using namespace std;

class Shape
{
public:
	int edge_length;
	virtual ~Shape()
	{
		cout << "Shape deleted\n";
	}
};

class Triangle : public Shape
{
public:
	~Triangle()
	{
		cout << "Triangle deleted\n";
	}
};

int main()
{
	Triangle* x = new Triangle();
	delete x;

	cout << endl << endl;

	Shape* y = new Triangle();
	delete y;
	return 0;
}
```

```bash
Triangle deleted
Shape deleted


Triangle deleted
Shape deleted
```


#### 虚函数

* 虚函数（virtual）：基类希望其派生类进行覆盖的函数。虚函数(virtual function) 需要虚函数表(vtable, Virtual Table)才能实现。如果一个类由函数声明成虚拟的，就会生成vtable，存放这个类的虚函数地址。此外，编译器还会在类里加入隐藏的`vptr`变量。若子类没有覆写虚函数，该子类的vtable就会存放父类的函数地址。调用这个虚函数时，就会通过vtable解析函数的地址。在C++里，动态绑定（dynamic binding）就是通过vtable机制实现的。由此，将子类对象赋值给基类指针时，`vptr`变量就会指向子类的vtable。这样一来，就能确保继承关系最末端的子类虚函数会被调用到。

```c++
#include <iostream>

using namespace std;

class Shape
{
public:
	int edge_length;
	virtual int circumference()
	{
		cout << "Circumference of Base Class\n";
		return 0;
	}
};

class Triangle : public Shape
{
public:
	int circumference()
	{
		cout << "Circumference of Triangle Class\n";
		return 3 * edge_length;
	}
};

int main()
{
	Shape* x = new Shape();
	x->circumference(); // "Circumference of Base Class"
	Shape* y = new Triangle();
	y->circumference(); // "Circumference of Triangle Class"
	return 0;
}
```



* 纯虚（pure virtual, =0）： ```double net_price(std::size_t) const = 0;```
    * 含有纯虚函数的类是抽象基类，不能创建抽象基类的对象。




#### 内联函数

C++ 内联函数是通常与类一起使用。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。

定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.


#### const

> https://www.cnblogs.com/MATU/p/5283454.html

```c++
class Test(){
public:
    Test(){}
    const int foo(int a);  //当const在函数名前面的时候修饰的是函数返回值。
    const int foo(int a) const; //当const在函数名后面表示是常成员函数，该函数不能修改对象内的任何成员，只能发生读操作，不能发生写操作。
};
```













### IO库

* `<iostream>`

* `<fstream>`

* `<sstream>`

#### IO类

* `ifstream`和`istringstream`都继承自`istream`。因此，我们可以像使用`istream`对象一样来使用`ifstream`和`istringstream`对象。

* 由于不能拷贝IO对象，因此我们也不能将形参或返回类型设置为流类型。

* 进行IO操作的函数通常以引用方式传递和返回流。

* 读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。

* 每个输出流都管理一个缓冲区，用来保存程序读写的数据。

* 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：
    * 程序正常结束，作为`main`函数的`return`操作的一部分，缓冲刷新被执行。
    * 缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。
    * 我们可以使用操纵符如`endl`来显式刷新缓冲区。
    * 在每个输出操作之后，我们可以用操纵符`unitbuf`设置流的内部状态，来清空缓冲区。默认情况下，对`cerr`是设置`unitbuf` ，因此写到`cerr`的内容都是立即刷新的。
    * 一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，`cin`和`cerr`都关联到`cout`。因此，读`cin`和`cerr`都会导致`cout`的缓冲区被刷新。


```c++
#include <iostream>

using namespace std;

int main()
{
	cout << "hi!" << endl;		// 完成换行，然后刷新缓冲区

	cout << "hi!" << flush;		// flush刷新缓冲区，不附加任何额外字符

	cout << "hi!" << ends;		// ends向缓冲区插入一个空字符，然后刷新缓冲区

	cout << unitbuf;		// 所有输出操作后都会立即刷新缓冲区

	cout << nounitbuf;		// 回到正常的缓冲方式

}
```


* `tie`有两个版本
    * 一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。
    * 另一个版本接受一个指向`ostream`的指针，将自己关联到此`ostream`。即，`x.tie(&o)`将流`x`关联到输出流`o`。

* 每个流同时最多关联到一个流，但多个流可以同时关联到同一个`ostream`。

* 每个IO对象都维护一组条件状态，用来指出此对象上是否可以进行IO操作。

```c++
#include <iostream>

using namespace std;

int main()
{
	cin.tie(&cout); // 将cin和cout关联在一起（其实默认已经是这样）

	ostream* old_tie = cin.tie(nullptr); // old_tie指向当前关联到cin的流（如果有的话），cin不再与其他流关联

	cin.tie(&cerr); // 将cin与cerr关联。读取cin会刷新cerr而不是cout

	cin.tie(old_tie);	// 重建cin和cout间的正常关联
}
```

#### 文件输出输入

* 如果我们定义了一个空文件六对象，可以随后调用`open`来将它与文件关联起来。

```c++
ifstream in(ifile);  // 构筑一个ifstream并打开给定文件

ofstream out;        // 输出文件流未与任何文件相关联

out.open(ifile + ".copy");  // 打开指定文件
```

* 因为调用可能失败，进行`open`是否成功的检测通常是一个好习惯。

```c++
if (out) // 检查是否成功
{
    // 如果成功了...
}
```

* 一旦一个文件流已经打开，它就保持与对应文件的关联。对一个已经打开的文件流调用`open`会失败，并会导致`failbit`被置位。为了将文件流关联到另一个文件，必须首先关闭已经关联的文件。

```c++
in.close();
in.open(ifile + "2");
```

* 当一个`fstream`对象被销毁时，`close`会被自动调用。

* 文件模式 (file mode)
    * `ofstream::in`以读方式打开
    * `ofstream::out`以写方式打开
    * `ofstream::app`每次写操作前均定位到文件末尾
    * `ofstream::ate`打开文件后立即定位到文件末尾
    * `ofstream::trunc`截断文件
    * `ofstream::binary`以二进制方式进行IO

* 默认情况下，即使我们没有指定`trunc`，以`out`模式打开的文件也会被截断。

* 保留被`ofstream`打开的文件中的已有数据的唯一方法是显式指定`app`或`in`模式。

* 如果未显式指定输出模式，文件隐式地以`out`模式打开。






















### 顺序容器 (sequential container)

#### 概述

* 顺序容器类型
    * `vector`: 可变大小数组
    * `deque`: 双端队列
    * `list`: 双向链表
    * `forward_list`: 单向链表
    * `array`: 固定大小数组
    * `string`: 与`vector`相似，但专门用于保存字符

* `string`和`vector`将元素保存在连续地内存空间中。由于元素是连续存储的，由元素下标来计算其地址是非常快速的。

* `list`和`forward_list`的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，它们不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。这两个容器的额外内存开销很大。

* `deque`支持快速随机访问（类似`vector`和`string`）。在`deque`两端添加或删除元素都是很快的。

* 只有`string`, `vector`, `deque`, `array`的迭代器支持下列运算
    * `iter + n`
    * `iter - n`
    * `iter1 += n`
    * `iter1 -= n`
    * `iter1 - iter2`
    * `>, >=, <, <=`

* `forward_list`迭代器不支持递减运算符 (`--`)。

* 最好使用`while (begin != end)` 而不是`while (begin < end)`。因为有些容器不支持`<`和`>`，例如`list`。

* 为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型时相同的了。

```c++
#include <iostream>

#include <vector>

#include <list>

#include <forward_list>

#include <deque>

#include <string>

using namespace std;

int main()
{
	list<string> authors = { "Tong", "Yihui" };
	vector<const char*> articles = { "a", "an", "the" };

	list<string> list2(authors); // OK：类型匹配

	deque<string> authList(authors); // ERROR: 容器类型不匹配

	vector<string> words(articles); // ERROR: 容器类型不匹配

	forward_list<string> words(articles.begin(), articles.end());	// OK

}
```

* 只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。


#### `array`

* 标准库`array`具有固定大小。

* 当定义一个`array`时，除了指定元素类型，还要指定容器大小。

```c++
array<int, 42> a1;
```

* 与其他容器不同，一个默认构造的`array`是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化。

* 如果我们对`array`进行列表初始化，初始值的数目必须等于或小于`array`的大小。如果初始值数目小于`array`的大小，则它们被用来初始化`array`中靠前的元素，所有剩余元素都会进行值初始化。

* 虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但`array`并无此限制。

* 与其他容器一样，`array`也要求初始值的类型必须与要创建的容器类型相同。此外，`array`还要求元素类型和大小也都一样。



#### 赋值和`swap`

* `assign`操作不适用于容器和`array`。

* `assign`允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> a1 = { 1, 2, 3, 4, 5 };
	vector<int> a2;
	a2.assign(a1.begin(), a1.begin() + 2); // { 1, 2 }
	a2.assign(3, 1);	// { 1, 1, 1 }
	a2.assign({ 3, 2, 1 });		// {3, 2, 1}
}
```

* 赋值相关运算会导致指向左边容器内部的迭代器，引用和指针失效。而`swap`操作将容器内容交换不会导致指向容器的迭代器，引用和指针失效 (容器类型为`array`和`string`的情况除外)。

* 除`array`外，`swap`不对任何元素进行拷贝，删除或插入操作，因此可以保证在常数时间内完成。

* 与其他容器不同，`swap`两个`array`会真正交换它们的元素。因此，交换两个`array`所需的时间与`array`中的元素的数目成正比。



#### 顺序容器操作

* 向一个`vector`，`string`或`deque`插入元素会使所有指向容器的迭代器，引用和指针失效。

* 在一个`vector`或`string`的尾部之外的任何位置，或是一个`deque`的首尾之外的任何位置添加元素，都需要移动元素。

* 向一个`vector`或`string`添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间。

* `insert`函数将元素插入到迭代器所指定的位置 __之前__。

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> v1 = { 1, 2, 3, 4, 5 };
	vector<int> v2 = { 10, 20, 30 };
	v1.insert(v1.begin(), v2.end() - 2, v2.end()); // v1: { 20 30 1 2 3 4 5 }

	v1.insert(v1.end(), { 100, 200 }); // v1: { 20 30 1 2 3 4 5 100 200 }

	v1.insert(v1.end(), 3, 666);		// v1: { 20 30 1 2 3 4 5 100 200 666 666 666 }

}
```

* 接收元素个数或范围的`insert`版本返回指向第一个新加入元素的迭代器。如果范围为空，不插入任何元素，`insert`操作会将第一个参数返回。

* `emplace_front`，`emplace`和`emplace_back`构造而不是拷贝元素。参数必须与元素类型的构造函数相匹配。

* 包括`array`在内的每一个顺序容器都有一个`front`成员函数，而除`forward_list`之外的所有顺序容器都有一个`back`成员函数。这两个操作分别返回首元素和尾元素的引用。

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> v1 = { 1, 2, 3, 4, 5 };
	auto& v1 = v1.back(); // 获得指向最后一个元素的引用

	auto v2 = v1.back(); // 获得最后一个元素的拷贝

}
```

* `c.at(n)`返回下标为`n`的元素的引用。如果下标越界，则抛出一`out_of_range`异常。

* 删除`deque`中除首尾位置之外的任何元素都会使所有迭代器，引用和指针失效。

* 指向`vector`或`string`中删除点之后位置的迭代器，引用和指针都会失效。

* 在一个`forward_list`中添加或删除元素的操作通过改变给定元素之后的元素来完成的。



#### 迭代器失效

* 在向容器添加元素后
    * 如果容器是`vector`或`string`，且存储空间被重新分配，则指向容器的迭代器，指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器，指针和引用仍有效，但指向插入位置之后元素的迭代器，指针和引用将会失效。
    * 对于`deque`，插入到除首尾位置之外的任何位置都会导致迭代器，指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。
    * 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器），指针和引用仍有效。

* 从一个容器删除元素后，
    * 指向被删除元素的迭代器，指针和引用会失效
    * 对于`list`和`forward_list`，指向容器的迭代器（包括尾后迭代器和首前迭代器），指针和引用仍有效。
    * 对于`deque`，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器，引用或指针也会失效。如果是删除`deque`的尾元素，则尾后迭代器也会失效，但其他迭代器，引用和指针不受影响；如果是删除首元素，这些也不会受影响。
    * 对于`vector`和`string`，指向被删除元素之前元素的迭代器，引用和指针仍有效。注意：当我删除元素时，尾后迭代器总是会失效。

#### 删除偶数元素，复制奇数元素

```c++
#include <iostream>

#include <vector>

using namespace std;

int main()
{
	vector<int> vi;
	for (vector<int>::size_type i = 0; i < 10; ++i)
		vi.push_back(static_cast<int>(i));

	auto iter = vi.begin();
	while (iter != vi.end())
	{
		if (*iter % 2)
		{
			iter = vi.insert(iter, *iter);
			iter += 2;
		}
		else
			iter = vi.erase(iter);
	}

	for (const auto& v : vi)
		cout << v << " ";
	cout << endl;
}
```

```c++
#include <iostream>

#include <list>

using namespace std;

int main()
{
	list<int> vi;
	for (list<int>::size_type i = 0; i < 10; ++i)
		vi.push_back(static_cast<int>(i));

	auto iter = vi.begin();
	while (iter != vi.end())
	{
		if (*iter % 2)
		{
			iter = vi.insert(iter, *iter);
			++iter;
			++iter;			// list 不支持 iter += 2

		}
		else
			iter = vi.erase(iter);
	}

	for (const auto& v : vi)
		cout << v << " ";
	cout << endl;
}

```

```c++
#include <iostream>

#include <forward_list>

using namespace std;

int main()
{
	forward_list<int> vi;
	auto cur = vi.before_begin();
	for (forward_list<int>::size_type i = 0; i < 10; ++i)
		cur = vi.insert_after(cur, static_cast<int>(i));

	auto prev = vi.before_begin();
	auto curr = vi.begin();

	while (curr != vi.end())
	{
		if (*curr % 2)
		{
			curr = vi.insert_after(curr, *curr);
			prev = curr;
			++curr;
		}
		else
		{
			curr = vi.erase_after(prev);
		}
	}

	for (const auto& v : vi)
		cout << v << " ";
	cout << endl;
}
```


#### 容量管理

* `shrink_to_fit`只适用于`vector`, `string`, `deque`。

* `capacity`和`reserve`只适用于`vector`和`string`。

* 容器的`size`是指它已经保存的元素的数目，而`capacity`则是在不分配新的内存空间的前提下它最多可以保存多少元素。

* 为什么`list`没有`capacity`函数？因为`list`不支持随机访问，它里面的元素是分散存储在内存里的。所以我们没有必要重新分配新的内存空间。所以它的`capacity`就是它的`size`。


#### 容器适配器 (adapter)

* 顺序容器适配器：`stack`, `queue`, `priority_queue`。

* 默认情况下，`stack`和`queue`是基于`deque`实现的。`priority_queue`是在`vector`之上实现的。

* 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。

```c++
stack<string, vector<string>> str_stk; // 在vector上实现的空栈
```

* `stack`可以被除`array`和`forward_list`之外的任何容器类型来构造。

* `queue`可以被`list`和`dequeue`构造。

* `priority_queue`可以被`vector`和`deque`构造。



















### 泛型算法 (generic algorithm)

* 算法永远不会改变底层容器的大小。

* 根据支持的操作不同，迭代器可以分为五类：输入，输出，前向，双向以及随机访问迭代器。

* 链表特有的操作会修改给定的链表。

* `accumulate()`

```c++

#include <iostream>

#include <vector>

#include <string>

#include <numeric>  // accumulate

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;

int main()
{
	vector<string> s{ "Hello ", "Tong" };
	string s1 = accumulate(s.begin(), s.end(), ""); // ERROR! 如果我们传递一个字符串字面值，用于保存和的对象将是const char*。由于const char*没有+运算符，此调用将产生编译错误。

	string s2 = accumulate(s.begin(), s.end(), string("")); // OK. "Hello Tong"

}
```


```c++

#include <iostream>

#include <algorithm>

#include <vector>

#include <string>

#include <numeric>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;

int main()
{
	vector<double> d{ 1.1, 2.2, 3.3 };
	cout << accumulate(d.begin(), d.end(), 0) << endl;	// 6, 因为第三个参数决定我们用哪种数值进行运算

	cout << accumulate(d.begin(), d.end(), 0.0) << endl;	// 6.6

}
```

* `equal`可以比较两个不同类型容器中的元素，而且元素类型也不必一样。但是，`equal`基于一个非常重要的假设：它假定第二个序列至少和第一个序列一样长。而且，我们必须能使用`==`来比较来自两个序列中的元素。

```c++
#include <iostream>

#include <algorithm>

#include <vector>

#include <string>

#include <numeric>

#include <list>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;
using std::list;

int main()
{
	vector<string> s1{ "Tong", "April" };
	vector<string> s2{ "Tong" };
	cout << equal(s1.begin(), s1.end(), s2.begin()) << endl;	// ERROR!!!

	cout << equal(s2.begin(), s2.end(), s1.begin()) << endl;	// 1

	vector<const char*> s3{ "Tong", "April" };
	cout << equal(s1.begin(), s1.end(), s3.begin()) << endl;	// 1

	list<const char*> s4{ "Tong", "April" };
	cout << equal(s3.begin(), s3.end(), s4.begin()) << endl;	// 1

}

```


* `back_inserter`在头文件`<iterator>`里，是一种向容器中添加元素的迭代器。当我们通过一个插入迭代器赋值时，一个与赋值右侧值相等的元素被添加到容器中。

```c++
#include <iostream>

#include <algorithm>	// fill_n

#include <vector>

#include <iterator>  // back_inserter

using std::cout;
using std::cin;
using std::endl;
using std::vector;

int main()
{
	vector<int> vec;
	auto it = back_inserter(vec);
	* it = 42; // { 42 }

	fill_n(back_inserter(vec), 5, 0);	// { 42 0 0 0 0 0 }

}
```

```c++
#include <iostream>

#include <algorithm>	// fill_n

#include <vector>

using std::cout;
using std::cin;
using std::endl;
using std::vector;

int main()
{
	vector<int> vec;
	vec.reserve(10);
	fill_n(vec.begin(), 10, 0);		// vec的size依然为0，应该用resize()
}

```

* `copy()`是向目的位置迭代器指向的输出序列中的元素写入数据的算法。传递给`copy`的目的序列至少要包含与输入序列一样多的元素。


```c++
#include <iostream>

#include <algorithm>	// copy

#include <vector>

#include <list>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::list;

int main()
{
	vector<int> vec;
	list<int> lst;
	int i;
	while (cin >> i)
		lst.push_back(i);

	copy(lst.cbegin(), lst.cend(), vec.begin()); // ERROR! vec的size为0

}
```

* `unique`并不真的删除元素，他只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。`unique`返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在。

```c++
#include <iostream>

#include <algorithm>	// copy

#include <vector>

#include <list>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::list;

std::ostream& operator<<(std::ostream& os, vector<int>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

int main()
{
	vector<int> vec{ 1,2,2,3,3,3,4,4,5 };
	sort(vec.begin(), vec.end());
	cout << vec;		// 1 2 2 3 3 3 4 4 5

	auto end_unique = unique(vec.begin(), vec.end());
	cout << vec;		// 1 2 3 4 5 3 4 4 5

	vec.erase(end_unique, vec.end());
	cout << vec;		// 1 2 3 4 5

}
```


* 为什么算法不能改变容器大小？`back_inserter`可以？ 因为对于算法，我们只传递了`iterator`，对本身容器没法直接访问，但是对于`back_inserter`，我们需要传递容器本身，所以有权限增加/删减内部元素。

#### 定制操作

#### 谓词 (predicate)

* 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。

* 标准库算法所使用的谓词分为两类：一元谓词（意味着它们只接受一个参数），和二元谓词（意味着它们有两个参数）。


```c++
#include <iostream>

#include <algorithm>	// stable_sort

#include <vector>

#include <string>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;

std::ostream& operator<<(std::ostream& os, vector<string>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

bool isShorter(const string& s1, const string& s2)
{
	return s1.size() < s2.size();
}

int main()
{
	vector<string> vs{ "Tong", "April", "Yihui", "Ling", "Wang" };
	std::stable_sort(vs.begin(), vs.end(), isShorter);
	cout << vs;
}

```


#### `lambda`表达式

* 可调用对象：对于一个对象或一个表达式，如果可以对其使用调用运算符`()`，则称它为可调用的。

* 可调用对象：1）函数，2）函数指针，3）重载了函数调用运算符的类，4）`lambda`表达式。

* 一个`lambda`表达式表示一个可调用的代码单元。可以将其理解为一个未命名的内联函数。

* 与普通函数不同，`lambda`必须使用尾置返回。

```
[capture list](parameter list) -> return type { function body }
```

* 如果`lambda`的函数体包括`return`语句之外的内容，且未指定返回类型，则返回`void`。被推断返回`void`的`lambda`不能返回值，除非我们指定返回类型。

```c++
#include <iostream>

#include <algorithm>	// transform

#include <vector>

using std::cout;
using std::cin;
using std::endl;
using std::vector;

std::ostream& operator<<(std::ostream& os, vector<int>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

int main()
{
	vector<int> vi{ -1, -2, -3, 1, 2, 4 };
	std::transform(vi.begin(), vi.end(), vi.begin(),
		[](int i) { return i < 0 ? -i : i; });		// OK

	cout << vi;	 // {1, 2, 3, 1, 2, 4}

	std::transform(vi.begin(), vi.end(), vi.begin(),
		[](int i) { if (i < 0) return -i; else return i; });	// 这个应该有错误，因为编译器应该推断为void类型。但是VS上运行没问题

	std::transform(vi.begin(), vi.end(), vi.begin(),
		[](int i) -> int { if (i < 0) return -i; else return i; });	// OK
}
```

* 与普通函数不同，`lambda`不能有默认参数。

* 一个`lambda`只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。

* 一个`lambda`可以直接使用定义在当前函数之外的名字和局部`static`变量。


```c++
#include <iostream>

#include <algorithm>	// stable_sort

#include <vector>

#include <string>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;

std::ostream& operator<<(std::ostream& os, vector<string>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

bool isShorter(const string& s1, const string& s2)
{
	return s1.size() < s2.size();
}

int main()
{
	vector<string> vs{ "Tong", "April", "Yihui", "Ling", "Wang" };
	std::stable_sort(vs.begin(), vs.end(), isShorter);
	const int sz = 5;
	auto wc = find_if(vs.begin(), vs.end(),
		[sz](const string& a)
		{ return a.size() >= sz; });		// 获取一个迭代器，指向第一个满足size() >= sz的元素

	auto count = vs.end() - wc;
	cout << count << endl;
}
```


* `lambda`采用的值捕获方式的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在`lambda`创建时拷贝，而不是调用时拷贝。

* `lambda`可以采用引用捕获。但必须确保被引用的对象在`lambda`执行的时候时存在的。

* 引用捕获有时是必要的，例如不能拷贝的`ostream`对象。

* 如果函数返回一个`lambda`，此`lambda`也不能包含引用捕获。

* 隐式捕获：指示编译器推断捕获列表，写一个`&`或`=`。`&`告诉编译器采用捕获引用方式，`=`则表示采用值捕获方式。

* 如果我们可以混合使用隐式捕获和显式捕获。当我们混合使用时，捕获列表中的第一个元素必须是一个`&`或`=`。而且，显式捕获的变量必须使用与隐式捕获不同的方式。

* 如果我们希望能改变一个被捕获的值被拷贝的变量的值，就必须在参数列表首加上关键子`mutable`。

```c++
int main()
{
	size_t v1 = 42;
	auto f = [v1] () mutable { return ++v1; };
	v1 = 0;
	auto j = f(); // j == 43
}
```

#### 参数绑定

* `bind`函数在`<functional>`中。它可以被看作是一个通用的函数适配器，接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。

```
auto newCallable = bind(callable, arg_list);
```


```c++
#include <iostream>

#include <algorithm>	// stable_sort

#include <vector>

#include <string>

#include <functional>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::string;
using std::placeholders::_1;

std::ostream& operator<<(std::ostream& os, vector<string>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

bool isShorter(const string& s1, const string& s2)
{
	return s1.size() < s2.size();
}

int main()
{
	vector<string> vs{ "Tong", "April", "Yihui", "Ling", "Wang" };
	std::stable_sort(vs.begin(), vs.end(), isShorter);
	const int sz = 5;

	auto check_size = [](const string& a, int sz) { return a.size() >= sz; };
	auto checkSz = std::bind(check_size, _ 1, sz);
	auto wc = find_if(vs.begin(), vs.end(), checkSz);

	auto count = vs.end() - wc;
	cout << count << endl;
}
```


* 名字 `_n`都定义在一个名为`placeholders`的命名空间中，而这个命名空间本身定义在`std`命名空间中。在头文件`<functional>`中。


```c++
auto g = bind(f, a, b, _ 2, c, _ 1);

// 注意对应关系

// g(_1, _2)

// f(a, b, _2, c, _1)
```

* 默认情况下，`bind`那些不是占位符的参数被拷贝到`bind`返回的可调用对象中。

* 为了绑定引用参数，我们可以使用标准库`ref`或者`cref`函数 (头文件`<functional>`)。

```c++
for_each(words.begin(), words.end(), bind(print, ref(os), _ 1, ' '));
```

#### 插入迭代器

* `back_inserter`创建一个使用`push_back`的迭代器。

* `front_inserter`创建一个使用`push_front`的迭代器。

* `inserter`创建一个使用`insert`的迭代器。当调用`inserter(c, iter)`时，我们得到一个迭代器，接下来使用它时，会将元素插入到`iter`原来所指向的元素之前的位置。最后得到的迭代器指向原来的元素。

```c++
#include <iostream>

#include <algorithm>	// copy

#include <vector>

#include <list>

#include <iterator>

using std::cout;
using std::cin;
using std::endl;
using std::vector;
using std::list;

template <typename T>
std::ostream& operator<<(std::ostream& os, list<T>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

int main()
{
	vector<int> v{ 1, 2, 3 };
	list<int> v1, v2, v3;
	std::copy(v.begin(), v.end(), std::front_inserter(v1));		// 3 2 1

	std::copy(v.begin(), v.end(), std::back_inserter(v2));		// 1 2 3

	std::copy(v.begin(), v.end(), std::inserter(v3, v3.begin()));	// 1 2 3

}
```

* `unique_copy`

```c++
#include <iostream>     // std::cout

#include <algorithm>    // std::unique_copy, std::sort, std::distance

#include <vector>       // std::vector

bool myfunction(int i, int j) {
	return (i == j);
}

int main() {
	int myints[] = { 10,20,20,20,30,30,20,20,10 };
	std::vector<int> myvector(9);                            // 0  0  0  0  0  0  0  0  0

	// using default comparison:

	std::vector<int>::iterator it;
	it = std::unique_copy(myints, myints + 9, myvector.begin());   // 10 20 30 20 10 0  0  0  0
															  //                ^

	std::sort(myvector.begin(), it);                          // 10 10 20 20 30 0  0  0  0
															  //                ^

	// using predicate comparison:

	it = std::unique_copy(myvector.begin(), it, myvector.begin(), myfunction);
	// 10 20 30 20 30 0  0  0  0
	//          ^

	myvector.resize(std::distance(myvector.begin(), it));    // 10 20 30

	// print out content:
	std::cout << "myvector contains:";
	for (it = myvector.begin(); it != myvector.end(); ++it)
		std::cout << ' ' << * it;
	std::cout << '\n';

	return 0;
}
```

#### `iostream`迭代器

* `istream_iterator`要读取的类型必须定义了输入运算符。

* 我们可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。

```c++
#include <iostream>     // std::cout

#include <algorithm>    // std::unique_copy, std::sort, std::distance

#include <vector>       // std::vector

#include <iterator>

using std::istream_iterator;
using std::cout;
using std::cin;
using std::endl;
using std::vector;

template <typename T>
std::ostream& operator<<(std::ostream& os, vector<T>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

int main()
{
	std::istream_iterator<int> in_iter(cin), eof;
	vector<int> v;
	while (in_iter != eof)
		v.push_back(*in_iter++);
	return 0;
}
```

```c++
#include <iostream>     // std::cout

#include <algorithm>    // std::unique_copy, std::sort, std::distance

#include <vector>       // std::vector

#include <iterator>

using std::istream_iterator;
using std::cout;
using std::cin;
using std::endl;
using std::vector;

template <typename T>
std::ostream& operator<<(std::ostream& os, vector<T>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

int main()
{
	std::istream_iterator<int> in_iter(cin), eof;
	vector<int> v(in_iter, eof);
	cout << v;
	return 0;
}
```

* 当创建一个`ostream_iterator`时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。

```c++
#include <iostream>     // std::cout

#include <algorithm>    // std::unique_copy, std::sort, std::distance

#include <vector>       // std::vector

#include <iterator>

using std::ostream_iterator;
using std::cout;
using std::cin;
using std::endl;
using std::vector;

template <typename T>
std::ostream& operator<<(std::ostream& os, vector<T>& v)
{
	for (auto e : v)
		os << e << " ";
	os << endl;
	return os;
}

int main()
{
	std::ostream_iterator<int> out_iter(cout, "-");
	vector<int> v{ 1, 2, 3, 4, 5 };

    // 下面等价于copy(v.begin(), v.end(), out_iter);

	for (auto e : v)
		* out_iter++ = e;
	cout << endl; // 1-2-3-4-5-

}
```


#### 反向迭代器

* 将一个反向迭代器转换成一个普通迭代器，可以用`base()`，但是它们会指向不同的元素，因为“左闭右开”的特性。

* 当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素。

```c++
#include <iostream>     // std::cout

#include <algorithm>    // std::unique_copy, std::sort, std::distance

#include <iterator>

#include <string>

using std::cout;
using std::cin;
using std::endl;
using std::string;

int main()
{
	string s("Hello, Tong, how are you");
	auto rcomma = find(s.crbegin(), s.crend(), ',');
	cout << string(s.crbegin(), rcomma) << endl;	// "uoy era woh "

	cout << string(rcomma.base(), s.cend()) << endl;	// " how are you"

}
```




























### 关联容器

* 严格弱序 (strict weak ordering)：关联容器所使用的关键字间的关系。在一个严格弱序中，可以比较任意两个值并确定哪个更小。若任何一个都不小于另一个，则认为两个值相等。

* 对于有序容器-`map`, `multimap`, `set`以及`multiset`，关键字类型必须定义元素比较的方法。

* 默认情况下，标准库使用关键字类型的`<`运算符来比较两个关键字。

* 我们可以定义`map<vector<int>::iterator, int>`，因为`vector<int>::iterator`支持使用`<`进行比较。

* 我们不可以定义`map<list<int>::iterator, int>`因为它不支持比较。

```c++
#include <iostream>

#include <set>

using namespace std;

struct Person
{
	int age;
	string name;
};

bool compareAge(const Person& p1, const Person& p2)
{
	return p1.age < p2.age;
}

int main()
{
	Person p1 = { 1 };
	Person p2 = { 2 };

	set<Person, decltype(compareAge)*> dict1(compareAge);
	set<Person, bool (*)(const Person & p1, const Person & p2 )> dict2(compareAge);

	dict2.insert(p1);
	dict2.insert(p2);

}
```

* `set`的迭代器`iterator`和`const_iterator`都是`const`的，这两种类型只允许只读访问，不能修改。

* `set`类型中的元素是`const`的，`map`中的元素是`pair`，其第一个成员是`const`的。

* `multiset`不能使用`back_inserter`，因为它没有`push_back`。但是它可以使用`inserter`。

* 向`map`添加元素
    * `word_count.insert({word, 1});`
    * `word_count.insert(make_pair(word, 1));`
    * `word_count.insert(pair<string, size_t>(word, 1));`
    * `word_count.insert(map<string, size_t>::value_type(word, 1));`

* 对于`map`和`set`，只有当元素的关键字不再`c`中时才插入`insert`（或构造`emplace`）元素。函数返回一个`pair`，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的`bool`值。

```c++
#include <iostream>

#include <map>	// map

#include <string>	// string

#include <cstddef> // size_t

using namespace std;

int main()
{
	map<string, size_t> word_count;
	string word;
	while (cin >> word)
	{
		auto ret = word_count.insert({ word, 1 });
		if (!ret.second)
			++ret.first->second;   // 等价于 ++((ret.first)->second)

	}
}

```

* 由于一个`multi`容器中的关键字不必唯一，在这些类型上调用`insert`总会插入一个元素，返回一个指向新元素的迭代器。

* 关联容器提供一个额外的`erase`操作，它接受一个`key_type`参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。

* 由于下标运算符可能插入一个新元素，我们只可以对非`const`的`map`使用下标操作。

* `c[k]` vs. `c.at(k)`
    * `c[k]`返回关键字为`k`的元素：如果`k`不在`c`中，添加一个关键字为`k`的元素，对其进行值初始化。
    * `c.at(k)`访问关键字为`k`的元素，带参数检查：若`k`不在`c`中，抛出一个`out_of_range`异常。

* 与`vector`和`string`不同，`map`的下标运算符返回的类型与解引用`map`迭代器得到的类型不同。

* 如果一个`multimap`或`multiset`中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。

```c++
#include <iostream>

#include <map>	// map

#include <string>	// string

#include <cstddef> // size_t

using namespace std;

int main()
{
	multimap<string, string> authors;
	authors.insert({ "Tong", "good book" });
	authors.insert({ "April", "better book" });
	authors.insert({ "April", "best book" });
	authors.insert({ "April", "bestest book" });
	authors.insert({ "Tong", "awesome book" });
	auto entries = authors.count("Tong");
	auto iter = authors.find("Tong");
	while (entries)
	{
		cout << iter->second << endl;
		++iter;
		--entries;
	}
}
```

* `c.lower_bound(k)`：返回一个迭代器，指向第一个关键字不小于`k`的元素

* `c.upper_bound(k)`：返回一个迭代器，指向第一个关键字大于`k`的元素

* `c.equal_range(k)`：返回一个迭代器`pair`，表示关键字等于`k`的元素的范围。若`k`不存在，`pair`的两个成员均等于`c.end()`

```c++
#include <iostream>

#include <map>	// map

#include <string>	// string

#include <cstddef> // size_t

using namespace std;

int main()
{
	multimap<string, string> authors;
	authors.insert({ "Tong", "good book" });
	authors.insert({ "April", "better book" });
	authors.insert({ "April", "best book" });
	authors.insert({ "April", "bestest book" });
	authors.insert({ "Tong", "awesome book" });
	auto entries = authors.count("Tong");
	auto iter = authors.find("Tong");

	for (auto beg = authors.lower_bound("Tong"),
		end = authors.upper_bound("Tong");
		beg != end; ++beg)
		cout << beg->second << endl;

	for (auto pos = authors.equal_range("Tong");
		pos.first != pos.second; ++pos.first)
		cout << pos.first->second << endl;
}

```

#### 管理桶

* 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。

* 无序容器使用一个哈希函数将元素映射到桶。

* 容器将具有一个特定哈希值的所有元素都保存在相同的桶中。

* 如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。

* 无序容器的性能依赖于哈希函数的质量和桶的数量和大小。

* 无序容器使用关键字类型的`==`运算符和一个`hash<key_type>`类型的对象来组织元素。


#### unordered_<> and ordered_<>

> 原文链接：https://blog.csdn.net/haluoluo211/article/details/82468061

* Implementation
    * `set`基于红黑树实现，红黑树具有自动排序的功能，因此`map`内部所有的数据，在任何时候，都是有序的。
    * `unordered_set`基于哈希表，数据插入和查找的时间复杂度很低，几乎是常数时间，而代价是消耗比较多的内存，无自动排序功能。底层实现上，用一个下标范围比较大的数组来存储元素，形成很多的桶，利用`hash`函数对`key`进行映射到不同区域进行保存。

* Ordering
    * `set`: increasing order (by default)
    * `unordered_set`: no ordering

* Search time
    * `set`: log(n)
    * `unordered_set`: average -> O(1); worst case -> O(n)

* Insertion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Deletion time
    * `set`: log(n) + rebalance
    * `unordered_set`: same as search

* Key的类型

```c++
#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
using namespace std;

ostream& operator<<(ostream& stream, const vector<int>& nums)
{
	for (const int num : nums)
		stream << num << " ";
	return stream;
}

int main()
{
	vector<int> v{ 1, 2, 3, 4, 5 };
	// unordered_set<vector<int>> usv; // unordered_set不能使用vector<int>作为key，因为vector<int>没有hash函数，除非自己定义一个

	set<vector<int>> sv;  // set可以使用vector<int>作为key，因为vector 重载了 operator<

    sv.insert({ 1, 2 });
	sv.insert({ 1, 3 });
	sv.insert({ 1, 2, 3 });
	sv.insert({ 4, 1 });
	for (vector<int> v : sv)
		cout << v << endl;
}
```

上面程序输出

```bash
1 2
1 2 3
1 3
4 1
```
























### 动态内存

* 静态内存用来保存局部`static`对象，类`static`数据成员，以及定义在任何函数之外的变量。

* 栈内存用来保存定义在函数内的非`static`对象。

* 分配在静态或栈内存中的对象由编译器自动创建和销毁。

* 栈对象仅在其定义的程序块运行时才存在；`static`对象在使用之前分配，在程序结束时销毁。

* 每个程序还拥有一个内存池，这部分被称作自由空间 (free store)或堆 (heap)。

* 程序用堆来存储 __动态分配 (dynamically allocate)__ 的对象---即，那些在程序运行时分配的对象。动态对象的生存期由程序来控制。也就是说，当动态对象不再使用时，我们的代码必须显式地销毁它们。

* `<memory>`

* 使用动态内存的三种原因：
    * 程序不知道自己需要使用多少对象
    * 程序不知道所需对象的准确类型
    * 程序需要在多个对象间共享数据

####` shared_ptr`

* `make_shared`是最安全地分配和使用动态内存的方法。如果我们不传递任何参数，对象就会进行值初始化。

* 一旦一个`shared_ptr`的计数器变为0，它就会自动释放自己所管理的对象。

```c++
#include <iostream>

#include <memory>	 

using namespace std;

int main()
{
	shared_ptr<int> p1 = make_shared<int>(42);
	auto p2 = make_shared<int>();
	auto p3(p2); // 拷贝了一个shared_ptr, 计数器都会递增

	cout << p1.use_count() << endl; // 1

	p1 = p3; // p1原指向的计数器减1，所以自动销毁；p3指向的加1，所以为3

	cout << p1.use_count() << endl; // 3

    shared_ptr<int> p4(new int(42)); // OK

    shared_ptr<int> p5 = new int(42); // ERROR! 必须使用直接初始化形式，在函数传递参数也要注意

    int* x(new int(42));

    shared_ptr<int> p6(x); // OK, 但不建议这么做，我们无法知道对象何时会被销毁

}
```

* 如果将`shared_ptr`存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用`erase`删除不再需要的那些元素。

* `get()`返回一个内置指针，指向智能指针管理的对象。但是，不要把另一个智能指针也绑定到`get`返回的指针上。

```c++
#include <iostream>

#include <memory>	 

using namespace std;

int main()
{
	shared_ptr<int> p(new int(42));
	int* q = p.get(); // OK

	{
		shared_ptr<int> p1(q); // Undefined!!! 两个独立的shared_ptr指向相同的内存

	}

	int foo = * p; // Undefined!!! p指向的内存已经被释放了

}
```


* 如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。


#### 直接管理内存

* `new`

```c++
int *pi1 = new int; // 默认初始化，未定义
int *pi2 = new int(); // 值初始化，0
```

* 默认情况下，如果`new`不能分配所要求的内存空间，它会抛出一个类型为`bad_alloc`的异常。

* `定位new (placement new)`允许我们向`new`传递额外的参数。

* `nothrow`可以防止抛出异常，并且返回一个空指针。

```c++
#include <iostream>

#include <memory>	 

using namespace std;

int main()
{
	int* p1 = new int;
	int* p2 = new (nothrow) int; // 如果失败，返回一个空指针

}

```


* 传递给`delete`的指针必须是指向动态分配的内存，或者是一个空指针。

* 释放一块并非`new`分配的内存，或者将相同的指针值释放多次，其行为是未定义的。

```c++
#include <iostream>

#include <memory>	 

using namespace std;

int main()
{
	int i;
	int* pi1 = &i;
	int* pi2 = nullptr;

	double* pd = new double(33);
	double* pd2 = pd;

	delete i; // ERROR! i不是指针

	delete pi1; // Undefined! pi1指向一个局部变量

	delete pd; // OK

	delete pd2; // Undefined! pd2指向的内存已经被释放了

	delete pi2; // OK, 释放一个空指针总是没有错误的

}
```


* 由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在。


#### 智能指针陷阱

* 不使用相同的内置指针值初始化（或`reset`）多个智能指针。

* 不`delete` `get()`返回的指针。

* 不使用`get()`初始化或`reset`另一个智能指针。

* 如果你使用`get()`返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了。

* 如果你使用智能指针管理的资源不是`new`分配的内存，记住传递给它一个删除器(deleter)。

#### `unique_ptr`

* 一个`unique_ptr`“拥有”它所指向的对象。某个时刻只能有一个`unique_ptr`指向一个给定对象。

* `unique_ptr`不支持普通的拷贝或者赋值操作。

* `release`会切断`unique_ptr`和它原来管理的对象间的联系，返回指针，并将原`unique_ptr`置空。返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。如果我们不用另一个智能指针来保存`release`返回的指针，我们的程序就要负责资源的释放。

```c++
#include <iostream>

#include <memory>	 

using namespace std;

int main()
{
	unique_ptr<int> p1(new int(42));

	unique_ptr<int> p2(p1); // ERROR! unique_ptr不支持拷贝

	unique_ptr<int> p3;
	p3 = p1; // ERROR! unique_ptr不支持拷贝

	unique_ptr<int> p4(p1.release()); // OK, p1 -> p4, p1被置空
	unique_ptr<int> p5(new int(100));

	p4.reset(p5.release()); // OK, p5 -> p4, reset释放了p4原来指向的内存

	p4.release(); // ERROR! p4不会释放内存，而且我们丢失了指针

	auto p = p4.release(); // OK, 我们必须记得 delete (p)

}

```


* 不能拷贝`unique_ptr`的规则有一个例外，我们可以拷贝或赋值一个将要被销毁的`unique_ptr`。例如从函数返回一个`unique_ptr`。

```c++
#include <iostream>

#include <memory>	 

using namespace std;

unique_ptr<int> clone(int p)
{
	return unique_ptr<int>(new int(p));
}

unique_ptr<int> clone2(int p)
{
	unique_ptr<int> ret(new int(p));
	return ret;
}

int main()
{
	auto p1 = clone(42);
	auto p2 = clone2(42);
}

```




#### `weak_ptr`

* `weak_ptr`是一种不控制所指向对象生存期的智能指针，它指向一个由`shared_ptr`管理的对象，并且不会改变`shared_ptr`的引用计数。

* 由于对象可能不存在，我们不能使用`weak_ptr`直接访问对象，而必须调用`lock`。此函数检查`weak_ptr`所指向的对象是否仍存在。如果存在，`lock`返回一个指向共享对象的`shared_ptr`。否则返回一个空`shared_ptr`。



#### 动态数组

* 动态数组并不是数组类型，而是一个数组类型元素的指针。

```c++
int* pia = new int[10]; // 未初始化

int* pia2 = new int[10](); // 值初始化为0

int* pia3 = new int[10]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // OK
```


* 当我们用`new`分配一个大小为0的数组时，`new`返回的是一个合法的飞空指针。

```c++
char arr[0];   // ERROR! 不能定义长度为0的数组

char* cp = new char[0]; // OK. 但cp不能解引用
```

* 为了释放动态数组，我们要在指针前加上一个空方括号。

* 数组中的元素按逆序销毁。

```c++
typedef int arrT[42];
int* p = new arrT;
delete [] p;
```

* 特殊的`unique_ptr`可以指向一个动态数组，并且使用下标运算符访问数组中的元素。

```c++
unique_ptr<int []> up(new int[10]);
up.release(); // 自动用delete[]销毁其指针

for (size_t i = 0; i != 10; ++i)
    up[i] = i;
```

* `shared_ptr`不支持管理动态数组，除非自己定义删除器。而且无法用下标运算符。

```c++
shared_ptr<int> sp(new int[10], [](int* p) { delete[] p; });
sp.reset(); // 使用我们提供的lambda释放数组
```

```c++
for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i;
```

#### `allocator`

* `<memory>`

* 它帮助我们将内存分配和对象构造分离开来。

```c++
#include <iostream>

#include <memory>	 

#include <string>

using namespace std;


int main()
{
	int n = 30;
	allocator<string> alloc;
	auto const p = alloc.allocate(n); // 分配30个未初始化的string

	auto q = p;  // q指向最后构造的元素之后的元素

	alloc.construct(q++, 10, 'c');

	cout << * p << endl;

	while (q != p)
		alloc.destroy(--q); // 释放我们真正构造的string

	alloc.deallocate(p, n); // 大小参数必须和之前相同
}
```


#### 编写一个智能指针类

智能指针是一种数据类型，一般用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动记录`SmartPointer<T*>`对象的引用计数，一旦`T`类型对象的引用计数为零，就会释放该对象。

```c++
#include <iostream>

using namespace std;

template <class T>
class SmartPointer
{
public:
	SmartPointer(T* ptr)
	{
		ref = ptr;
		ref_count = (unsigned*)malloc(sizeof(unsigned));
		*ref_count = 1;
	}

	SmartPointer(SmartPointer<T>& sptr)
	{
		ref = sptr.ref;
		ref_count = sptr.ref_count;
		++(*ref_count);
	}

	SmartPointer<T>& operator=(SmartPointer<T>& sptr)
	{
		if (this == &sptr) return *this;

		/* If already assigned to an object, remove one reference */
		if (*ref_count > 0) remove();

		ref = sptr.ref;
		ref_count = sptr.ref_count;
		++(*ref_count);
		return *this;
	}

	~SmartPointer()
	{
		remove(); // Remove one reference to object

	}

	T getValue()
	{
		return *ref;
	}

protected:
	void remove()
	{
		--(*ref_count);
		if (*ref_count == 0) delete ref;
		free(ref_count);
		ref = nullptr;
		ref_count = nullptr;
	}

	T* ref;
	unsigned* ref_count;
};


int main()
{
	return 0;
}
```


#### Typical beginner error

```c++
#include <iostream>

#include <memory>

int main()
{
	int a = 0;
	auto a_ptr = std::unique_ptr<int>(&a);
	return 0;
}
```

* Create a smart pointer from a pointer to a stack-managed variable
* The variable ends up being owned both by the smart pointer and the stack and gets deleted twice → __Error!__


#### 内存泄漏 (Memory Leak)

Memory leak if nobody has freed the memory.

* 忘记`delete`或者`delete`两次同一个地址

```c++
#include <iostream>

using namespace std;

int main()
{
	double* ptr_1 = nullptr;
	double* ptr_2 = nullptr;
	int size = 10;

	// Allocate memory for two arrays on the heap

	ptr_1 = new double[size];
	ptr_2 = new double[size];
	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;		// 1: 00FF5670 2: 00FF5398

	ptr_2 = ptr_1; // ptr_2 overwritten. PROBLEM: no change to access the previous memory of ptr_2， 之前的内存没法删除了

	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;		// 1: 00FF5670 2: 00FF5670

	delete[] ptr_1;
	delete[] ptr_2;    // 同一个地址删了两次

	return 0;
}
```

* If we run out of memory, `std::bad_alloc` error is thrown.

```c++
#include <iostream>
#include <cmath>
#include <algorithm>

using namespace std;

int main()
{
	double* data = nullptr;
	size_t size = pow(1024, 3) / 8; // Produce 1 GB

	for (int i = 0; i < 5; ++i)
	{
		// Allocate memory for the data

		data = new double[size];
		fill(data, data + size, 1.23);

		cout << "Iteration: " << i << " done!" << endl;
	}

	delete[] data; // PROBLEM: This will only free the last allocation!!!

	return 0;
}
```

#### 悬挂指针（Dangling pointer）

Dangling pointer if somebody has freed the memory in a function.

```c++
#include <iostream>

using namespace std;

int main()
{
	int size = 5;
	int* ptr_1 = new int[size];
	int* ptr_2 = ptr_1;

	ptr_1[0] = 100;
	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;	// 1: 01245D78 2: 01245D78
	cout << "ptr_2 [0]: " << ptr_2[0] << endl;	// ptr_2 [0]: 100

	delete[] ptr_1; // Free memory.

	ptr_1 = nullptr;
	cout << "1: " << ptr_1 << " 2: " << ptr_2 << endl;	// 1: 00000000 2: 01245D78

	// PROBLEM: Data under ptr_2 does not exist anymore!

	cout << "ptr_2 [0]: " << ptr_2[0] << endl; // ptr_2[0]: -572662307

	return 0;
}
```



#### 普通指针如何实现一块内存只有一个指针指向这种功能

























### 拷贝控制

* 拷贝控制操作
    * 拷贝构造函数 (copy constructor)
    * 拷贝赋值运算符 (copy-assignment operator)
    * 移动构造函数 (move constructor)
    * 移动赋值运算符 (move-assignment operator)
    * 析构函数 (destructor)

#### 拷贝构造函数

* 拷贝构造函数的第一个参数必须是一个引用类型。因为拷贝构造函数被用来初始化非引用类类型参数。如果其参数不是引用类型，则调用永远不会成功---为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要拷贝构造函数，如此无限循环。

```c++
class foo
{
public:
    Foo ();
    Foo (const Foo&);
}
```

* 拷贝构造函数通常不应该是`explicit`的。

* 拷贝初始化通常是由拷贝构造函数或者移动构造函数来完成的。

* 拷贝构造发生的情况
    * 用`=`定义变量时
    * 将一个对象作为实参传递给一个非引用类型的形参
    * 从一个返回类型未非引用类型的函数返回一个对象
    * 用花括号列表初始化一个数组中的元素或一个聚合类中的成员
    * 初始化标准库容器或是调用其`insert`或`push`成员采用拷贝初始化。但是，用`emplace`创建的元素都直接初始化。


* 初始化问题

```c++
#include <iostream>

using namespace std;

class A
{
private:
	int value;

public:
	A(int n) { value = n; }

	// PROBLEM: 复制构造函数A(A other)传入的参数是A的一个实例。由于是传值函数，我们把形参复制到实参会调用复制构造函数。因此，如果允许复制构造函数传值，就会在复制构造函数内调用复制构造函数，就会形成无休止的递归调用从而导致栈溢出

	A(A other) { value = other.value; }  

	void Print() { cout << value << endl; }
};

int main()
{
	A a = 10;
	A b = a;
	b.Print();

	return 0;
}
```

将上述代码修改如下后才能运行

```c++
#include <iostream>

using namespace std;

class A
{
private:
	int value;

public:
	A(int n) { value = n; }
	A(const A& other) { value = other.value; }  

	void Print() { cout << value << endl; }
};

int main()
{
	A a = 10;
	A b = a;
	b.Print();

	return 0;
}
```

#### 拷贝赋值函数


* 赋值运算符通常应该返回一个指向其左侧运算对象的引用。

```c++
class foo
{
public:
    Foo& operator=(const Foo&);
}
```

#### 析构函数

* 构造函数初始化对象的非`static`数据成员；析构函数释放对象使用的资源，并销毁对象的非`static`数据成员。

* 隐式销毁一个内置指针类型的成员不会`delete`它所指向的对象。

* 无论何时一个对象被销毁，就会自动调用其析构函数：
    * 变量离开作用域时被销毁。
    * 当一个对象被销毁时，其成员被销毁。
    * 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。
    * 对于动态分配的对象，当对指向它的指针应用`delete`运算符时被销毁。
    * 对于临时对象，当创建它的完整表达式结束时被销毁。

* 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。


```c++
#include <iostream>

#include <string>

using namespace std;

class HasPtr
{
public:
	HasPtr(const string& s = string()) :
		ps(new string(s)), i(0) { }

	HasPtr(const HasPtr& ori) :
		ps(new string(*ori.ps)), i(ori.i) { }

	HasPtr& operator=(const HasPtr& ori)
	{
		auto new_ps = new string(*ori.ps);
		delete ps;
		ps = new_ps;
		i = ori.i;
		return *this;
	}

	~HasPtr() { delete ps; }

	string getPs() { return *ps; }

private:
	string* ps;
	int i;
};

int main()
{
	HasPtr ori("Tong");
	HasPtr sec = ori;
	HasPtr thi;
	thi = ori;
	cout << sec.getPs() << endl;
	cout << thi.getPs() << endl;
}
```

* 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。

* 需要拷贝操作的类也需要赋值操作，反之亦然。但这不必然意味着也需要析构函数。



#### 阻止拷贝

* 我们只能对具有合成版本的成员函数使用`=default`（即，默认构造函数或拷贝控制成员），这样来显式地要求编译器生成合成的版本。

* 当我们在类内用`=default`修饰成员的声明时，合成的函数将隐式地声明为内联地（就像任何其他类内声明地成员函数一样）。如果我们不希望合成的成员时内联函数，应该只对成员外定义使用`=default`，就像对拷贝赋值运算符所做的那样。

* 我们可以通过将拷贝构造函数和拷贝赋值运算符定义为`=delete`来阻止拷贝。

* 与`=default`不同
    * `=delete`必须出现在函数第一次声明的时候。
    * `=delete`可以对任何函数指定

* 如果析构函数被删除，就无法销毁此类型的对象了。

* 对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象，但可以动态分配这种类型的对象。但是，我们不能释放指向该类型动态分配对象的指针。

```c++
struct NoDtor
{
	NoDtor() = default;
	~NoDtor() = delete;
};

NoDtor nd; // ERROR

NoDtor* p = new NoDtor(); // OK

delete p; // ERROR
```

* 如果一个类有数据成员不能默认构造，拷贝，复制或销毁，则对应的成员函数将被定义为删除的。


#### 拷贝控制和资源管理

* 编写赋值运算符时，
    * 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
    * 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。一个好的方法是先将右侧运算对象拷贝到一个局部临时变量。当拷贝完成时，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。

* 错误的示范

```c++
// ERROR

HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
	delete ps;
	ps = new string(*rhs.ps); // 如果 rhs和*this是同一个对象，我们无法从已经释放的内存中拷贝数据!
	i = rhs.i;
	return * this;
}
```

* 正确的示范

```c++
// OK

HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
	auto newp = new string(*rhs.ps);
	delete ps;
	ps = newp;
	i = rhs.i;
	return * this;
}
```

* 定义一个引用计数的类

```c++
#include <iostream>

#include <string>

#include <cstddef> // size_t

using namespace std;

class HasPtr
{
public:
	HasPtr(const string& s = string()) :
		ps(new string(s)), i(0), use(new size_t(1)) { }

	HasPtr(const HasPtr& ori) :
		ps(new string(*ori.ps)), i(ori.i), use(ori.use) { ++* use; }

	HasPtr& operator=(const HasPtr& rhs);

	~HasPtr();

	string getPs() { return *ps; }

private:
	string* ps;
	int i;
	size_t* use; // 用来记录有多少个对象共享*ps的成员

};


HasPtr& HasPtr::operator=(const HasPtr& rhs)
{
	++ * rhs.use;
	if (-- * use == 0)
	{
		delete ps;
		delete use;
	}
	ps = rhs.ps;
	i = rhs.i;
	use = rhs.use;
	return * this;
}

HasPtr::~HasPtr()
{
	if (-- * use == 0)
	{
		delete ps;
		delete use;
	}
}


int main()
{
	HasPtr ori("Tong");
	HasPtr sec = ori;
	HasPtr thi;
	thi = ori;
	cout << sec.getPs() << endl;
	cout << thi.getPs() << endl;
}
```

#### 动态内存管理类

```c++

```

#### 对象移动

* 标准库容器，`string`和`shared_ptr`类既支持移动也支持拷贝。`IO`类和`unique_ptr`类可以移动但不能拷贝。

* 右值引用指向将要被销毁的对象。

* 左值引用可绑定
    * 返回左值引用的函数
    * 赋值运算符
    * 下标运算符
    * 解引用
    * 前置递增/递减
    * 变量表达式

* 右值引用或`const`左值引用可绑定
    * 返回非引用类型的函数
    * 算数运算符
    * 关系运算符
    * 位运算符
    * 后置递增/递减运算符

* 左值持久，右值短暂。

* 变量时左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。

* `std::move` 在`<utility>`里。

* 当我们使用`move`时，直接调用`std::move`而不是`move`。

```c++
int&& rr1 = 42; // OK

int&& rr2 = rr1; // ERROR!

int&& rr3 = std::move(rr1); // OK, rr1称作移后源 (moved-from) 对象
```

* 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。

* 一旦资源完成移动，源对象必须不再指向被移动的资源，这些资源的所有权已经归属新创建的对象。

* `noexcept`通知标准库我们的构造函数不抛出任何异常，否则标准库会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。

* 不抛出异常的移动构造函数和移动赋值运算符必须标记为`noexcept`。

* 必须在类头文件的声明中和定义中（如果定义在类外的话）都指定`noexcept`。

* 在移动操作之后，移后源对象必须保持有效的，可析构的状态，但是用户不能对其值进行任何假设。

* 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非`static`数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值匀速那副。

* 什么时候将合成的移动操作定义为删除的函数？
    * 有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符类似。
    * 有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的。
    * 如果类的析构函数被定义为删除的或不可访问的。
    * 如果有类成员是`const`的或是引用，则类的移动赋值运算符被定义为删除的。

* 定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。

* 如果一个类有一个可用地拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”地。

* 移动迭代器 (move iterator)：移动迭代器地解引用运算符生成一个右值引用。我们可以调用`make_move_iterator`函数将一个普通迭代器转换成一个移动迭代器。

* 区分移动和拷贝地重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`。

* 指出`this`左值/右值属性的方式与定义`const`成员函数相同，即，在参数列表后放置一个引用限定符 (reference qualifier) `&`。

```c++
class Foo
{
public:
    Foo& operator=(const Foo&) &; // 只能向可修改的左值赋值

};

Foo& Foo::operator=(const Foo& rhs) &
{
    return * this;
}
```

* 一个函数可以同时用`const`和引用限定。在此情况下，引用限定符必须跟随在`const`限定符之后。

* 如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

```c++
#include <iostream>

#include <vector>

#include <algorithm>

using namespace std;

class Foo
{
public:
	Foo sorted() &&; // 可用于可改变得右值

	Foo sorted() const &; // 可用于任何类型的Foo

private:
	vector<int> data;

};

Foo Foo::sorted() &&
{
	cout << "I am for a right value" << endl;
	sort(data.begin(), data.end());
	return * this;
}

Foo Foo::sorted() const &
{
	cout << "I am for a left value" << endl;
	Foo ret(* this);
	sort(ret.data.begin(), ret.data.end());
	return ret;
}

Foo& retFoo(Foo& f)
{
	return f;
}

Foo retVal()
{
	return Foo();
}

int main()
{
	retVal().sorted(); // 调用Foo::sorted() &&
	Foo f;
	retFoo(f).sorted(); // 调用Foo::sorted() const &
}
```











### 重载类型与类型转换

#### 基本概念

* 当一个重载的运算符是成员函数时，`this`绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。

* 对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。

* 对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。

* 运算符的重载版本无法保留求职顺序和/或短路求值属性。

* 通常情况下，不应该重载逗号，取地址，逻辑与和逻辑或运算符。

* 判断该将运算符定义为成员函数还是普通的非成员函数：
    * 赋值(`=`)，下标(`[]`)，调用(`()`)，和成员访问箭头(`->`)运算符 __必须__ 是成员。
    * 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。
    * 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增(`++`)，递减(`--`)和解引用(`*`)运算符，通常应该是成员。
    * 具有对称性的运算符可能转换任意一端的运算对象，例如算术，相等性，关系和位运算符等，因此它们通常应该是普通的非成员函数。



#### 输入和输出运算符

* 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。

* 输入输出运算符必须是非成员函数。

* `IO`运算符一般被声明为友元。

* 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。

* 当读取操作发生错误时，输入运算符应该负责从错误中恢复。

* 在执行输入运算符时可能发生以下错误：
    * 当流含有错误类型的数据时读取操作可能失败。
    * 当读取操作到达文件末尾或者遇到输入流的其他错误时也会失败。

```c++
#include <iostream>

#include <vector>

std::istream& operator>>(std::istream& is, std::vector<int>& v)
{
	int i;
	while (is >> i)
		v.push_back(i);
	return is;
}

std::ostream& operator<<(std::ostream& os, const std::vector<int>& v)
{
	for (const int& e : v)
		os << e << " ";
	return os;
}

int main()
{
	std::vector<int> v;
	std::cin >> v;
	std::cout << v;
}
```

#### 赋值运算符

* 赋值运算符必须定义成类的成员，复合赋值(`+=`)运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。

```c++
class StrVec
{
public:
    StrVec& operator=(std::initializer_list<std::string>);    
};

StrVec& StrVec::operator=(initializer_list<string> il)
{
    auto data = alloc_n_copy(il.begin(), il.end());
    free();
    elements = data.first;
    first_free = cap = data.second;
    return * this;
}
```

#### 下标运算符

* 下标运算符必须是成员函数。

* 如果一个类包含下标运算符，则通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。



#### 递增和递减运算符

* 定义递增和递减运算符的类应该同时定义迁至版本和后置版本。这些运算符通常应该被定义成类的成员。

* 为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。

* 为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。而且，后置版本接受一个额外的不被使用的`int`类型的形参。

* 要想显式调用后置运算符，我们必须为它的整型参数传递一个值。

```c++
StrBlobPtr& operator++(); //  前置

StrBlobPtr operator++(int); // 后置

p.operator++(0);  // 后置

p.operator++(); // 前置
```

#### 成员访问运算符

* 箭头(`->`)运算符必须是类的成员。

* 解引用(`*`)运算符通常也是类的成员，尽管并非必须如此。

* 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。


#### 函数调用运算符

```c++
#include <functional>
#include <vector>
#include <string>
#include <iostream>
#include <algorithm>

int main() {
  using namespace std::placeholders;

  std::vector<int> vi { 1000, 2000, 3000, 4000, 5000 };
  std::cout << std::count_if(vi.begin(), vi.end(), std::bind(std::greater<int>(), _1, 1024)) << std::endl;

  std::vector<std::string> vs { "pooh", "pooh", "abc", "pooh" };
  std::cout << * std::find_if(vs.begin(), vs.end(), std::bind(std::not_equal_to<std::string>(), _1, "pooh")) << std::endl;

  std::transform(vi.begin(), vi.end(), vi.begin(), std::bind(std::multiplies<int>(), _1, 2));
  for (const auto &i : vi)
    std::cout << i << ' ';
  std::cout << std::endl;

  return 0;
}
```

* 两个不同类型的可调用对象可能共享同一种调用形式 (call signature)。

* 调用形式指明了调用返回的类型以及传递给调用的实参类型。例如`int(int, int)`。

* 可以定义一个函数表(function table)用于存储指向一些可调用对象的“指针”。

* `function`定义在`<functional>`中。

```c++
map<string, fucntion<int(int, int)>> binops = {
	{"+", add},
	{"-", std::minus<int>()},
	{"/", divide()},
	{"*", [](int i, int j) { return i * j; }},
	{"%", mod}
};
```

1_

#### 重载，类型转换与运算符

* 一个类型转换函数必须是类的成员函数，它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是`const`。

* 不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型。

```c++
operator type() const;
```

* 因为`bool`是一种算术类型，所以类类型的对象转换成`bool`后就能用在任何需要算数类型的上下文中。这可能会引发意想不到的结果。如果`istream`含有向`bool`的类型转换时，下面代码将编译通过

```c++
int i =42;
cin << i; // OK, cin转换成bool，然后提升成int，并左移42位
```

* 为了防止异常发生，C++11引入了显式的类型转换运算符 (explicit conversion operator)

```c++
class SmallInt
{
public:
    explicit operator int() const { return val; }    
};

SmallInt si = 3; // OK, 构造函数不是显式的

si + 3; // ERROR!!! 此处需要隐式的类型转换，但类的运算符是显式的

static_cast<int>(si) + 3; // OK, 显式的转换
```

* 我们必须通过显式的强制类型转换才能执行类型转换。存在一个例外，如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。

* 当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。如果它们所需的标准类型转换级别一致，会产生二义性。


```c++
#include <iostream>

using namespace std;

void calc(int a)
{
	cout << "I am int version" << endl;
}

void calc(long double a)
{
	cout << "I am long double version" << endl;
}

int main()
{
	double d = 3.1;
	calc(d);	// ERROR

	short s = 1;
	calc(s); // int version
}
```

* 表达式中运算符的候选函数集既应该包括成员函数，也应该非成员函数。

* 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。




















### 面向对象程序设计

#### OOP：概述

* __面向对象程序设计 (object-oriented programming)__ 的核心思想是数据抽象，继承和动态绑定。

* 使用数据抽象，我们可以将类的接口与实现分离。

* 使用继承，可以定义相似类型并对其相似关系建模。

* 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为 __运行时绑定 (run-time binding)__。

* 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上`virtual`关键字，但是不是必须的。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类地虚函数，具体措施是在该函数地形参列表之后增加一个`override`关键字。

* 在C++语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。

#### 定义基类和派生类

* 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。

* 任何构造函数之外的非静态函数都可以是虚函数。

* 关键字`virtual`只能出现在类内部的声明语句之前，而不能用于类外部的函数定义。

* 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。

* 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。

* `protected`成员：基类希望它的派生类有权访问该成员，同时禁止其他用户访问。

* 派生类必须通过使用 __类派生列表 (class derivation list)__ 明确指出它是从哪个（哪些）基类继承而来的。

* 类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：`public`, `protected`, `private`。

* 我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方；同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。

* 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。

* 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。

* C++11新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字`final`。

* 表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。

* 基类的指针或引用的静态类型可能与其动态类型不一致。

* 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。

* 不能将基类转换成派生类。

* 派生类向基类的自动类型转换只对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

* 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝，移动或赋值，它的派生类部分将被忽略掉。

#### 虚函数

* 我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为编译器也无法确定到底会使用哪个虚函数。

* 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

* OOP的核心思想是多态性 (polymorphism)。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种类型”而无须在意它们的差异。引用或指针的静态类型与动态类型不同这一事实正是C++语言支持多态性的根本存在。

* 基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的型参必须与派生类中的形参严格匹配。

* 如果我们使用`override`标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错。

* 如果我们已经把函数定义成`final`了，则之后任何尝试覆盖该函数的操作都将引发错误。

* 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

* 如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的派生类中的函数版本。此时，传入派生类函数的将是基类函数定义的默认实参。

* 通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。


#### 抽象基类

*  和普通的虚函数不一样，一个纯虚函数无须定义。

* 我们通过在函数体的位置（即在声明语句的分号之前）书写`=0`就可以将一个虚函数说明为纯虚函数。`=0`只能出现在类内部的虚函数声明语句处。

* 我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个`=0`的函数提供函数体。

* 含有（或者未经覆盖直接继承）纯虚函数额类是抽象基类 (abstract base class)。

* 我们不能创建抽象基类的对象。

* 抽象基类负责定义接口，而后续的其他类可以覆盖该接口。

* 重构 (refactoring) 负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。

#### 访问控制与继承

* `proctected`成员
    * 对于类的用户来说是不可访问的。
    * 对于派生类的成员和友元来说是可访问的。
    * 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。

```c++
class Base
{
protected:
    int prot_mem;    
};

class Sneaky : public Base
{
    friend void clobber(Sneaky&); // 能访问Sneaky::prot_mem

    friend void clobber(Base&); // 不能访问Base::prot_mem

};
```

* 派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。

* 派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。

* 如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行

* 就像友元关系不能传递一样，友元关系同样也不能继承。

* 有时我们需要改变派生类继承的某个名字的访问级别，通过使用`using`声明可以达到这一目的。

```c++
class Derived : private Base
{
public:
    using Base::size;
protected:
    using Base::n;
};
```

* 默认情况下，使用`class`关键字定义的派生类是私有继承的；而使用`struct`关键字定义的派生类是公有继承的。

```c++
class Base {
public:
  void pub_mem(); // public member

protected:
  int prot_mem; // protected member

private:
  char priv_mem; // private member

};

struct Pub_Derv : public Base {
  // ok: derived classes can access protected members

  int f() { return prot_mem; }

  // error: private members are inaccessible to derived classes

  //char g() { return priv_mem; }

};

struct Priv_Derv : private Base {
  // ok: private derivation doesn’t affect access in the derived class

  int f() { return prot_mem; }

  // error: private members are inaccessible to derived classes

  //char g() { return priv_mem; }

};

struct Prot_Derv : protected Base {
  // ok: derived classes can access protected members

  int f() { return prot_mem; }

  // error: private members are inaccessible to derived classes

  //char g() { return priv_mem; }

};

struct Derived_from_Public : public Pub_Derv {
  // ok: Base::prot_mem remains protected in Pub_Derv
  int use_base() { return prot_mem; }
};

struct Derived_from_Private : public Priv_Derv {
  // error: Base::prot_mem is private in Priv_Derv

  //int use_base() { return prot_mem; }

};

struct Derived_from_Protected : public Prot_Derv {
  // ok: Base::prot_mem remains protected in Prot_Derv

  int use_base() { return prot_mem; }
};

int main() {
  Pub_Derv d1; Priv_Derv d2; Prot_Derv d3;
  Derived_from_Public dd1; Derived_from_Private dd2; Derived_from_Protected dd3;
  // Below are user code
  Base * p = &d1;  // legal

  p = &d2;        // illegal, user code may use the derived-to-base conversion
                  // only if D inherits publicly from B

  p = &d3;        // illegal, same reason as d2

  p = &dd1;       // legal

  p = &dd2;       // illegal, same reason as d2

  p = &dd3;       // illegal, same reason as d2

  return 0;
}
```


#### 继承中的类作用域

* 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

* 一个对象，引用或指针的静态类型决定了该对象的哪些成员是可见的。

* 派生类的成员将隐藏同名的基类成员。

* 定义派生类中的函数不会重载其基类中的成员。

* 如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉。

* 基类与派生类中的虚函数必须有相同的形参列表。假如基类与派生类的函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。

* 有时一个类仅需覆盖重载集合中的一些而非全部函数，此时，如果我们不得不覆盖基类中的每一个版本的话，显然操作将极其繁琐。

#### 构造函数与拷贝控制

* 如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。

* 如果一个类定义了析构函数，即使它通过`=default`的形式使用了合成的版本，编译器也不会为这个类合成移动操作。

* 派生类中删除的拷贝控制与基类的关系
    * 如果基类中的默认构造函数，拷贝构造函数，拷贝赋值运算或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造，赋值或销毁操作。
    * 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
    * 编译器将不会合成一个删除掉的移动操作。当我们使用`=default`请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。

* 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

* 和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。派生类的基类部分也是自动销毁的。

* 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。

* 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。

* 对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推。

* 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。

* 派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的`using`声明语句。

* 通常情况下，`using`声明语句只是令某个名字在当前作用域内可见。而当作用与构造函数时，`using`声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。

* 如果派生类含有自己的数据成员，则这些成员将被默认初始化。

```c++
class Bulk_quote : public Disc_quote
{
public:
    using Disc_quote::Disc_quote;
    double net_price(std::size_t) const;
};

// 等价于下面

class Bulk_quote : public Disc_quote
{
public:
    Bulk_quote(const std::string& book, double price, std::size_t qty, double disc) :
        Disc_quote(book, price, qty, disc) { }
    double net_price(std::size_t) const;
};
```

* 和普通成员的`using`声明不一样，一个构造函数的`using`声明不会改变该构造函数的访问级别。

* 一个`using`声明语句不能指定`explicit`或`constexpr`。如果基类的构造函数是`explicit`或者`constexpr`，则继承的构造函数也拥有相同的属性。

* 当一个基类构造函数默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。例如，如果一个基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。

* 如果基类含有几个构造函数，则除了两个例外，大多数时候派生类会继承所有这些构造函数：
    * 第一个例外是派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。
    * 第二个例外是默认，拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用。因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数。



#### 容器与继承

* 当派生类对象赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。

* 当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（或智能指针）。这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。

#### 文本查询程序再探

* `Is A`: 当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种 (Is A)”关系。在设计良好的类体系中，公有派生类的对象应该可以用在任何需要基类对象的地方。

* `Has A`:具有这种关系的类暗含成员的意思。





















### 模板与泛型编程

* 一个模板就是一个创建类或函数的蓝图或者说公式。

#### 定义模板

* 模板定义以关键字`template`开始，后跟一个模板参数列表 (template parameter list)，这是一个逗号分隔的一个或多个模板参数的列表。

* 在模板定义中，模板参数列表不能为空。类型参数前必须使用关键字`class`或`typename`。这两个关键字含义相同，可以互换使用。

```c++
template <typename T>
int compare(const T& v1, const T& v2)
{
	if (v1 < v2) return -1;
	if (v2 < v1) return 1;
	return 0;
}
```

* 一个非类型参数 (nontype parameter) 表示一个值而非一个类型。非类型模板参数的模板实参必须是常量表达式。

* 我们不能用一个普通（非`static`）局部变量或动态对象作为指针或引用非类型模板参数的实参。

```c++
template<unsigned N, unsigned M>
int compare(const char(&p1)[N], const char(&p2)[M])
{
	return strcmp(p1, p2);
}

// 如果我们调用 compare("hi", "mom");

// 编译器会实例化出如下版本

// int compare(const char(&p1)[3], const char(&p2)[4])
```

* 当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。当我们使用（而不是定义）模板时，编译器才生成代码，这一特性影响了我们如何组织代码以及错误何时被检测到。

* 为了生成一个模板的实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。

* 函数模板和类模板成员函数的定义通常放在头文件中。

* 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。

* 一个类模板的每个实例都形成一个独立的类。类型`Blob<string>`与任何其他`Blob`类型都没有关联，也不会对任何其他`Blob`类型的成员有特殊访问权限。

* 默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。

```c++
#pragma once

#include <vector>

#include <memory>

#include <utility> // move

#include <initializer_list>

#include <string>

using namespace std;

template <typename T>
class Blob
{
public:
	typedef T value_type;
	typedef typename vector<T>::size_type size_type;

	Blob();
	Blob(initializer_list<T> il);

	size_type size() const { return data->size(); }
	bool empty() const { return data->empty(); }
	void push_back(const T& t) { data->push_back(t); }
	void push_back(T&& t) { data.push_back(std::move(t)); }

	void pop_back();

	T& back();
	T& operator[](size_type i);

private:
	shared_ptr<vector<T>> data;
	void check(size_type i, const string& msg) const;
};

template <typename T>
void Blob<T>::check(size_type t, const string& msg) const
{
	if (i >= data->size())
		throw out_of_range(msg);
}

template <typename T>
T& Blob<T>::back()
{
	check(0, "back on empty Blob");
	return data->back();
}

template <typename T>
void Blob<T>::pop_back()
{
	check(0, "pop_back on empty Blob");
	data->pop_back();
}

template <typename T>
Blob<T>::Blob() : data(make_shared<vector<T>>()) { }

template <typename T>
Blob<T>::Blob(initializer_list<T> il) : data(make_shared<vector<T>>(il)) { }
```

* 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。

* 当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。

* 为了让所有实例称为友元，友元声明中必须使用与类模板本身不同的模板参数。

* C++ 11中，我们可以将模板类型参数声明为友元。因此，对于某个类型名`Foo`，`Foo`将成为`Bar<Foo>`的友元。

```c++
template <typename T>
class binary
{
    friend T;
};
```

* C++ 11允许我们为类模板定义一个类型别名。

```c++
template <typename T> using twin = pair<T, T>;
twin<string> authors; // authors is pair<string, string>
```

* 一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。

* 模板参数会隐藏外层作用域中声明的相同名字。

* 在模板内不能宠用模板参数名。

* 一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。

* 默认情况下，C++语言假定通过作用域运算符访问的是名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字。

```c++
template <typename T>
typename T::value_type top(const T& c)
{
    /*...*/
}
```

* 当我们希望通知编译器一个名字表示类型时，必须使用关键字`typename`，而不能使用`class`。

* C++ 11中，我们可以为函数和类模板提供默认实参。

* 对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。

* 一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为 __成员模板 (member template)__。成员模板不能是虚函数。

* 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表。

* 当模板使用时才会进行实例化意味着，相同的实例可能出现在多个对象文件中。在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过 __显式实例化 (explicit instantiation)__ 来避免这种开销。

```c++
extern template class Blob<string>; // 声明

template int compare(const int&, const int&); //定义
```

* 对于每个实例化声明，在程序中某个位置必须有其显式的实例化定义。

* 一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。

* 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。

* [实例化什么时候发生？](https://stackoverflow.com/questions/21598635/how-is-a-template-instantiated)
    * notice the pointer/reference stuff: they don't require instantiation since no data is actually allocated (a pointer is just a few bytes to contain the address, has no need to have all the data stored.)
    * Only when stuff is allocated then the template has to be completely resolved (and that happens at compile-time, that's why they usually need both declaration and definition.. there's no linking phase yet)

```c++
#include <iostream>
#include <string>

using namespace std;


template <typename T> class Stack {
  typedef typename T::ThisDoesntExist StaticAssert; // T::NotExisting doesn't exist at all!
};


void f1(Stack<char>); // No instantiation, compiles

class Exercise {
  Stack<double> &rsd; // No instantiation, compiles (references don't need instantiation, are similar to pointers in this)

  Stack<int>    si; // Instantiation! Doesn't compile!!
};


int main(){

  Stack<char> * sc; // No Instantiation, this compiles successfully since a pointer doesn't need instantiation

  f1(*sc); // Instantiation of Stack<char>! Doesn't compile!!

  int iObj = sizeof(Stack<string>); // Instantiation of Stack<string>, doesn't compile!!

}
```

* `shared_ptr`和`unique_ptr`
    * 第一个明显不同是它们管理所保存的指针的策略-前者给予我们共享指针所有权的能力；后者则独占指针。
    * 另一个差异是它们允许用户重载默认删除器的方式。我们可以很容易地重载一个`shared_ptr`的删除器，只要在创建或`reset`指针时传递给它一个可调用对象即可。与之相反，删除器的类型是一个`unique_ptr`对象的类型的一部分。用户必须在定义`unique_ptr`时以显示模板实参的形式提供删除器的类型。

* 通过在编译时绑定删除器，`unique_ptr`避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，`shared_ptr`使用户重载删除器更为方便。

* 实现`shared_ptr`

```c++
#pragma once

#include <cstddef> // size_t
#include <functional> // function
#include <utility> // move

using std::size_t;
using std::function;

namespace custom_pointer
{

	struct Delete
	{
		template <typename T>
		auto operator() (T* p) const { delete p; }
	};

	template <typename T> class shared_ptr;

	template <typename T> void swap(shared_ptr<T>& lhs, shared_ptr<T>& rhs)
	{
		std::swap(lhs.ptr, rhs.ptr);
		std::swap(lhs.ref_count, rhs.ref_count);
		std::swap(lhs.deleter, rhs.deleter);
	}

	template <typename T>
	class shared_ptr
	{
	public:
		shared_ptr() : ptr(nullptr), ref_count{ new size_t(1) }, deleter(Delete()) { }

		explicit shared_ptr(T* raw_ptr) : ptr(raw_ptr), ref_count(new size_t(1)), deleter(Delete()) { }

		shared_ptr(const shared_ptr& other) : ptr(other.ptr), ref_count(other.ref_count), deleter(other.deleter)
		{
			++* ref_count;
		}

		shared_ptr(shared_ptr&& other) noexcept : ptr(other.ptr), ref_count(other.ref_count), deleter(std::move(other.deleter))
		{
			other.ptr = nullptr;
			other.ref_count = nullptr;
		}

		shared_ptr& operator=(const shared_ptr& rhs)
		{
			// increment first to ensure safty for self-assignment

			++* rhs.ref_count;
			decrement_and_destroy();
			ptr = rhs.ptr;
			ref_count = rhs.ref_count;
			deleter = rhs.deleter;
			return *this;
		}

		shared_ptr& operator=(shared_ptr&& rhs) noexcept
		{
			custom_pointer::swap(*this, rhs);
			rhs.decrement_and_destroy();
			return *this;
		}

		operator bool() const { return ptr ? true : false; }

		T& operator*() const { return *ptr; }

		T* operator->() const { return &*ptr; }

		size_t use_count() const { return *ref_count; }

		T* get() const { return ptr; }

		bool unique() const { return 1 == *ref_count; }

		void swap(shared_ptr& rhs) { custom_pointer::swap(*this, rhs); }

		void reset() { decrement_and_destroy(); }

		void reset(T* other_ptr)
		{
			if (ptr != other_ptr)
			{
				decrement_and_destroy();
				ptr = other_ptr;
				ref_count = new size_t(1);
			}
		}

		void reset(T* other_ptr, const function<void(T*)>& d)
		{
			reset(other_ptr);
			deleter = d;
		}

		~shared_ptr() { decrement_and_destroy(); }

	private:
		T* ptr;
		size_t* ref_count;
		function<void(T*)> deleter;

		void decrement_and_destroy()
		{
			if (ptr && (0 == -- * ref_count))
			{
				delete ref_count;
				deleter(ptr);
			}
			else if (!ptr)
			{
				delete ref_count;
			}
			ref_count = nullptr;
			ptr = nullptr;
		}
	};
}
```

* 实现`unique_ptr`

```c++
#pragma once

#include <cstddef> // size_t, nullptr_t
#include <functional> // function
#include <utility> // move
#include <iostream>

using std::size_t;
using std::function;
using std::ostream;
using std::cerr;
using std::endl;

namespace custom_pointer
{

	class DebugDelete
	{
	public:
		DebugDelete(ostream& s = cerr) : os(s) { }

		template <typename T>
		void operator() (T* p) const
		{
			os << "deleting ptr" << endl;
			delete p;
		}

	private:
		ostream& os;
	};

	template <typename, typename> class unique_ptr;

	template <typename T, typename D>
	void swap(unique_ptr<T, D>& lhs, unique_ptr<T, D>& rhs)
	{
		std::swap(lhs.ptr, rhs.ptr);
		std::swap(lhs.deleter, rhs.deleter);
	}

	template <typename T, typename D = DebugDelete>
	class unique_ptr
	{
		friend void swap<T, D>(unique_ptr<T, D>& lhs, unique_ptr<T, D>& rhs);

	public:
		unique_ptr(const unique_ptr&) = delete;
		unique_ptr& operator=(const unique_ptr&) = delete;



		unique_ptr() = default;
		explicit unique_ptr(T* raw_ptr) : ptr(raw_ptr) { }

		unique_ptr(unique_ptr&& other) noexcept : ptr(other.ptr)
		{
			other.ptr = nullptr;
		}

		unique_ptr& operator=(unique_ptr&& rhs) noexcept
		{
			if (this->ptr != rhs.ptr)
			{
				deleter(ptr);
				ptr = nullptr;
				custom_pointer::swap(*this, rhs);
			}
			return *this;
		}

		unique_ptr& operator=(nullptr_t n) noexcept
		{
			if (n == nullptr)
			{
				deleter(ptr);
				ptr = nullptr;
			}
			return *this;
		}


		operator bool() const { return ptr ? true : false; }

		T& operator*() const { return *ptr; }

		T* operator->() const { return &*ptr; }

		T* get() const { return ptr; }

		void swap(unique_ptr& rhs) { custom_pointer::swap(*this, rhs); }

		void reset()
		{
			deleter(ptr);
			ptr = nullptr;
		}

		void reset(T* other_ptr)
		{
			if (ptr != other_ptr)
			{
				deleter(ptr);
				ptr = other_ptr;
			}
		}

		T* release()
		{
			T* ret = ptr;
			ptr = nullptr;
			return ret;
		}

		~unique_ptr() { deleter(ptr); }

	private:
		T* ptr;
		D deleter = D();
	};
}
```


#### 模板实参推断

* `顶层const`无论是在形参中还是在实参中，都会被忽略。

* 能在调用中应用于函数模板的类型转换只包括如下两项：
    * `const`转换：可以将一个非`const`对象的引用（或指针）传递给一个`const`的引用（或指针）形参。
    * 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。

* 将实参传递给带模板类型的形参时，能够自动应用的类型转换只有`const`转换及数组或函数到指针的转换。

* 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。

```c++
template <class T> int compare(const T&, const T&);

compare("hi", "world"); // ERROR!!! (char[3], char[6])

compare("bye", "dad"); // OK, (char*, char*)
```

```c++
template <typename T> T calc(T, int);
template <typename T> T fcn(T, T);

double d;
float f;
char c;

calc(c, 'c'); // OK. T is a char

calc(d, f); // OK. T is a double

fcn(c, 'c'); // OK. T is a char

fcn(d, f); // ERROR!!! (double, float) 不一致
```

```c++
template <typename T> f1(T, T);
template <typename T1, typename T2) f2(T1, T2);
int i = 0;
int j = 42;
int* p1 = &i;
int* p2 = &j;
const int* cp1 = &i;
const int* cp2 = &j;

f1(p1, p2); // f1<int*>(int*, int*)

f2(p1, p2);  // f2<int*, int*>(int*, int*)

f1(cp1, cp2); // f1<const int*>(const int*, const int*)

f2(cp1, cp2); // f2<const int*, const int*>(const int*, const int*)

f1(p1, cp1); // ERROR!!! (int*, const int*)

f2(p1, cp1); // f2<int*, const int*>(int*, const int*)
```

* 用户可以提供一个显式模板实参 (explicit template argument)

```c++
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3); // T1 无法推断

auto val3 = sum<long long>(i, lng); // long long sum(int, long)
```

* 显式模板实参按由左至右的顺序与对应的模板参数匹配。

```c++
template <typename T1, typename T2, typename T3>
T3 sum(T2, T1); // T1 无法推断

auto val3 = sum<long long>(i, lng); // ERROR! 无法推断，long long匹配的是T1

auto val2 = sum<long long, int, long>(i, lng); // OK
```

* 尾置返回类型与类型转换

```c++
#include <type_traits>

using std::remove_reference;

template <typename It>
auto fcn2(It beg, It end) -> decltype(*beg)
{
	return *beg;	// 返回一个元素的引用

}

template <typename It>
auto fcn2(It beg, It end) -> decltype(*beg + 0)
{
	return *beg;	// 返回一个元素的拷贝

}

template <typename It>
auto fcn2(It beg, It end) -> typename remove_reference<decltype(* beg)>::type
{
	return * beg;	// 返回一个元素的拷贝

}
```

* 引用折叠：对于一个给定类型`X`,
    * `X& &`, `X& &&`, `X&& &`都折叠成类型`X&`
    * `X&& &&`折叠成`X&&`

* 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。

```c++
template <typename T> void f1(T&);
template <typename T> void f2(const T&);
template <typename T> void f3(T&&);

f1(i); // T: int

f1(ci); // T: const int

f1(5); // ERROR!

f2(i); // T: int

f2(ci); // T: int

f2(5); // T: int

f3(i); // T: int&

f3(ci); // T: const int&

f3(5); // T: int

```

* 如果一个函数参数是指向模板参数类型的右值引用（如，`T&&`），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（`T&`）。

* `std::move`是一个使用右值引用模板很好的例子。

```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```


* 如果一个函数参数是指向模板类型参数的右值引用（如`T&&`），它对应的实参的`const`属性和左值/右值属性将得到保持。

* 当用于一个指向模板参数类型的右值引用函数参数（`T&&`）时，`forward`会保持实参类型的所有细节。

* 与`std::move`相同，对`std::forward`不适用`using`声明是一个好主意。(`<utility>`)

```c++
template <typename F, typename T1, typename T2>
void flip(F f, T1&& t1, T2&& t2)
{
    f(std::forward<T2>(t2), std::forward<T1>(t1));
}
```

#### 重载与模板

#### 可变参数模板

#### 模板特例化














### 多线程

#### 实现方式







### RTTI (Runtime Type Information)








### OpenCV

#### cv::Mat如何析构




### cmake


```cmake
cmake_minimum_required(VERSION 2.8)
project(myslam)

set(CMAKE_BUILD_TYPE Release)

set(CMAKE_CXX_FLAGS "-std=c++11 -Wall")
set(CMAKE_CXX_FLAGS_RELEASE  "-std=c++11 -O3 -fopenmp -pthread")

list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake_modules)
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin)
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)

############### dependencies ######################
# Eigen
include_directories("/usr/include/eigen3")

# OpenCV
find_package(OpenCV 3.1 REQUIRED)
include_directories(${OpenCV_INCLUDE_DIRS})

# pangolin
find_package(Pangolin REQUIRED)
include_directories(${Pangolin_INCLUDE_DIRS})

# Sophus
find_package(sophus REQUIRED)
include_directories(${sophus_INCLUDE_DIRS})

# G2O
# find_package(G2O REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/g2o/)

# glog
#find_package(Glog REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/glog/)

# gtest
find_package(GTest REQUIRED)
include_directories(${GTEST_INCLUDE_DIRS})

# gflags
# find_package(GFlags REQUIRED)
include_directories(${PROJECT_SOURCE_DIR}/thirdparty/gflags/)

# csparse
find_package(CSparse REQUIRED)
include_directories(${CSPARSE_INCLUDE_DIR})

set(THIRD_PARTY_LIBS
        ${OpenCV_LIBS}
        ${sophus_LIBRARIES}
        ${Pangolin_LIBRARIES} GL GLU GLEW glut
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_core.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_stuff.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_types_sba.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_solver_csparse.so
        ${PROJECT_SOURCE_DIR}/thirdparty/g2o/lib/libg2o_csparse_extension.so
        ${GTEST_BOTH_LIBRARIES}
        ${PROJECT_SOURCE_DIR}/thirdparty/glog/build/libglog.a
        ${PROJECT_SOURCE_DIR}/thirdparty/gflags/build/lib/libgflags.a
        pthread
        ${CSPARSE_LIBRARY}
        )

enable_testing()
############### source and test ######################
include_directories(${PROJECT_SOURCE_DIR}/include)
add_subdirectory(src)
add_subdirectory(test)
add_subdirectory(app)
```


```cmake
# src/CMakeLists.txt
add_library(myslam SHARED
        frame.cc
        mappoint.cc
        map.cc
        camera.cc
        config.cc
        feature.cc
        frontend.cc
        backend.cc
        viewer.cc
        visual_odometry.cc
        dataset.cc)

target_link_libraries(myslam
        ${THIRD_PARTY_LIBS})
```




### Eigen

#### 行优先还是列有限




### 数据结构

#### 四叉树

#### cv::Mat
