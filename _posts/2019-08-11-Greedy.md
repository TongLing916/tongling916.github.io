---
layout:     post
title:      "Greedy"
date:       2019-8-11
author:     Tong
catalog: true
tags:
    - Algorithm
---

### Summary

1.

### [55\. Jump Game](https://leetcode.com/problems/jump-game/)

Difficulty: **Medium**


Given an array of non-negative integers, you are initially positioned at the first index of the array.

Each element in the array represents your maximum jump length at that position.

Determine if you are able to reach the last index.

**Example 1:**

```
Input: [2,3,1,1,4]
Output: true
Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
```

**Example 2:**

```
Input: [3,2,1,0,4]
Output: false
Explanation: You will always arrive at index 3 no matter what. Its maximum
             jump length is 0, which makes it impossible to reach the last index.
```


#### Solution

Language: **C++**

```c++
//Given an array of non - negative integers, you are initially positioned at the first index of the array.
//
//Each element in the array represents your maximum jump length at that position.
//
//Determine if you are able to reach the last index.
//
//Example 1:
//Input: [2, 3, 1, 1, 4]
//Output: true
//Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
//
//Example 2:
//Input: [3, 2, 1, 0, 4]
//Output: false
//Explanation: You will always arrive at index 3 no matter what.
//Its maximum jump length is 0, which makes it impossible to reach the last index.

#include <algorithm>

#include <iostream>

#include <vector>

using namespace std;

// find if the last step which can arrive n - 1 is the first index
class Solution1 {
public:
	bool canJump(vector<int>& nums) {
		ios::sync_with_stdio(0);
		cin.tie(0);
		int n = nums.size();
		int lastJump = n - 1;
		for (int i = n - 2; i >= 0; --i)
			if (i + nums[i] >= lastJump)
				lastJump = i;

		return (lastJump == 0) ? true : false;

	}
};

// check how far we can get from the first index
class Solution2 {
public:
	bool canJump(vector<int>& nums) {
		int n = nums.size();
		if (n == 0) return true;
		int start = 1;
		int end = nums[0];
		while (start <= end && end < n)
		{
			int max_end = 0;
			for (int i = start; i <= end; ++i)
				max_end = std::max(max_end, i + nums[i]);
			start = end + 1;
			end = max_end;
		}
		if (end >= n - 1) return true;
		return false;
	}
};

int main()
{
	vector<int> test1{ 3,2,1,0,4 };
	vector<int> test2{ 2,3,1,1,4 };
	Solution1 solution;
	cout << solution.canJump(test1) << endl;
	cout << solution.canJump(test2) << endl;
}

```


### [134\. Gas Station](https://leetcode.com/problems/gas-station/)

Difficulty: **Medium**


There are _N_ gas stations along a circular route, where the amount of gas at station _i_ is `gas[i]`.

You have a car with an unlimited gas tank and it costs `cost[i]` of gas to travel from station _i_ to its next station (_i_+1). You begin the journey with an empty tank at one of the gas stations.

Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.

**Note:**

*   If there exists a solution, it is guaranteed to be unique.
*   Both input arrays are non-empty and have the same length.
*   Each element in the input arrays is a non-negative integer.

**Example 1:**

```
Input:
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]

Output: 3

Explanation:
Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 4\. Your tank = 4 - 1 + 5 = 8
Travel to station 0\. Your tank = 8 - 2 + 1 = 7
Travel to station 1\. Your tank = 7 - 3 + 2 = 6
Travel to station 2\. Your tank = 6 - 4 + 3 = 5
Travel to station 3\. The cost is 5\. Your gas is just enough to travel back to station 3.
Therefore, return 3 as the starting index.
```

**Example 2:**

```
Input:
gas  = [2,3,4]
cost = [3,4,3]

Output: -1

Explanation:
You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
Travel to station 0\. Your tank = 4 - 3 + 2 = 3
Travel to station 1\. Your tank = 3 - 3 + 3 = 3
You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
Therefore, you can't travel around the circuit once no matter where you start.
```

#### Train of Thought

1. 如果从A出发只能到H，那么从A与H间任意一点出发，我们也只能到H。

2. 如果总的gas比总的cost要多，那么一定存在一个解。


#### Solution

Language: **C++**

```c++
#include <vector>

#include <iostream>

using namespace std;

class Solution {
public:
	int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
		int n = gas.size();
		int gas_left = 0;
		int start = 0;
		int cur_left = 0;
		for (int i = 0; i < n; ++i)
		{
			cur_left += gas[i] - cost[i];
			gas_left += gas[i] - cost[i];
			if (cur_left < 0)
			{
				start = i + 1;
				cur_left = 0;
			}
		}
		return gas_left < 0 ? -1 : start;
	}
};

int main()
{
	vector<int> gas{ 2,3,4 };
	vector<int> cost{ 3,4,3 };
	Solution solution;
	cout << solution.canCompleteCircuit(gas, cost) << endl;
}

```

### [376\. Wiggle Subsequence](https://leetcode.com/problems/wiggle-subsequence/)

Difficulty: **Medium**


A sequence of numbers is called a **wiggle sequence** if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.

For example, `[1,7,4,9,2,5]` is a wiggle sequence because the differences `(6,-3,5,-7,3)` are alternately positive and negative. In contrast, `[1,4,7,2,5]` and `[1,7,4,5,5]` are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.

Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.

**Example 1:**

```
Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.
```


**Example 2:**

```
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].
```


**Example 3:**

```
Input: [1,2,3,4,5,6,7,8,9]
Output: 2
```

**Follow up:**  
Can you do it in O(_n_) time?


#### Train of Thought

首先，如果只有0个或1个元素的话，我们就不需要验证了。

如果有2个元素，我们可以通过验证这两个元素是否相等，然后再决定返回值。

如果有2个以上元素，我们可以遍历一遍列表，判断difference的正负号变了多少次（如果是0的话，那就忽略。但是数组开头的0需要谨慎对待）。

例子：`1, 17, 5, 10, 13, 15, 10, 5, 16, 8`。两两相减，其中差为`16, -12, 5, 3, 2, -5, -5, 11, -8`。缩减过后，我们得到`16, -12, 10, -10, 11, -8`。一共6个difference，所以一共7个数。


#### Solution

Language: **C++**

```c++
#include <vector>

#include <iostream>

using namespace std;

class Solution {
public:
	int wiggleMaxLength(vector<int>& nums) {
		int n = nums.size();
		if (n <= 1) return n;
		if (n == 2)
			if (nums[1] - nums[0]) return 2;
			else return 1;

		int last_diff = nums[1] - nums[0];
		int cnt = (last_diff != 0) ? 1 : 0; // count the number of differences
		for (int i = 2; i < n; ++i)
		{
			int cur_diff = nums[i] - nums[i - 1];
			if (cur_diff == 0) continue;
			if ((cur_diff > 0 && last_diff <= 0) || (cur_diff < 0 && last_diff >= 0))
			{
				++cnt;
				last_diff = cur_diff;
			}
		}
		return cnt + 1;
	}
};

int main()
{
	vector<int> nums1{ 3, 3, 3 };
	vector<int> nums2{ 0, 0 };
	vector<int> nums3{ 1,7,4,9,2,5 };
	vector<int> nums4{ 1,17,5,10,13,15,10,5,16,8 };
	vector<int> nums5{ 1,2,3,4,5,6,7,8,9 };
	Solution solution;
	cout << solution.wiggleMaxLength(nums1) << endl;
	cout << solution.wiggleMaxLength(nums2) << endl;
	cout << solution.wiggleMaxLength(nums3) << endl;
	cout << solution.wiggleMaxLength(nums4) << endl;
	cout << solution.wiggleMaxLength(nums5) << endl;
}
```
